<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=0.45"/>
  <title>末日控制中心 - 正式版v.1.102 pve-coop update</title>
  <style>
    /* 彈窗系統 */
    .modal-overlay {
	  position: fixed;
	  top: -50px;
	  left: -50px;
	  right: -50px;
	  bottom: -100px;
	  background: rgba(0,0,0,0.7);
	  display: none;
	  z-index: 1000;
	  pointer-events: auto;
	  overscroll-behavior: none;
	  transform: translateZ(0);
	}

	.modal-content {
	  background: #2d2d2d;
	  padding: 2rem;
	  border-radius: 12px;
	  width: min(90vw, 500px);
	  max-height: 80vh;
	  overflow-y: auto;
	  overflow-x: visible; /* 允許水平顯示 */
	  overscroll-behavior-y: contain; /* 仅对垂直方向阻止滚动传播 */
	  overscroll-behavior-x: auto;    /* 水平方向允許默认处理 */
	  -webkit-overflow-scrolling: touch; /* 启用弹性滚动 */
	  position: fixed !important; /* 改用fixed定位 */
	  left: 50% !important;
	  top: 20vh;
	}
	.modal-overlay.nested {
	  overflow: hidden;
	  position: absolute !important;      /* 以相對於父容器定位 */
	  top: 0 !important;                  /* 上緣貼齊容器頂部 */
	  left: 0;
	  width: 100%;
	  height: 100%;
	  background: rgba(0,0,0,0.7);
	  display: none;
	  z-index: 1000;
	  scrollbar-width: none;
	}
	.modal-overlay.nested::-webkit-scrollbar {
	  display: none;           /* Chrome, Safari, Opera 隱藏滾動條 */
	}

	/* 嵌套彈窗內部：上緣貼齊、水平居中（不做垂直居中） */
	.modal-overlay.nested .modal-content {
	  position: absolute !important;
	  top: 0 !important;                 /* 上緣緊貼基地建設容器上緣 */
	  left: 50% !important;              /* 水平居中 */
	  transform: translateX(-50%) !important;
	  background: #2d2d2d !important;
	  padding: 2rem;
	  border-radius: 12px;
	  width: min(90vw, 500px);
	  max-height: 80vh;
	  box-sizing: border-box;
	}

	#upgradeModal .modal-content {
	  position: absolute;
	  left: 50%;
	  transform: translate(-50%, 0); /* 使其居中 */
	}
	#resultModal .modal-content {
	  position: absolute;
	  left: 50%;
	  transform: translate(-50%, 0);
	}
	#resultModal .modal-content,
	#resultModal .modal-content p {
		text-align: center;
	}
	#buildModal .modal-content {
	  background: #2d2d2d;
	  padding: 2rem;
	  border-radius: 12px;
	  width: 450px;
	  height: 500px;
	  overflow-y: hidden;
	  position: fixed;
	  left: 50%;
	  top: 70%; 
	  transform: translate(-50%, -60%);
	}
	/* 建造彈窗中選項內容區讓其內部滾動 */
	#buildModal .build-options {
	  max-height: 400px; /* 根據實際需求調整 */
	  overflow-y: auto;
	}




	/* 收藏彈窗繼承現有 modal 的樣式，若需要與行動日誌區重合，可加入如下設定 */
	#favoritesModal .modal-content,
	#productionCollectionModal .modal-content {
	  width: 60%;         /* 或直接與行動日誌區同寬 */
	  max-width: 400px;    /* 根據行動日誌所在區域調整 */
	  overflow-x: visible;
	}
	html {
	  touch-action: manipulation;
	}
	html, body {
	  overscroll-behavior: none;
	}
	
	.log {
	  overflow-y: scroll;
	  overflow-anchor: none;
	  scrollbar-gutter: stable;
	}

    :root {
	  --btr-frame-height: 120px;
	  --btr-frame-width: calc(2000 * var(--btr-frame-height) / 500);  /* 1000 * 120/500 = 240px */
	  --btr-sprite-total-width: calc(4 * var(--btr-frame-width));
	
	  --exploration-height: 120px;
	  /* 无缝背景图原始比例为3:1，tile 宽度根据窗口高度自动计算 */
	  --tile-width: calc(var(--exploration-height) * 3);
	  --zombie-size: 90px;
	  /* 精靈圖總寬度 = 幀數 × 單帧寬度，由於共 4 幀 */
	  --zombie-sprite-total-width: calc(4 * var(--zombie-size));
      --bg-color: #1a1a1a;
      --text-color: #e0e0e0;
      --border-color: #4a4a4a;
      --hover-bg: #333333;
       /* 基础级别 - 提升亮度和饱和度 */
	  --junk: #ab4826;     /* 亮棕色 (原色亮度↑35%) */
	  --old: #d68569;      /* 浅灰棕 (原色亮度↑30%) */
	  --damaged: #d69e69;  /* 浅米灰 (原色亮度↑25%) */
	  
	  /* 普通级别 - 增强对比度 */
	  --common: #BDBDBD;   /* 亮灰色 (原色亮度↑30%) */
	  --decent: #66BB6A;   /* 鲜绿色 (原色亮度↑15%) */
	  --sealed: #26A69A;   /* 亮青绿 (原色亮度↑20%) */
	  
	  /* 精良级别 - 保持专业感但提亮 */
	  --selected: #42A5F5; /* 亮蓝色 (原色亮度↑15%) */
	  --tested: #5C6BC0;   /* 浅群青 (原色亮度↑10%) */
	  
	  /* 高级别 - 增强发光效果 */
	  --rare: #AB47BC;     /* 亮紫色 (原色亮度↑10%) */
	  --epic: #EC407A;     /* 品红色 (原色亮度↑10%) */
	  
	  /* 顶级级别 - 保持醒目特性 */
	  --legendary: #FF9800; /* 亮橙色 (原色亮度↑5%) */
	  --divine: #FFEE58;    /* 荧光黄 (原色亮度↑15%) */
      --danger: #d32f2f;
      --warning: #fbc02d;
      --efficiency-green: #66BB6A;
      --production-blue: #42A5F5;
    }
	.log-entry.junk {
	  color: var(--junk) !important;
	}
	.log-entry.zombie-event {
	  background-color: rgba(16, 102, 21, 0.2); /* 半透明橙紅色背景 */
	  color: #2f9936; /* 綠色 */
	  border-left: 4px solid #106615; /* 用一條醒目的邊框做強調 */
	  font-weight: bold;
	  white-space: normal;
	}
	/* 收藏頁簽中，針對以 junk 標記的物品，強制顯示正確顏色 */
	#collectionContent tr.junk,
	#collectionContent tr.junk td {
		color: var(--junk) !important;
	}
	#collectionContent,
	#collectionContent td,
	#collectionContent th {
		font-weight: bold;
	}
	/* 使生產收藏頁面的所有文字加粗 */
	#productionCollectionContent,
	#productionCollectionContent td,
	#productionCollectionContent th {
		font-weight: bold;
	}



    /* 基礎布局 */
    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: 'Microsoft YaHei', system-ui, sans-serif;
      margin: 0;
      padding: 20px;
      line-height: 1.6;
      min-height: 100vh;
	  overscroll-behavior-y: contain;
	  -webkit-font-smoothing: antialiased;
	  -moz-osx-font-smoothing: grayscale;
	  text-rendering: optimizeLegibility;
    }
	@media (max-width: 480px) {
	  body {
		font-size: 16px;
		line-height: 1.5;
	  }
	}
	
    .container {
      display: grid;
      grid-template-columns: 300px 1fr;
      gap: 25px;
      max-width: 1400px;
      margin: 0 auto;
    }
    /* 資源儀表盤 */
	.main-grid-container {
	  display: grid;
	  grid-template-columns: 1fr 1fr;         /* 兩列等分 */
	  grid-template-rows: auto auto auto;      /* 三行，第二行的高度自動調整，第一行與第二行保持等高 */
	  gap: 20px;
	  margin-top: 20px;
	}
	.grid-container {
	  display: grid;
	  grid-template-columns: 1fr 1fr;
	  grid-auto-rows: minmax(300px, auto);
	  gap: 20px;
	  margin-top: 20px;
	}
	.grid-item {
	  background: #262626;
	  padding: 1rem;
	  border-radius: 12px;
	  border: 1px solid var(--border-color);
	  box-sizing: border-box;
	}
	/* 第一行與第二行的 grid-item  */
	#resourceDashboard,
	#zombieCommand,
	#explorationLogContainer,
	#productionLogContainer {
	  position: relative;
	  /* 固定高度（根據需求調整數值），例如 350px */
	  height: 600px;
	  overflow: hidden;  /* 若內容超出，可自行加入 overflow 設定 */
	}
	/* 基地建設容器，跨兩列 */
	.building-system-container {
	  position: relative; /* 保留相對定位，但不要強制覆蓋 */
	  grid-column: 1 / span 2;
	  height: 600px;      /* 保持原來高度 */
	  overflow: auto;
	}
    .dashboard {
      background: #262626;
      padding: 1.5rem;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      height: fit-content;
    }
    .resource-group {
      margin-bottom: 1rem;
      background: #2d2d2d;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .resource-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      cursor: pointer;
      transition: background 0.3s ease;
      background: #373737;
    }
    .resource-header:hover {
      background: var(--hover-bg);
    }
    .resource-details {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .resource-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 15px;
      font-size: 0.9em;
      background: linear-gradient(to right, #2d2d2d 50%, #373737);
      border-top: 1px solid var(--border-color);
    }
	
	.reset-cycle-container {
	  display: flex;
	  justify-content: space-between; /* 左右分散 */
	  align-items: center;            /* 垂直居中 */
	  font-size: 1em;                 /* 與食物、武器卡一致的字體大小 */
	  padding: 1px;                  /* 可依需要調整內間距 */
	}

	.reset-cycle-card {
	  margin-top: 15px;
	  background: #262626;
	  border-radius: 12px;
	  border: 1px solid var(--border-color);
	  height: 30px;
	  padding: 10px;
	}

	/* 新增：成就系統選項卡樣式，同 reset-cycle-card 的樣式 */
	.achievement-card {
	  margin-top: 15px;
	  background: #262626;
	  border-radius: 12px;
	  border: 1px solid var(--border-color);
	  height: 80px; /* 調整高度，可根據需要調整 */
	  padding: 10px;
	}

	.achievement-header {
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  margin-bottom: 5px;
	  font-weight: bold;
	  font-size: 1em;
	}

	/* 3x2 成就網格 */
	.achievement-grid {
	  display: grid;
	  grid-template-columns: repeat(3, 1fr);
	  grid-gap: 5px;
	}

	/* 每個成就單元：不帶邊框，加粗文字 */
	.achievement-cell {
	  /* 移除邊框 */
	  border: none;
	  background: transparent;
	  font-weight: bold;
	  text-align: center;
	  /* 稀有度類：common, uncommon, rare, epic, legendary, divine；請確保這些類設定對應顏色和動畫 */
	}

	/* 稱號庫模態視窗，兩欄表格 */
	#titlesModal .modal-content {
	  width: 60%;
	  max-width: 400px;
	  overflow-x: visible;
	  position: fixed;
	  left: 50%;
	  transform: translateX(-50%);
	  max-height: 600px;
	  background: #2d2d2d;
	  border-radius: 12px;
	  padding: 2rem;
	}
	#titlesModal .modal-content .collection-table th:first-child,
	#titlesModal .modal-content .collection-table td:first-child {
	  width: 40%;
	}


	/* 收藏彈窗 */
	.collection-table {
	  width: 100%;
	  border-collapse: collapse;
	  font-family: inherit; /* 使用全局字體 */
	}

	.collection-table th,
	.collection-table td {
	  border: 1px solid var(--border-color); /* 使用你定義的邊框顏色 */
	  padding: 5px;
	}

	/* 對 th 進行居中屬性 */
	.collection-table th,
	.collection-table td{
	  text-align: center;
	  vertical-align: middle;
	  font-weight: bold;
	}



		
    /* 部門管理界面 */
    .operations-panel {
      display: flex;
      flex-direction: column;
	  gap: 10px;          /* 卡片間距 */
	  height: 100%;       /* 或指定固定高度，如350px */
      box-sizing: border-box;
    }
    .department-card {
	  flex: 1;
      background: #262626;
      padding: 0.5rem;
	  border: 1px solid #4a4a4a !important;
      border-radius: 5px;
	  height:80px;
	  margin-bottom: 0.3rem;
    }
	.dept-header h3 {
	  font-size: 1em;        /* 調小標題字體 */
	  margin: 0;
	  line-height: 1.2;
	}
    .department {
      background: #2d2d2d;
      border-left: 4px solid;
      border-radius: 8px;
      margin: 1rem 0;
      padding: 1rem;
      transition: transform 0.2s;
    }
    .department:hover {
      transform: translateX(5px);
    }
    #exploration { border-color: var(--danger); }
    #farming { border-color: var(--uncommon); }
    #recycling { border-color: var(--warning); }
    #research { border-color: var(--rare); }
    .zombie-control {
      display: flex;
	  justify-content: space-evenly;
      align-items: center;
      gap: 10px;
	  padding: 0 10px;
      margin-top: 12px;
    }
    .zombie-btn {
      width: 28px;
      height: 28px;
      border: none;
      border-radius: 50%;
      background: #404040;
      color: white;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.2s;
    }
    .zombie-btn:hover {
      background: #4a4a4a;
      transform: scale(1.1);
    }
	.large-btn {
	  font-size: 1.2em;
	  padding: 0.6em 1em;
	}

    /* 建築系統 */
    .building-system {
      background: #262626;
      padding: 1.5rem;
      border-radius: 12px;
      border: 1px solid var(--border-color);
    }
    .construction-grid {
      display: grid;
      grid-template-columns: repeat(3, 120px);
      gap: 15px;
      justify-content: center;
    }
    .tile {
      width: 120px;
      height: 120px;
      background: #2d2d2d;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      position: relative;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .tile:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .upgradable {
      border-color: var(--uncommon);
      animation: pulse-border 2s infinite;
    }
    .building-icon {
      font-size: 2.5rem;
      margin-bottom: 8px;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    }
    .building-info { text-align: center; }
    .building-name {
      font-weight: 500;
      font-size: 0.9em;
    }
    .building-level {
      font-size: 0.8em;
      color: var(--common);
    }
    .upgrade-badge {
      position: absolute;
      top: 8px;
      right: 8px;
      background: var(--uncommon);
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      box-shadow: 0 0 10px var(--uncommon);
    }
	 .build-box {
	  height: 150px;
	  display: flex;
	  flex-direction: column;
	  border: 1px solid var(--border-color);  /* 始終顯示邊框 */
	  background-color: #2d2d2d;
	  border-radius: 8px;
	  padding: 10px;
	  margin: 10px 0;
	  margin-bottom: 10px;
	  transition: background 0.2s;
	  cursor: pointer;
	}

	/* 懸停時僅改變背景色，但邊框保持不變 */
	.build-box:hover {
	  background-color: #3a3a3a;
	}

	.build-top {
	  display: flex;
	  align-items: center;
	  gap: 10px;
	  margin-bottom: 5px;
	}

	.build-icon {
	  font-size: 2rem;
	  width: 50px;
	  text-align: center;
	}

	.build-name {
	  font-size: 1.1rem;
	  font-weight: bold;
	}


	.cost-item {
	  display: inline-block;
	  margin-right: 8px;
	}

	.build-box.empty {
	  /* 保持與建造卡片相同的高度、邊框邏輯 */
	  height: 150px;        /* 與其他 build-box 固定高度一致 */
	  border: 1px solid var(--border-color);
	  background-color: transparent; /* 也可以設為 #2d2d2d 看看效果 */
	  border-radius: 8px;
	  margin-bottom: 10px;
	  padding: 10px;
	  cursor: default;      /* 使其沒有點擊效果 */
	  /* 內容置空，不顯示文字 */
	}
	
	/* 上半部分容器，佔滿剩餘空間並垂直居中 */
	.build-top-container {
	  flex: 1;
	  display: flex;
	  align-items: center;  /* 垂直居中 */
	  justify-content: center;
	}

	/* 下方資源信息部分，不變 */
	.build-resources {
	  text-align: center;
	  margin-top: 5px;
	}

	/* 左右容器，內部分欄 */
	.build-row {
	  display: flex;
	  width: 100%;
	}

	/* 左邊：建築圖示與名稱，50% 寬度，左對齊，右側有分界線 */
	.build-left {
	  flex: 1;
	  text-align: left;
	  border-right: 1px solid var(--border-color);
	  padding-right: 10px;
	}

	/* 右邊：加成描述，50% 寬度，左對齊 */
	.build-right {
	  flex: 1;
	  text-align: left;
	  padding-left: 10px;
	}
	.building-info {
	  display: flex;
	  flex-direction: column;
	  justify-content: center; /* 垂直居中 */
	  text-align: center;
	}




	
    /* 事件日誌系統 */
    .log {
      height: 320px;
      background: #1f1f1f;
      border-radius: 8px;
      padding: 15px;
      margin-top: 1.5rem;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--border-color) transparent;
    }
    .log-entry {
      padding: 10px;
      margin: 8px 0;
      background: #2d2d2d;
      border-left: 3px solid;
      border-radius: 4px;
      animation: fadeIn 0.4s ease;
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-size: 0.9em;
	  font-weight: bold;
    }
    .log-entry::before {
      content: "•";
      color: currentColor;
      font-weight: bold;
    }
	#favoritesModal .modal-content {
	  /* 確保使用固定定位 */
	  position: fixed !important;
	  left: 50% !important;
	  /* 為了讓整個彈窗以自身中心作水平定位 */
	  transform: translateX(-50%) !important;
	  max-height: 600px; 
	}
	#productionCollectionModal .modal-content {
	  position: fixed !important;
	  left: 50% !important;
	  transform: translateX(-50%) !important;
	  max-height: 600px;
	}
	#productionLog .log-entry {
	  white-space: normal;      /* 允许自动换行 */
	  word-break: normal;     /* 保持中文不拆断；注意：对于英文，keep-all 通常不会在单词内部拆分 */
	  overflow-wrap: break-word; /* 如果单词太长，允许在单词边界断开 */
	}

	
    /* 稀有度顏色 */
    /* 基础级别 */
	.junk { color: var(--junk) !important; }
	.old { color: var(--old); }
	.damaged { color: var(--damaged); }

	/* 普通级别 */
	.common { color: var(--common); }
	.decent { color: var(--decent); }
	.sealed { 
	  color: var(--sealed);
	  animation: pulse 1.5s infinite;
	}

	/* 精良级别 */
	.selected { 
	  color: var(--selected);
	  text-shadow: 0 0 5px rgba(30, 136, 229, 0.5);
	}
	.tested {
	  color: var(--tested);
	  animation: float 2s ease-in-out infinite;
	}

	/* 高级别 */
	.rare {
	  color: var(--rare);
	  animation: rare-glow 2s infinite alternate;
	}
	.epic {
	  color: var(--epic);
	  text-shadow: 0 0 8px rgba(142, 36, 170, 0.7);
	  animation: epic-pulse 1.5s infinite;
	}

	/* 顶级级别 */
	.legendary {
	  color: var(--legendary);
	  animation: 
		legendary-glow 2s infinite alternate,
		shake 0.5s infinite alternate;
	}
	.divine {
	  color: var(--divine);
	  text-shadow: 
		0 0 10px rgba(255, 214, 0, 0.8),
		0 0 20px rgba(255, 214, 0, 0.4);
	  animation: 
		divine-shine 3s infinite alternate;
	}
	.upgrade-indicator.upgrade-available {
	  color: green;
	}


	/* 动画定义 */
	@keyframes pulse {
	  0%, 100% { opacity: 0.9; }
	  50% { opacity: 1; transform: scale(1.02); }
	}
	@keyframes float {
	  0%, 100% { transform: translateY(0); }
	  50% { transform: translateY(-3px); }
	}
	@keyframes rare-glow {
	  from { text-shadow: 0 0 5px rgba(142, 36, 170, 0.3); }
	  to { text-shadow: 0 0 15px rgba(142, 36, 170, 0.7); }
	}
	@keyframes epic-pulse {
	  0%, 100% { transform: scale(1); }
	  50% { transform: scale(1.05); }
	}
	@keyframes legendary-glow {
	  from { text-shadow: 0 0 5px rgba(245, 124, 0, 0.5); }
	  to { text-shadow: 0 0 20px rgba(245, 124, 0, 0.9); }
	}
	@keyframes shake {
	  0% { transform: translateX(-1px); }
	  100% { transform: translateX(1px); }
	}
	@keyframes divine-shine {
	  from { 
		filter: brightness(1);
		text-shadow: 0 0 10px rgba(255, 214, 0, 0.8);
	  }
	  to { 
		filter: brightness(1.2);
		text-shadow: 0 0 25px rgba(255, 214, 0, 1);
	  }
	}
    }
    
  
    @keyframes pulse-border {
      0% { border-color: var(--uncommon); }
      50% { border-color: rgba(76,175,80,0.5); }
      100% { border-color: var(--uncommon); }
    }
    @keyframes resource-glow {
      0% { box-shadow: 0 0 5px currentColor; }
      50% { box-shadow: 0 0 15px currentColor; }
      100% { box-shadow: 0 0 5px currentColor; }
    }
    @media (max-width: 768px) {
      .container { grid-template-columns: 1fr; padding: 10px; }
      .construction-grid { grid-template-columns: repeat(3, 1fr); }
      .tile { width: 100%; height: 100px; }
      .zombie-control { flex-wrap: wrap; }
	  .modal-content {
		width: min(41vw, 400px);
		margin: 0 auto;
		touch-action: auto;        /* 允許原生滾動處理 */
		overscroll-behavior: contain;  /* 抑制滾動連鎖效應 */
      }
	}
    @media (max-width: 480px) {
      .building-system { padding: 1rem; }
      .construction-grid { grid-template-columns: repeat(2, 1fr); }
    }
    .efficiency-badge {
      color: var(--efficiency-green);
      font-size: 0.8em;
      padding: 2px 8px;
      border-radius: 4px;
      background: rgba(76,175,80,0.1);
    }
    .production-rate {
      color: var(--production-blue);
      font-size: 0.9em;
      margin-top: 5px;
    }
    .pending-zombies {
      color: var(--warning);
      animation: resource-glow 1.5s infinite;
    }
	
	/* 動畫窗口的公共樣式，寬度與日誌一樣，高度約 120px，可根據需要調整 */
	.anim-window {
	  width: 100%;
	  height: 120px;
	  position: relative;
	  overflow: hidden;
	  background-color: #000; /* 可作為預設背景 */
	}

	/* 生產日誌動畫窗口三欄佈局 */
	#productionAnim .prod-col {
	  float: left;
	  width: 33.33%;
	  height: 100%;
	  position: relative;
	  overflow: hidden;
	  /* 可設定背景或邊框便於區分 */
	}

	/* 清除浮動 */
	#productionAnim::after {
	  content: "";
	  display: block;
	  clear: both;
	}

	/* 探索動畫背景滾動效果 */
	#explorationAnim {
	  width: 100%;
	  height: var(--exploration-height);
	  position: relative; /* 作为绝对定位子元素的参照 */
	  background-image: url('images/location_day_1.png');
	  background-repeat: repeat-x;
	  /* 设置背景单元尺寸为 432pt × 144pt */
	  background-size: var(--tile-width) var(--exploration-height);
	  background-position: 0 0;
	  /* 使用明确的像素（pt）值，让背景从 0 滚动到 432pt，即一个完整平铺单元 */
	  animation: scrollBgRight 30s linear infinite;
	}


	@keyframes scrollBgRight {
	  from {
		background-position: 0 0;
	  }
	  to {
		background-position: 432pt 0;
	  }
	}

	/* 1.1 僵尸寻找动画 */
	.zombie-search {
	  position: absolute;
	  left: 50%;
	  top: 50%;
	  transform: translate(-50%, -50%);
	  width: var(--zombie-size);
	  height: var(--zombie-size);
	  background-image: url('images/zombie_search_sprite.png');
	  /* 将背景设为全精灵图 */
	  background-size: var(--zombie-sprite-total-width) var(--zombie-size);
	  animation: zombieSearchAnim 3s steps(4) infinite;
	}
	@keyframes zombieSearchAnim {
	  from { background-position: 0 0; }
	  to { background-position: calc(-1 * var(--zombie-sprite-total-width)) 0; }
	}


	/* 1.3 僵尸入场动画（僵尸增加事件触发） */
	.zombie-entry {
      position: absolute;
      top: 50%;
      right: -200px; /* 初始位置在屏幕外更右侧 */
      width: var(--zombie-size);
      height: var(--zombie-size);
      background-image: url('images/zombie_entry_sprite.png');
      background-size: var(--zombie-sprite-total-width) var(--zombie-size);
      background-repeat: no-repeat;
      transform: translateY(-50%);
      animation: 
        zombieEntryMove 4s linear forwards,
        zombieEntryFrames 0.8s steps(4) infinite;
      z-index: 10;
      opacity: 1;
      transition: opacity 0.5s; /* 平滑淡出效果 */
    }
    
    @keyframes zombieEntryMove {
      0% { 
        right: -200px; /* 起始位置 */
        opacity: 1;
      }
      95% { 
        right: calc(100% + 100px); /* 结束位置 */
        opacity: 1;
      }
      100% {
        right: calc(100% + 100px);
        opacity: 0; /* 动画结束时淡出 */
      }
    }
    
    @keyframes zombieEntryFrames {
      0% { background-position: 0 0; }
      100% { background-position: calc(-1 * var(--zombie-sprite-total-width)) 0; }
    }

    /* 防止其他样式影响 */
    .zombie-entry * {
      animation: none !important;
    }

    
    @keyframes zombieEntryFrames {
      0% { background-position: 0 0; }
      100% { background-position: calc(-1 * var(--zombie-sprite-total-width)) 0; }
    }

    /* 防止其他样式影响 */
    .zombie-entry * {
      animation: none !important;
    }

    
	

	/* 1.4 僵尸倒地动画（僵尸减少事件触发） */
	.zombie-lying {
	  position: absolute;
	  top: 65%; /* 位置略低于搜索动画 */
	  left: -100px;
	  width: var(--zombie-size);
	  height: var(--zombie-size);
	  background-image: url('images/zombie_lying_sprite.png');
	  background-size: 100% 100%;
	  transform: translateY(-50%);
	  z-index: 12; /* 确保低于搜索动画 */
	  opacity: 0;
	  
	  
	  /* 分离移动和淡入淡出动画 */
	  animation: 
		zombieLyingAnim 20s linear forwards,
		zombieLyingFade 20s linear forwards;
	}

	@keyframes zombieLyingAnim {
	  0% { 
		left: -100px;
	  }
	  100% { 
		left: calc(100% + 100px);
	  }
	}

	@keyframes zombieLyingFade {
	  0% { 
		opacity: 0;
	  }
	  5% { 
		opacity: 1;
	  }
	  95% { 
		opacity: 1;
	  }
	  100% {
		opacity: 0;
	  }
	}
	/* 外層包裹容器，負責移動動畫，定位參照 #explorationAnim */
	.btr-wrapper {
	  position: absolute;
	  bottom: 0;
	  /* 使用百分比相對於 #explorationAnim 宽度進行移動 */
	  animation: btrMove 10s ease-in-out forwards;
	  z-index: 11;
	}

	/* 內層 BTR 精靈圖元素，尺寸固定為單幀大小 */
	.btr-animation {
	  width: var(--btr-frame-width);      /* 240px */
	  height: var(--btr-frame-height);      /* 120px */
	  background-image: url('images/btr_sprite.png');
	  background-size: var(--btr-sprite-total-width) var(--btr-frame-height); /* 960px x 120px */
	  background-repeat: no-repeat;   /* 不重複 */
	  /* 精靈圖幀動畫，每1秒循環一次，共4帧 */
	  animation: btrFrame 0.5s steps(4) infinite;
	}

	/* 移動動畫：使用百分比，相對於父容器寬度 */
	@keyframes btrMove {
	  0%   { transform: translateX(100%); }   /* 開始完全在右側外 */
	  20%  { transform: translateX(50%); }    /* 2秒內移動到父容器右側位置75% */
	  60%  { transform: translateX(50%); }    /* 保持位置 */
	  100% { transform: translateX(100%); }   /* 10秒內退回右側外 */
	}

	/* 精靈圖幀動畫，從0移動到 -960px */
	@keyframes btrFrame {
	  from { background-position: 0 0; }
	  to { background-position: -1920px 0; }
	}

	.log-entry.btr-active {
	  background-color: yellow;
	  color: red;
	  font-weight: bold;
	  border: 2px solid red;
	  padding: 5px;
	  text-shadow: 0 0 5px orange;
	}
	
	/* T-80 Animation CSS */
	.t80-animation {
	  /* 以與 BTR 相同高度，計算寬度：480px */
	  width: var(--btr-frame-width);       /* 480px */
	  height: var(--btr-frame-height);                /* 120px */
	  background-image: url('images/t-80_sprite.png');
	  /* 設置 T‑80 精靈圖總寬度：4 帧 × 480px = 1920px */
	  background-size: var(--btr-sprite-total-width) var(--btr-frame-height);  /* 1920px x 120px */
	  background-repeat: no-repeat;
	}
	@keyframes t80Idle {
	  0% { background-position: 0 0; }          
	  50% { background-position: -1440px 0; }   /* 第4 幀：-3×480 = -1440px */
	  100% { background-position: 0 0; }
	}
	.t80-idle {
	  animation: t80Idle 1s steps(2, end) infinite;
	}

	/* Full (開炮) 狀態：完整播放 4 幀一次 */
	@keyframes t80Full {
	  from { background-position: 0 0; }
	  to { background-position: -1920px 0; }
	}
	.t80-full {
	  animation: t80Full 1s steps(4, end) 1;
	}

	
	/* 以下為示例，根據需要擴展 production、exploration 動畫 CSS */

	/* ============================================================================
	   生產日誌動畫窗口 - 背景部分 (固定圖片)
	============================================================================ */

	#productionAnim {
	  width: 100%;
	  height: 120px;             /* 整个生产区域高度 */
	  position: relative;
	  display: flex;
	  /* 不再统一设置背景图片，因为此区域下各栏背景分开设置 */
	  background: none;
	}

	/* 每一栏（prod-col）保持现有布局 */
	#productionAnim .prod-col {
	  float: left;
	  flex: 1;
	  height: 100%;
	  position: relative;
	  overflow: hidden;
	}

	/* 清除浮动 */
	#productionAnim::after {
	  content: "";
	  display: block;
	  clear: both;
	}

	/* 设置左栏背景 */
	#prodAnimLeft {
	  background-size: cover;        /* 填满整个区域 */
	  background-repeat: no-repeat;
	  background-position: center center;
	}

	/* 设置中栏背景 */
	#prodAnimMid {
	  background-size: cover;
	  background-repeat: no-repeat;
	  background-position: center center;
	}

	/* 设置右栏背景 */
	#prodAnimRight {
	  background-size: cover;
	  background-repeat: no-repeat;
	  background-position: center center;
	}

	/* 生产区域三栏布局 */
	#productionAnim .prod-col {
	  float: left;
	  width: 33.33%;
	  height: 100%;
	  position: relative;
	  overflow: hidden;
	}
	#productionAnim::after {
	  content: "";
	  display: block;
	  clear: both;
	}

	/* 2.1 左栏：僵尸耕田动画 */
	.prod-zombie-plow {
	  position: absolute;
	  bottom: 10%;
	  left: 50%;
	  transform: translateX(-50%);
	  width: var(--zombie-size);
	  height: var(--zombie-size);
	  background-image: url('images/zombie_plow_sprite.png');
	  background-size: calc(4 * var(--zombie-size)) var(--zombie-size);
	  animation: prodPlowAnim 2s steps(4) infinite;
	}
	@keyframes prodPlowAnim {
	  from { background-position: 0 0; }
	  to { background-position: calc(-1 * 4 * var(--zombie-size)) 0; }
	}

	/* 2.2 中栏：僵尸焊接动画 */
	.prod-zombie-weld {
	  position: absolute;
	  bottom: 10%;
	  left: 50%;
	  transform: translateX(-50%);
	  width: var(--zombie-size);
	  height: var(--zombie-size);
	  background-image: url('images/zombie_weld_sprite.png');
	  background-size: calc(4 * var(--zombie-size)) var(--zombie-size);
	  animation: prodWeldAnim 2s steps(4) infinite;
	}
	@keyframes prodWeldAnim {
	  from { background-position: 0 0; }
	  to { background-position: calc(-1 * 4 * var(--zombie-size)) 0; }
	}

	/* 2.3 右栏：僵尸实验室动画 */
	.prod-zombie-lab {
	  position: absolute;
	  bottom: 10%;
	  left: 50%;
	  transform: translateX(-50%);
	  width: var(--zombie-size);
	  height: var(--zombie-size);
	  background-image: url('images/zombie_lab_sprite.png');
	  background-size: calc(4 * var(--zombie-size)) var(--zombie-size);
	  animation: prodLabAnim 2s steps(4) infinite;
	}
	@keyframes prodLabAnim {
	  from { background-position: 0 0; }
	  to { background-position: calc(-1 * 4 * var(--zombie-size)) 0; }
	}

	/* ============================== */
	/* 其他辅助样式（例如花屏过渡效果 .glitch 及动画公共样式） */
	/* ============================== */

	.transition-overlay {
	  position: absolute;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  background-size: cover;
	  z-index: 15;
	  animation: fadeInOut 0.3s linear;
	}

	@keyframes fadeInOut {
	  0% { opacity: 0; }
	  50% { opacity: 1; }
	  100% { opacity: 0; }
	}
	.accident-overlay {
	  position: absolute;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  background-size: cover;
	  z-index: 10;
	}
	.achievement-header {
	  display: inline-flex;
	  align-items: center;
	  gap: 10px;
	}
	/* 對稱號庫與收藏記錄彈窗內的 .modal-content 取消所有動畫效果 */
	/* 覆寫稱號庫、收藏記錄、以及生產記錄彈窗內的所有元素動畫與過渡 */
	#titlesModal *,
	#favoritesModal *,
	#productionCollectionModal * {
	  animation: none !important;
	  transition: none !important;
	}
	/* ===== 新增：對戰模式 CSS ===== */
	.battle-overlay {
	  position: fixed;
	  top: 0;
	  left: 0;
	  right: 0;
	  bottom: 0;
	  background: rgba(0,0,0,0.8);
	  z-index: 2000;
	  display: none; /* 初始隱藏 */
	}

	.battle-container {
	  position: fixed;
	  top: 0%; 
	  left: 50%;
	  transform: translateX(-50%);
	  width: 100vw;
	  height: 300px;
	  z-index: 2100;
	}

	.battle-header {
	  padding: 15px;
	  background: #333;
	  display: flex;
	  flex-direction: column; /* 修改为纵向排列 */
	  justify-content: center;
	  align-items: stretch; /* 使子元素拉伸填充宽度 */
	  gap: 10px;
	  height: auto; /* 高度自适应内容 */
	}

	.battle-header input[type="text"] {
	  padding: 15px;
	  font-size: 1rem;
	}

	.battle-header button {
	  padding: 15px 30px;
	  font-size: 1rem;
	  cursor: pointer;
	}

	.battle-content {
	  height: 180px;
	  width: 100vw;
	  display: flex;
	  margin: 0px;
	}

	.battle-half {
	  width: 50vw;
	  height: 180px;
	  overflow: hidden;
	  position: relative;
	  background: #000; /* 預設黑屏 */
	}

	.battle-half.left .battle-inner {
	  transform: scaleX(-1); /* 左邊內容水平翻轉 */
	}

	.battle-inner {
	  width: 100%;
	  height: 100%;
	  position: relative;
	}

	/* 戰鬥日誌 */
	/* 新增：戰鬥日誌標題 */
	.battle-log-title {
	  margin: 0;
	  padding: 5px 10px;
	  background: #444;
	  border-bottom: 1px solid #666;
	  font-family: 'Microsoft YaHei', sans-serif;
	  font-size: 1.1rem;
	}

	.battle-log {
	  position: fixed;
	  top: 300px;      /* 戰鬥日誌頂部緊貼 battle-container 底部 */
	  left: 0;
	  width: 100%;
	  height: calc(100vh - 220px);  /* 占滿剩餘高度 */
	  background: #1f1f1f;         /* 與探索日誌一致 */
	  color: #fff;
	  overflow-y: auto;
	  z-index: 2200;
	  padding: 5px 10px;
	  box-sizing: border-box;
	  border-top: 1px solid #4a4a4a;
	}
	.log-entry.battle-self-entry {
	  color: white;
	  font-weight: bold;
	  margin: 4px 0;
	}

	.log-entry.battle-enemy-entry {
	  color: #fca572;
	  font-weight: bold;
	  margin: 4px 0;
	}
	
	.log-entry.battle-system-entry {
	  color: #fae678;
	  font-weight: bold;
	  margin: 4px 0;
	}
	#battleSelfAnim .zombie-search, #battleEnemyAnim .enemy-zombie-search  {
	  top: 60%
	}
	#battleExitBtn {
	  background-color: #5e1c0d; /* 底色為紅色 */
	  color: white;          /* 文字顏色為白色 */
	  border: none;          /* 無邊框（可根據需要調整） */
	  font-size: 20px;       /* 調整字體大小 */
	  cursor: pointer;
	}
	.resource-header {
	  display: grid;
	  grid-template-columns: 20% 30% 50%; /* 第一欄固定30%，第二欄40%，第三欄30%，總和為100% */
	  align-items: center;
	  width: 100%;
	  padding: 10px 0;  /* 根據需要調整內邊距 */
	}

	.resource-icon {
	  grid-column: 1;
	  text-align: center;  /* 靠右對齊，讓圖示靠近邊界 */
	}

	.resource-name {
	  grid-column: 2;
	  text-align: center;
	}

	.resource-count {
	  grid-column: 3;
	  text-align: right;
	  padding-right: 20px;
	}

	 #wardrobeModal {
      position: absolute;
      top: 30vh;
      left: 50%;
      transform: translateX(-50%);
      width: 90vw;
      max-width: 600px;
      background: #2d2d2d;
      border-radius: 12px;
      padding: 1rem;
      box-sizing: border-box;
    }

	#wardrobeHeader {
	  display: flex;
	  align-items: center;
	  font-weight: bold;
	}
	#wardrobeCloseBtn {
	  margin-left: auto;
	  background-color: #5e1c0d; /* 底色為紅色 */
	  color: white;          /* 文字顏色為白色 */
	  border: none;          /* 無邊框（可根據需要調整） */
	  font-size: 20px;       /* 調整字體大小 */
	  cursor: pointer;
	}
        /* 分頁部分 */
    #wardrobeTabs {
      display: flex;
      justify-content: space-around;
      margin-bottom: 1em;
      border-bottom: 1px solid #aaa;
    }
    #wardrobeTabs button {
      flex: 1;
      background: transparent;
      border: none;
      padding: 0.5em;
      font-weight: bold;
      color: #fff;
      cursor: pointer;
    }
    #wardrobeTabs button.active {
      border-bottom: 2px solid limegreen;
    }
    /* 內容區（卡片區），超出高度則自動出現滾動條 */
    #wardrobeContent {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      max-height: 400px; /* 可根據需要調整 */
      overflow-y: auto;
    }
    .wardrobe-card {
      width: 150px;
      height: 150px;
      background-size: cover;
      background-position: center;
      border: 2px solid transparent;
      cursor: pointer;
      transition: border 0.3s ease;
      position: relative;
    }
    .wardrobe-card.locked {
      filter: grayscale(100%);
    }
    .wardrobe-card.selected {
      border: 2px solid limegreen;
    }
    .wardrobe-card .label {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: rgba(0, 128, 0, 0.7);
      color: white;
      text-align: center;
      font-size: 1em;
      display: none;
    }
    .wardrobe-card.selected .label {
      display: block;
    }
	/* 对战模式导航行样式 */
	.battle-nav-row {
	  display: flex;
	  justify-content: center;
	  align-items: center;
	  gap: 10px; /* 元素间距 */
	  width: 100%;
	}

	.battle-nav-row:first-child input[type="text"] {
	  flex: 1;
	  max-width: 40%; /* 限制最大宽度 */
	  padding: 8px 12px;
	  font-size: 1rem;
	}

	.battle-nav-row:first-child button {
	  padding: 8px 15px;
	  margin-left: auto; /* 推到右侧 */
	}

	/* 第二行样式 - 三个下拉菜单均匀分布 */
	.battle-nav-row:last-child select {
	  flex: 1;
	  padding: 8px;
	  max-width: 30%; /* 限制最大宽度，确保三个选择器大小一致 */
	}

	.battle-nav-row:last-child button {
	  padding: 8px 20px;
	  min-width: 100px; /* 给开始按钮一个最小宽度 */
	}

	/* 调整下拉菜单样式 */
	#battleModeSelect, #bossList, #pveModeSelect {
	  padding: 8px;
	  border-radius: 4px;
	  border: 1px solid #444;
	  background: #222;
	  color: #fff;
	  height: 36px; /* 固定高度确保一致性 */
	}


	
  </style>
</head>
<!-- Firebase App (核心) SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<!-- Firebase Realtime Database SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
<!-- Firebase Authentication SDK (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>


<body>
  <div class="main-grid-container">
   <!-- 上排：左 - 末日指揮中心；右 - 尸群指揮系統 -->
   <div class="grid-item" id="resourceDashboard">
    <!-- 左側資源面板 -->
      <h2 class="section-title">
		🏚️ 末日指揮中心
		<button id="resetProgressBtn" class="modal-btn" style="margin-left: 10px;">重置存檔</button>
	  </h2>
      <div class="resource-panel">
        <div class="resource-group">
          <div class="resource-header" onclick="toggleResource('food')">
            <span class="resource-icon">🍖</span>
            <span class="resource-name">食物</span>
            <span class="resource-count" id="foodCount">0</span>
          </div>
          <div class="resource-details" id="foodDetails"></div>
        </div>
        <div class="resource-group">
          <div class="resource-header" onclick="toggleResource('materials')">
            <span class="resource-icon">🔩</span>
            <span class="resource-name">材料</span>
            <span class="resource-count" id="materialsCount">0</span>
          </div>
          <div class="resource-details" id="materialsDetails"></div>
        </div>
        <div class="resource-group">
          <div class="resource-header" onclick="toggleResource('weapons')">
            <span class="resource-icon">🔫</span>
            <span class="resource-name">武器</span>
            <span class="resource-count" id="weaponsCount">0</span>
          </div>
          <div class="resource-details" id="weaponsDetails"></div>
        </div>
        <div class="resource-group">
          <div class="resource-header" onclick="toggleResource('tech')">
            <span class="resource-icon">💾</span>
            <span class="resource-name">科技</span>
            <span class="resource-count" id="techCount">0</span>
          </div>
          <div class="resource-details" id="techDetails"></div>
        </div>
      </div>
	  
	  <div class="dashboard reset-cycle-card" id="resetCycleCard">
		<div class="reset-cycle-container">
			<span class="reset-cycle-label" style="font-weight: bold;">資源爆破</span>
			<span class="reset-cycle-count" id="resetCycleDisplay">循環次數：0</span>
		  </div>
		</div>
	  <div class="dashboard achievement-card" id="achievementCard">
		  <div class="achievement-header">
			<span class="achievement-title">成就系統</span>
			<button id="titleLibraryBtn" class="modal-btn">稱號庫</button>
		  </div>
		  <!-- 3*2 格局，用一個網格顯示最新六個成就 -->
		  <div class="achievement-grid" id="achievementGrid">
			<!-- 程式會在此填充最新的 6 個成就 -->
		  </div>
		</div>
	  <!-- 稱號庫模態視窗 -->
		<div id="titlesModal" class="modal-overlay">
		  <div class="modal-content">
			<h3 id="titleLibraryTitle" style="text-align: center; font-weight: bold;">稱號庫</h3>
			<div class="titles-content" id="titlesContent">
			  <!-- 全部稱號，按稀有度排序顯示 -->
			</div>
		  </div>
		</div>
	</div>	
	   <div class="grid-item" id="zombieCommand">
		<!-- 尸群指揮系統：操作控制區域 -->
		<div class="operations-panel">
		  <h2 class="section-title">🧟 尸群指揮系統</h2>
		  <div class="production-grid">
			<div class="department-card" id="exploration">
			  <div class="dept-header">
				<h3>🔍 偵察軍團</h3>
				<div class="efficiency-badge" id="exploreEfficiency">效率: 100%</div>
			  </div>
			  <div class="zombie-control">
				<button class="zombie-btn" onclick="adjustZombies('exploration', -1)">−</button>
				<span class="zombie-count" id="explorationCount">0</span>
				<button class="zombie-btn" onclick="adjustZombies('exploration', 1)">+</button>
			  </div>
			</div>
			  <div class="department-card" id="farming">
				<div class="dept-header">
				  <h3>🌾 種植部門</h3>
				  <div class="efficiency-badge" id="farmEfficiency">+0%</div>
				</div>
				<div class="zombie-control">
				  <button class="zombie-btn" onclick="adjustZombies('farming', -1)">−</button>
				  <span class="zombie-count" id="farmingCount">0</span>
				  <button class="zombie-btn" onclick="adjustZombies('farming', 1)">+</button>
				</div>
			  </div>
			  <div class="department-card" id="recycling">
				<div class="dept-header">
				  <h3>♻ 回收工廠</h3>
				  <div class="efficiency-badge" id="recycleEfficiency">+0%</div>
				</div>
				<div class="zombie-control">
				  <button class="zombie-btn" onclick="adjustZombies('recycling', -1)">−</button>
				  <span class="zombie-count" id="recyclingCount">0</span>
				  <button class="zombie-btn" onclick="adjustZombies('recycling', 1)">+</button>
				</div>
			  </div>
			  <div class="department-card" id="research">
				<div class="dept-header">
				  <h3>🔬 科研中心</h3>
				  <div class="efficiency-badge" id="researchEfficiency">+0%</div>
				</div>
				<div class="zombie-control">
				  <button class="zombie-btn" onclick="adjustZombies('research', -1)">−</button>
				  <span class="zombie-count" id="researchCount">0</span>
				  <button class="zombie-btn" onclick="adjustZombies('research', 1)">+</button>
				</div>
			  </div>
			</div>
		 </div>
	  </div>
      <!-- 下排：左 - 行動日誌；右 - 生產日誌 -->
	  <div class="grid-item" id="explorationLogContainer">
		<h3 class="log-title">
		  📜 行動日誌
		 <!-- 在標題右側加入收藏按鈕 -->
		 <button id="favoritesBtn">收藏</button>
		 <button id="encounterBattleBtn">遭遇戰</button>
		</h3>
		<div class="log-header">
          <span class="zombie-status">待分配僵尸: <span id="pendingZombies">0</span></span>
          <span class="total-zombies">總數: <span id="totalZombies">10</span></span>
        </div>
		<div class="log" id="explorationLog">
		  <div class="log-entry uncommon">✅ 系統初始化完成</div>
		</div>
		<div id="explorationAnim" class="anim-window"></div>
	 </div>
	  <div class="grid-item" id="productionLogContainer">
	   <h3 class="log-title">🛠 生產日誌
	   <button id="productionFavoritesBtn" class="modal-btn" onclick="showProductionCollection()">收藏</button>
	   </h3>
	   	<div id="timerContainer" class="timer-container">
          <span class="timer-label">用時</span>
          <span id="timerValue">00:00:00</span>
        </div>
	   <div class="log" id="productionLog">
		 <!-- 生產事件將在此顯示 -->
	   </div>
	     <div id="productionAnim" class="anim-window">
	    <div class="prod-col" id="prodAnimLeft"></div>
	    <div class="prod-col" id="prodAnimMid"></div>
	    <div class="prod-col" id="prodAnimRight"></div>
	  </div>
	 </div>
    <div class="grid-item building-system-container" id="buildingSystem">
        <h2 class="section-title">🏗️ 基地建設
		<button id="wardrobeBtn">衣櫃</button>
		</h2>
        <div class="construction-grid" id="buildingGrid">
          <!-- 動態生成的建築格子 -->
        </div>
	  
	  <!-- 請將下面這四個彈窗的 HTML 移入 id="buildingSystem" 的容器內 -->
		<!-- 結果提示彈窗：加上 nested 類 -->
		<div id="resultModal" class="modal-overlay nested">
		  <div class="modal-content">
			<p id="resultMessage"></p>
		  </div>
		</div>

		<!-- 升級彈窗：加上 nested 類 -->
		<div id="upgradeModal" class="modal-overlay nested">
		  <div class="modal-content">
			<h3 id="upgradeTitle"></h3>
			<div id="upgradeInfo" style="white-space: pre-wrap; margin-bottom: 1em;"></div>
			<div class="button-row" style="display: flex; justify-content: space-between;">
			  <button id="confirmUpgradeBtn" class="modal-btn large-btn" onclick="confirmUpgrade()" style="flex: 1; margin-right: 5px;">升級</button>
			  <button id="demolishBtn" class="modal-btn large-btn" onclick="confirmBuildingRemoval(currentUpgradeIndex)" style="flex: 1; margin-left: 5px;">拆除</button>
			</div>
		  </div>
		</div>

		<!-- 建築互動彈窗：加上 nested 類 -->
		<div id="interactionModal" class="modal-overlay nested">
		  <div class="modal-content">
			<h3 id="interactionTitle">建築管理</h3>
			<div id="interactionContent"></div>
		  </div>
		</div>

	  
    </div>
  </div>

  <!-- 收藏彈窗 -->
   <div id="favoritesModal" class="modal-overlay">
	 <div class="modal-content">
	 <h3 style="display: flex; justify-content: space-between; align-items: center;">收藏記錄
	 <!-- 新增收藏完成度 -->
       <div id="collectionCompletion" style="display: inline-block; margin-left: 10px; font-weight: bold;"></div>
	 </h3>
	 <div class="collection-content" id="collectionContent">
		  <!-- 收藏內容將在此填充 -->
	 </div>
	</div>
   </div>
   <div id="productionCollectionModal" class="modal-overlay">
    <div class="modal-content">
		<h3>生產記錄</h3>
		<div id="productionCollectionContent"></div>
	  </div>
	</div>
	<div id="buildModal" class="modal-overlay">
	  <div class="modal-content">
		<div id="buildHeaderStatus" style="margin-bottom: 1rem; font-size: 1.1em; color: var(--text-color);">
		  <div style="display: flex; flex-wrap: wrap;">
			<div style="width: 50%; text-align: left;">
			  <span class="resource-label">🍖食物: </span>
			  <span id="foodCountDisplay">0</span>
			</div>
			<div style="width: 50%; text-align: left;">
			  <span class="resource-label">🔩材料: </span>
			  <span id="materialsCountDisplay">0</span>
			</div>
			<div style="width: 50%; text-align: left;">
			  <span class="resource-label">🔫武器: </span>
			  <span id="weaponsCountDisplay">0</span>
			</div>
			<div style="width: 50%; text-align: left;">
			  <span class="resource-label">💾科技: </span>
			  <span id="techCountDisplay">0</span>
			</div>
		  </div>
		</div>
		<div class="build-options" id="buildOptions"></div>
	  </div>
	</div>
	
	<div id="battleOverlay" class="battle-overlay">
	  <div class="battle-container">
		<!-- 导航区：分两行，结构清晰 -->
		<div class="battle-header">
		  <!-- 第一行：暱稱、PIN和退出 -->
		  <div class="battle-nav-row">
			<input type="text" id="battleNickname" placeholder="輸入暱稱">
			<input type="text" id="battlePin" placeholder="輸入PIN碼">
			<button id="battleExitBtn">X</button>
		  </div>
		  
		  <!-- 第二行：模式、BOSS、单挑/合作选择 -->
		  <div class="battle-nav-row">
			<select id="battleModeSelect">
			  <option value="pvp">PVP模式</option>
			  <option value="pve">PVE模式</option>
			</select>
			<select id="bossList" style="display:none">
			  <option value="zombieKing">BTR-80A「守護者」</option>
			  
			</select>
			<select id="pveModeSelect" style="display:none">
			  <option value="solo">單挑模式</option>
			  <option value="coop">合作模式</option>
			</select>
			<button id="battleStartBtn">開始</button>
		  </div>
		</div>
		
		<!-- 動畫區 -->
		<div class="battle-content">
		  <div class="battle-half left">
			<div class="battle-inner" id="battleSelfAnim">
			  <!-- 己方動畫內容，其僵尸精靈圖將取自全局配置 -->
			</div>
		  </div>
		  <div class="battle-half right">
			<div class="battle-inner" id="battleEnemyAnim">
			  <!-- 敵方動畫保持原有邏輯 -->
			</div>
		  </div>
		</div>
	  </div>
	  <!-- 日誌區 -->
	  <div class="battle-log" id="battleLog">
		<h3 class="battle-log-title">戰鬥日誌</h3>
		<div class="log" id="battleLogContent"></div>
	  </div>
	</div>
	  <!-- ===== 新增： 衣櫃模式（Wardrobe Mode）彈窗 ===== -->
	   <div id="wardrobeOverlay" class="modal-overlay">
		<div id="wardrobeModal">
		  <div id="wardrobeHeader">
			<span>衣櫃</span>
			<button id="wardrobeCloseBtn">X</button>
		  </div>
		  <div id="wardrobeTabs">
			<button id="tabZombie" class="active">僵尸</button>
			<button id="tabArmor">裝甲</button>
		  </div>
		  <div id="wardrobeContent">
			<!-- 卡片內容會由 JS 動態生成 -->
		  </div>
		</div>
	  </div>



  
  <script>
  
    // 替換以下配置為你自己的 Firebase 配置
	var firebaseConfig = {
	  apiKey: "AIzaSyDKXgDOWZnTF9cBTCCOc6kgMSnJLZplFiY",
	  authDomain: "san1tater-gz2.firebaseapp.com",
	  databaseURL: "https://san1tater-gz2-default-rtdb.asia-southeast1.firebasedatabase.app",
	  projectId: "san1tater-gz2",
	  storageBucket: "san1tater-gz2.firebasestorage.app",
	  messagingSenderId: "554205994483",
	  appId: "1:554205994483:web:1389f62227f078f00ac686"
	};

	// 初始化 Firebase
	firebase.initializeApp(firebaseConfig);
	var currentUid = firebase.auth().currentUser ? firebase.auth().currentUser.uid : "userPlaceholder";	
	var enemyTotalZombies = 0;
    var enemyAllocations = { exploration: 0, farming: 0, recycling: 0, research: 0 };


	let achievements = [];  // 儲存稱號對象，每個稱號包含 category, title, rarity, unlockedTime 等屬性
	// 【新增】在全局範圍定義稀有度映射，確保所有函數均可訪問
	var rarityMapping = {
	  junk: "[破爛的]",
	  old: "[陳舊的]",
	  damaged: "[破損的]",
	  common: "[正常的]",
	  decent: "[看起來不錯的]",
	  sealed: "[未開封的]",
	  selected: "[精挑細選的]",
	  tested: "[歷經考驗的]",
	  rare: "[稀有的]",
	  epic: "[史詩的]",
	  legendary: "[傳奇的]",
	  divine: "[神聖的]"
	};

    let ITEM_DATA = {
	  food: {
		names: ['罐頭食品', '壓縮餅乾', '軍用口糧', '脫水蔬菜', '肉類罐頭', '水果乾', '能量棒', '即食麥片', '奶粉', '速食湯包', '真空包裝米', '乾燥豆類', '堅果混合物', '巧克力塊', '蜂蜜', '果醬', '魚罐頭', '醃製肉類', '乾燥麵條', '速食馬鈴薯泥', '即食粥', '咖啡粉', '茶包', '糖', '鹽', '食用油', '花生醬', '乾酪', '餅乾', '泡麵', '乾燥蘑菇', '風乾肉條', '穀物棒', '乾燥湯塊', '燕麥片', '玉米罐頭', '番茄罐頭', '燉煮豆罐頭', '壓縮乾糧', '黑糖', '葡萄乾', '椰子粉', '芝麻糊', '速食蛋花湯', '乾燥海帶', '凍乾水果', '牛肉乾', '豬肉鬆', '即食布丁', '乾燥馬鈴薯', '速食咖哩', '罐裝煉乳', '乾燥香腸', '速食味噌湯', '罐裝玉米濃湯', '乾燥南瓜', '速食燉飯', '罐裝燉肉', '乾燥洋蔥', '速食馬鈴薯餅', '罐裝蔬菜湯', '乾燥胡蘿蔔', '速食義大利麵', '罐裝鮪魚', '乾燥高麗菜', '速食濃湯', '罐裝紅豆', '乾燥青豆', '速食炒飯', '罐裝沙丁魚', '乾燥菠菜', '速食玉米粥', '罐裝奶油蘑菇湯', '乾燥甜椒', '速食燉蔬菜', '罐裝雞肉', '乾燥蘋果', '速食南瓜湯', '罐裝牛肉醬', '乾燥香蕉片', '速食馬鈴薯沙拉', '罐裝羊肉', '乾燥鳳梨', '速食蔬菜泥', '罐裝海鮮濃湯', '乾燥藍莓', '速食燉牛肉', '罐裝火腿', '乾燥芒果', '速食燉豆', '罐裝奶油玉米', '乾燥草莓', '速食燉雞', '罐裝番茄醬', '乾燥奇異果', '速食燉魚', '罐裝奶油南瓜湯', '乾燥覆盆子', '速食燉馬鈴薯'],
		modifiers: [
		   { name: '冷凍乾燥的', effect: 1.3 },   // 保存技術
		   { name: '輻射變異的', effect: 0.8 },  // 環境影響
		   { name: '軍用密封的', effect: 1.5 },  // 包裝規格
		   { name: '部分霉變的', effect: 0.7 },  // 物理狀態
		   { name: '營養強化的', effect: 1.4 },   // 功能屬性
		   { name: '野戰烹製的', effect: 1.1 },  // 製作方式
		   { name: '黏稠液化的', effect: 0.6 },  // 變質狀態
		   { name: '抗輻射處理的', effect: 1.25 }, // 特殊處理
		   { name: '合成再造的', effect: 1.15 }, // 生產方式
		   { name: '真空脫水的', effect: 1.35 }  // 加工技術
		]
	  },
	  materials: {
		names: ['廢金屬', '電子元件', '聚合物', '鈦合金', '鋁材', '銅線', '鋼板', '橡膠', '玻璃', '陶瓷', '混凝土', '木材', '塑料', '纖維布', '石墨', '矽膠', '鎂合金', '鉛塊', '鋅板', '鎳片', '錫箔', '碳纖維', '不鏽鋼', '彈簧', '軸承', '齒輪', '螺絲', '螺母', '螺栓', '鐵絲', '鋼纜', '鋁箔', '銅管', '鋼管', 'PVC管', '電線', '絕緣膠帶', '焊錫', '潤滑油', '砂紙', '磨刀石', '砂輪', '鑽頭', '鋸片', '鉗子', '扳手', '錘頭', '螺絲刀', '鐵釘', '鉚釘', '鐵鍊', '掛鉤', '滑輪', '皮帶', '彈簧鋼', '鋁合金', '黃銅', '青銅', '鑄鐵', '鍍鋅鋼', '鎢絲', '鉬片', '鈷粉', '稀土磁鐵', '鋰電池', '太陽能板', '電路板', '電容器', '電阻器', '二極管', '晶體管', '集成電路', '馬達', '發電機', '變壓器', '電磁鐵', '絕緣漆', '防火棉', '隔熱板', '防水布', '防彈玻璃', '碳化矽', '氧化鋁', '氮化硼', '石棉', '玻璃纖維', '環氧樹脂', '聚氨酯', '尼龍繩', '凱夫拉纖維', '聚乙烯', '聚丙烯', '聚碳酸酯', '聚酯薄膜', '矽鋼片', '磁性材料', '超導材料', '陶瓷纖維', '耐火磚', '水泥', '石膏板', '瀝青', '砂石', '黏土', '石灰', '磚塊', '大理石', '花崗岩', '石英砂', '矽藻土'],
		modifiers: [
		  { name: '俺拾的', effect: 2.0 },
		  { name: '長期廢棄的', effect: 1.8 },
		  { name: '高溫鍛壓的', effect: 1.9 },  // 加工工藝
		  { name: '鏽蝕脆化的', effect: 0.7 },  // 劣化狀態
		  { name: '電鍍強化的', effect: 2.0 },  // 表面處理
		  { name: '回收再造的', effect: 1.5 },  // 來源類型
		  { name: '輻射硬化的', effect: 1.8 },  // 環境適應
		  { name: '精密鑄造的', effect: 2.2 },  // 製造精度
		  { name: '應力斷裂的', effect: 0.5 },  // 結構缺陷
		  { name: '碳纖維複合的', effect: 2.3 },  // 材料類型
		  { name: '戰前庫存的', effect: 1.7 },  // 時代背景
		  { name: '液壓成型的', effect: 2.1 }   // 成型技術
		]
	  },
	  weapons: {
		names: ['長劍', '短劍', '彎刀', '戰斧', '雙手斧', '匕首', '長矛', '短矛', '戰錘', '釘頭錘', '鏈枷', '鐮刀', '鉤鐮', '戟', '長柄斧', '武士刀', '太刀', '肋差', '西洋刺劍', '闊劍', '手半劍', '羅馬短劍', '維京斧', '飛斧', '投矛', '飛刀', '狼牙棒', '流星錘', '戰鐮', '雙截棍', '三節棍', '鐵鞭', '鐵尺', '峨眉刺', '鉤爪', '袖箭', '弩箭', '複合弓', '反曲弓', '長弓', 'AK-74M', 'AK-105', 'AK-12', 'AK-101', 'AK-103', 'AKS-74U', 'RPK-16', 'SKS', 'VPO-136', 'VPO-209', 'ADAR 2-15', 'TX-15 DML', 'M4A1', 'HK416', 'SCAR-L', 'FN FAL', 'SR-25', 'M1A', 'RSASS', 'SV-98', 'Mosin Nagant', 'VSS Vintorez', 'AS VAL', 'SR-3M', '9A-91', 'VSK-94', 'MP5', 'MP7', 'P90', 'UMP45', 'Vector', 'PP-19-01 Vityaz', 'PP-91 Kedr', 'MPX', 'MP9', 'MP-155', 'Saiga-12', 'TOZ-106', 'Remington 870', 'Mossberg 590', 'Glock 17', 'Glock 18C', 'M9A3', 'P226', 'TT-33', 'APS', 'Five-seveN', 'Desert Eagle', 'RSh-12', 'SVD', 'DVL-10', 'T-5000', 'M700', 'MK18', 'HK G36', 'AUG A3', 'DT MDR', 'MCX', 'SA-58', 'RPD', 'PKM'],
		modifiers: [
		  { name: '生鏽的', effect: 0.9 },
		  { name: '精密校準的', effect: 1.6 },  // 調試狀態
		  { name: '經常卡殼的', effect: 0.6 },  // 故障類型
		  { name: '戰術消音的', effect: 1.4 },  // 功能改裝
		  { name: '鏽蝕黏連的', effect: 0.5 },  // 損壞程度
		  { name: '複合材料的', effect: 1.7 },  // 材質特性
		  { name: '強化射速的', effect: 1.8 },  // 射擊模式
		  { name: '防反光處理的', effect: 1.3 },  // 表面處理
		  { name: '雙彈匣系統', effect: 1.5 },  // 結構設計
		  { name: '熱成像瞄具', effect: 1.9 },  // 配件升級
		  { name: '平衡配重的', effect: 1.2 }   // 人體工學
		]
	  },
	  tech: {
		names: ['電路板', '加密芯片', 'AI核心', '量子處理器', '傳感器模組', '伺服馬達', '固態硬盤', '內存條', 'GPU芯片', 'CPU散熱器', '電源模塊', '藍牙模組', 'WiFi天線', '射頻芯片', '光纖收發器', '觸控面板', '液晶屏幕', 'OLED顯示器', '攝像頭模組', '指紋識別器', '聲波馬達', '微型麥克風', '揚聲器單元', '振動電機', '陀螺儀傳感器', '加速度計', '氣壓傳感器', '溫度傳感器', '濕度傳感器', '紅外線發射器', '激光雷達', '毫米波雷達', 'NFC芯片', 'RFID標籤', '生物識別模組', '語音識別芯片', '神經網絡處理器', '邊緣計算單元', '5G基帶芯片', '衛星通信模塊', '無人機飛控', '機械臂控制器', '工業PLC', '機器視覺鏡頭', '3D打印噴頭', 'CNC控制板', '激光切割頭', '電化學傳感器', '光伏電池板', '鋰電池電芯', '超級電容器', '燃料電池堆', '無線充電線圈', '逆變器模塊', '變壓器組件', '繼電器開關', '電磁閥門', '步進電機', '伺服驅動器', '機器人關節模組', '自動駕駛ECU', '車載雷達', '軍規級芯片', '航空電子組件', '衛星姿控系統', '火箭導航芯片', '深空通信終端', '量子加密機', '區塊鏈礦機', '雲服務器主板', '數據中心交換機', '光刻機鏡頭', '半導體蝕刻機', '納米壓印設備', '分子篩膜', '碳納米管材料', '石墨烯晶片', '超導體材料', '柔性電子薄膜', '智能纖維織物', '電子皮膚', '腦機接口探針', '醫療影像探頭', '基因測序儀', '納米機器人', '微流控芯片', '生物傳感器', '人工晶狀體', '仿生義肢', '智能假肢', '外骨骼驅動器', 'AR顯示模組', 'VR定位傳感器', '全息投影儀', '激光投影鏡頭', '智能家居中樞', '物聯網網關', '邊緣服務器', 'AI訓練集群', '超級計算機節點', '量子計算單元'],
		modifiers: [
		  { name: '實驗性的', effect: 1.5 },
		  { name: '破解權限的', effect: 1.8 },   // 軟體狀態
		  { name: '軍用加密的', effect: 2.4 },   // 安全等級
		  { name: '過載燒毀的', effect: 0.3 },   // 損壞類型
		  { name: '模組化設計的', effect: 1.7 },   // 結構特性
		  { name: '量子加密的', effect: 2.6 },   // 技術層級
		  { name: '輻射屏蔽的', effect: 1.5 },   // 防護功能
		  { name: '原型機版本的', effect: 1.9 },   // 開發階段
		  { name: '生物識別的', effect: 2.1 },   // 驗證方式
		  { name: '太陽能供電的', effect: 1.4 },   // 能源類型
		  { name: '全息投影的', effect: 2.0 }    // 顯示技術
		]
	  }
	};

	let LOCATIONS = ["廢棄超市", "核電站廢墟", "地鐵隧道", "軍事基地", "醫院地下室", "研究所遺址", "加油站", "農場穀倉", "廢棄購物中心", "核反應爐冷卻池", "地鐵維修通道", "退役導彈發射井", "精神病院停尸間", "化工實驗室廢墟", "漏油加油站", "穀物黴變倉庫", "銹蝕輸油管道", "坍塌礦山隧道", "廢棄冷凍食品廠", "放射性廢料坑", "城市防空洞群", "軍用雷達站遺址", "焚化爐處理車間", "水庫控制塔", "報廢火車調度場", "抗生素生產線", "鋼鐵廠高爐區", "海底隧道滲水段", "航空燃料儲罐區", "生物製劑實驗室", "晶圓廠無塵室", "纜車中轉機房", "造紙廠汙水池", "地下鈾礦豎井", "跨海大橋橋墩", "電弧爐煉鋼車間", "穀物升降機筒倉", "石化管線加壓站", "報廢船舶拆解場", "放射性汙水井", "山區纜車塔架", "混凝土預拌工廠", "地下配電總站", "戰備糧食儲藏庫", "鐵路信號控制塔", "製藥廠發酵車間", "廢棄紡織印染廠", "山體滑坡掩埋村", "冷戰時期觀察哨", "地下種子基因庫", "港口貨櫃吊裝區", "鋁電解車間廢墟", "河川疏浚設備場", "火力發電煤倉", "廢棄汽車壓縮廠", "深層地質鑽探井", "戰時地下印刷所", "放射性醫療器械庫"];
	let currentUpgradeIndex;
    
	let productionCollection = {};
	
	// 新定義池：增加事件時，僵尸遇到的對象
	const ZOMBIE_ENCOUNTER_POOL = [
	  "流浪的僵尸","孤獨的旅行者","天真的倖存者","迷途的行者","受傷的退伍軍人","帶著染血筆記的科學家","狂熱的末日教徒","改造機車的暴徒","囤藥藥劑師","失語戰地記者","黑市地圖商人","叛逃研究員","免疫體流浪兒","焦慮直升機工程師", "瘋癲尸體畫家", "項圈實驗體", "樂器盒狙擊手", "訊號塔廣播員", "急診室焚尸醫","被感染的護林員", "變異流浪犬", "腐爛救護員", "寄生藤宿主", "嘶吼路燈吊尸"  // 可擴充更多選項
	];

	// 新定義池：減少事件時，僵尸遭遇的不利事件
	const ZOMBIE_DISASTER_POOL = [
	  "暴走的變異獸","大規模的坍塌", "強雷雨天氣","突如其來的颶風","被感染的警犬群","巨型腐爛烏鴉王","寄生藤蔓僵尸樹","成群尸鼠遷徙","黏菌覆蓋的腐化熊","食尸禿鷲群襲擊","軍方燃燒彈地毯轟炸","自動哨戒機槍陣列啟動","地下瓦斯管線大爆炸","高壓電網意外過載","致命抗體空氣傳播","智能無人機群掃蕩","生化溶尸酸雨雲團","精神干擾波無差別攻擊","反僵尸真菌快速蔓延","異種捕食者集團狩獵" // 可擴充更多選項
	];
	const effectMapping = {
	  food: "食物生產",
	  materials: "材料生產",
	  weapons: "武器生產",
	  tech: "科技生產",
	  resourceBonus: "資源加成",
	  explorationBoost: "探索提升",
	  zombieEfficiency: "僵尸效率",
	  production: "僵尸生產",
	  zombieBoost: "僵尸加成",
	  zombieLossReduction: "損失控制",
	  productionBonus: "生產加成",
	  resourceConsumptionRate: "全資源消耗",
	  weaponConsumptionRate: "武器消耗",
	  techConsumptionRate: "科技消耗",
	  foodConsumption: "食物消耗",
	  rareChanceBoost: "稀有幾率",
	  accidentReduction: "意外控制",
	  btrChance: "BTR應答率",
	  btrZombieEventChanceBonus: "BTR協助",
	  btrZombieMaxBonus:"BTR收容",
	  btrRareItemBonus: "BTR收集",
	  maxZombieCapBonus: "收容上限"
	};

	const costMapping = {
	  food: "食物",
	  materials: "材料",
	  weapons: "武器",
	  tech: "科技"
	};
	const resourceMapping = {
	  food: "食物",
	  materials: "材料",
	  weapons: "武器",
	  tech: "科技"
	};

	
	/***** 全局變量定義 *****/
	window.currentZombieSprite = localStorage.getItem("currentZombieSprite") || "images/zombie_search_sprite.png";
    window.currentBtrSprite = localStorage.getItem("currentBtrSprite") || "images/btr_sprite.png";
    window.currentT80Sprite = localStorage.getItem("currentT80Sprite") || "images/t-80_sprite.png";
	function getTotalRarityLevels() {
	  return RARITIES.length;
	}
	// 更新重置循環記錄的顯示
	function updateResetCycleDisplay() {
	  const totalRarityLevels = getTotalRarityLevels();  // 動態獲取總數
	  const cycleCount = Math.floor(gameState.resetCounter / totalRarityLevels);
	  const displayElem = document.getElementById("resetCycleDisplay");
	  if (displayElem) {
		displayElem.innerHTML = `循環次數：${cycleCount}`;
	  }
	}
	function updateResourceCardsBorder() {
	  // 定義稀有度列表，順序從低到高
	  const rarityList = [
		"junk", "old", "damaged", "common",
		"decent", "sealed", "selected", "tested",
		"rare", "epic", "legendary", "divine"
	  ];
	  
	  // 根據 gameState.resetCounts，分別為各資源計算重置次數對應的索引
	  const foodRarity = rarityList[ gameState.resetCounts.food % rarityList.length ];
	  const materialsRarity = rarityList[ gameState.resetCounts.materials % rarityList.length ];
	  const weaponsRarity = rarityList[ gameState.resetCounts.weapons % rarityList.length ];
	  const techRarity = rarityList[ gameState.resetCounts.tech % rarityList.length ];
	  
	   // 取得資源卡的 DOM 元素（假設資源數字元素的父元素為選項卡容器）
	  const foodCard = document.getElementById("foodCount")?.parentElement;
	  const materialsCard = document.getElementById("materialsCount")?.parentElement;
	  const weaponsCard = document.getElementById("weaponsCount")?.parentElement;
	  const techCard = document.getElementById("techCount")?.parentElement;
	  
	  // 更新為只修改 box-shadow 顏色，並確保圓角完整顯示
	  if (foodCard) {
		const colorVal = "var(--" + foodRarity + ")";
		foodCard.style.border = "1px solid " + colorVal;
		// 確保圓角、內邊距等設定不受干擾
		foodCard.style.borderRadius = "8px";
	  }
	  if (materialsCard) {
		const colorVal = "var(--" + materialsRarity + ")";
		materialsCard.style.border = "1px solid " + colorVal;
		materialsCard.style.borderRadius = "8px";
	  }
	  if (weaponsCard) {
		const colorVal = "var(--" + weaponsRarity + ")";
		weaponsCard.style.border = "1px solid " + colorVal;
		weaponsCard.style.borderRadius = "8px";
	  }
	  if (techCard) {
		const colorVal = "var(--" + techRarity + ")";
		techCard.style.border = "1px solid " + colorVal;
		techCard.style.borderRadius = "8px";
	  }
	}


	
	// 固定稀有度數組（共 12 個等級）
	const RARITIES = [
	  "junk", "old", "damaged", "common", "decent",
	  "sealed", "selected", "tested", "rare", "epic",
	  "legendary", "divine"
	];

	function calculateTotalCombinations() {
	  let total = 0;
	  // 遍歷 ITEM_DATA 中所有資源類型
	  for (let res in ITEM_DATA) {
		if (ITEM_DATA.hasOwnProperty(res)) {
		  const data = ITEM_DATA[res];
		  // 物品名稱數量
		  const namesCount = Array.isArray(data.names) ? data.names.length : 0;
		  // 詞綴數量，如果 modifiers 不存在則默認為 0
		  const modifiersCount = Array.isArray(data.modifiers) ? data.modifiers.length : 0;
		  const rarityCount = RARITIES.length; // 固定為12

		  // 計算：物品名+稀有度 與 物品名+詞綴+稀有度
		  const countNameRarity = namesCount * rarityCount;
		  const countNameModifierRarity = namesCount * modifiersCount * rarityCount;
		  const resourceTotal = countNameModifierRarity;
		  total += resourceTotal;
		}
	  }
	  return total;
	}

	// 從 ITEM_DATA 中動態計算所有可能的收藏組合數
	let ALL_COMBINATIONS = calculateTotalCombinations();

	// 更新收藏記錄完成度的函數
	function updateCollectionCompletion() {
	  // 已收藏項目數量：以 collectedItems 的鍵數量作為計數
	  const obtained = Object.keys(collectedItems).length;
	  // 計算收藏完成率（百分比），避免除數為 0 的情況
	  const total = ALL_COMBINATIONS || 1;
	  const percentage = (obtained / total) * 100;

	  const completionElem = document.getElementById("collectionCompletion");
	  if (completionElem) {
		// 即使數值為 0，也顯示0/總數: 0.0%
		completionElem.textContent = `${obtained}/${total}(${percentage.toFixed(3)}%)`;
	  }
	}

	
	function showTempMessage(message) {
	  // 找到基地建設容器（必須確保該容器設置 position: relative）
	  let buildingContainer = document.getElementById("buildingSystem");
	  if (!buildingContainer) {
		// 若不存在則退回 body
		buildingContainer = document.body;
	  }

	  // 創建提示元素
	  let tempDiv = document.createElement("div");
	  tempDiv.style.position = "absolute";  // 絕對定位相對於父容器
	  tempDiv.style.top = "0";                // 上緣貼齊父容器頂部
	  tempDiv.style.left = "50%";             // 水平居中
	  tempDiv.style.transform = "translateX(-50%)";
	  tempDiv.style.background = "#333";
	  tempDiv.style.color = "#FFF";
	  tempDiv.style.padding = "1em 2em";
	  tempDiv.style.borderRadius = "12px";
	  tempDiv.style.zIndex = "1100";          // 確保提示層級高於其它內容
	  tempDiv.style.boxShadow = "0 4px 12px rgba(0,0,0,0.3)";
	  tempDiv.textContent = message;

	  // 將提示添加到基地建設容器中
	  buildingContainer.appendChild(tempDiv);

	  // 300 毫秒後自動移除提示
	  setTimeout(function() {
		if (tempDiv.parentNode) {
		  tempDiv.parentNode.removeChild(tempDiv);
		}
	  }, 300);
	}



	
	//生產收藏彈窗
	function showProductionCollection() {
	  // 將 productionCollection 轉換為陣列後排序（如依獲取次數從高到低排序）
	  let prodItems = Object.keys(productionCollection).map(key => ({
		name: key,
		count: productionCollection[key]
	  }));
	  
	  prodItems.sort((a, b) => b.count - a.count);
	  prodItems = prodItems.slice(0, 100); // 只取前100條
	  
	  let html = `<table class="collection-table">
		<thead>
		  <tr>
			<th>物品名稱</th>
			<th>獲得次數</th>
		  </tr>
		</thead>
		<tbody>`;

	  
	  prodItems.forEach(item => {
		html += `<tr>
		  <td style="border:1px solid var(--border-color); padding:5px; text-align: center;">${item.name}</td>
		  <td style="border:1px solid var(--border-color); padding:5px; text-align: center;">${item.count}</td>
		</tr>`;

	  });
	  html += `</tbody></table>`;
	  
	  // 將生成的 HTML 填入生產收藏頁面的內容區域中
	  document.getElementById("productionCollectionContent").innerHTML = html;
	  
	  // 顯示生產收藏彈窗
	  showModal("productionCollectionModal");
	}

	


	const RESOURCE_CAP = 900000000000;  // 所有資源達到此值即認為“達到上限”
	const RESET_VALUE = 100000;     // 重置後每項資源量
	let collectedItems = {};
	let gameState = {
	  resources: { food: 100, materials: 100, weapons: 50, tech: 20 },
	  // 新增：重置次數記錄，初始值為 0
	  resetCounts: { food: 0, materials: 0, weapons: 0, tech: 0 },
	  // 新增統一的資源重置循環記數器
	  resetCounter: 0,
	  totalZombies: 10,
	  allocations: { exploration: 4, farming: 4, recycling: 1, research: 1 },
	  buildings: new Array(9).fill(null).map((_, i) =>
		i === 4 ? { type: 'center', level: 1, upgradable: true } : null
	  ),
	  explorationMilestone: 10,
	  efficiency: { food: 1, materials: 1, weapons: 1, tech: 1, exploration: 1 }
	};

	let BUILDINGS = {
	  center: {
		name: '中心基地',
		buildable: false,
		baseCost: { materials: 200, tech: 50 },
		costMultiplier: 1.5,      // 每升級一次，成本乘以1.5
		baseEffect: { resourceBonus: 0.02, explorationBoost: 0.05 },
		effectMultiplier: 1.2,    // 每升級一次，效果乘以1.2
		getUpgradeInfo: function(currentLevel) {
		  // currentLevel 代表目標升級後的等級
		  return {
			cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  resourceBonus: this.baseEffect.resourceBonus * Math.pow(this.effectMultiplier, currentLevel - 1),
			  explorationBoost: this.baseEffect.explorationBoost * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },

	  barracks: {
		name: '僵尸兵營',
		baseCost: { food: 300, materials: 200 },
		costMultiplier: 1.5,
		baseEffect: { production: 2 },
		// 新增：1级时每秒消耗武器资源比例 (例如 0.05)
		baseWeaponConsumptionRate: 0.01,
		effectMultiplier: 1.2,
		getUpgradeInfo: function(currentLevel) {
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  // 如果目標等級超過中心基地等級則返回 null 表示無法升級
		  if (currentLevel > centerLevel) return null;
		  return {
			cost: {
			  food: Math.floor(this.baseCost.food * Math.pow(this.costMultiplier, currentLevel - 1)),
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  production: this.baseEffect.production * Math.pow(this.effectMultiplier, currentLevel - 1),
			  // 計算等級調整後的武器資源消耗率（例如 1 级时为 baseWeaponConsumptionRate, 后续以 effectMultiplier 指數增長）
			  weaponConsumptionRate: this.baseWeaponConsumptionRate * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },


	  greenhouse: {
		name: '溫室大棚',
		baseCost: { materials: 100, tech: 50 },
		costMultiplier: 1.5,
		baseEffect: { food: 0.1 },
		effectMultiplier: 1.2,
		getUpgradeInfo: function(currentLevel) {
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  if (currentLevel > centerLevel) return null;
		  return {
			cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  food: this.baseEffect.food * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },
	  recyclingFactory: {
	    name: '回收工廠',
	    baseCost: { materials: 150, tech: 50 }, // 與溫室大棚相似的成本
	    costMultiplier: 1.5,                   // 每次升級成本乘以1.5
	    baseEffect: { materials: 0.1 },         // 初始效果：為材料產量加成10%
	    effectMultiplier: 1.2,                 // 每升級一次效果乘以1.2
	    getUpgradeInfo: function(currentLevel) {
		  // 取得中心基地的等級，作為其他建築升級上限的參考
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  // 如果目標等級超過中心基地等級，則返回 null 表示無法升級
		  if (currentLevel > centerLevel) return null;
		  return {
		    cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1))
	        },
		    effect: {
			  // 效果轉為影響材料產量加成
			  materials: this.baseEffect.materials * Math.pow(this.effectMultiplier, currentLevel - 1)
		    }
		  };
	    }
	  },

	  armory: {
		name: '軍械工坊',
		baseCost: { materials: 100, weapons: 150 },
		costMultiplier: 1.5,
		baseEffect: { weapons: 0.3 },
		effectMultiplier: 1.2,
		getUpgradeInfo: function(currentLevel) {
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  if (currentLevel > centerLevel) return null;
		  return {
			cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  weapons: Math.floor(this.baseCost.weapons * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  weapons: this.baseEffect.weapons * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },

	  laboratory: {
		name: '科研實驗室',
		baseCost: { materials: 200, tech: 100 },
		costMultiplier: 1.5,
		baseEffect: { tech: 0.2 },
		effectMultiplier: 1.2,
		getUpgradeInfo: function(currentLevel) {
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  if (currentLevel > centerLevel) return null;
		  return {
			cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  tech: this.baseEffect.tech * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },

	  // 新增：資源增幅站，增加所有資源的產量加成
	  resourceAmplifier: {
		name: '資源增幅站',
		baseCost: { materials: 250, tech: 75, weapons: 250 },
		costMultiplier: 1.6,
		baseEffect: { resourceBonus: 0.05 },  // 初始 +5%
		effectMultiplier: 1.2,
		getUpgradeInfo: function(currentLevel) {
		  // 對於這類建築，可以不受中心基地等級的限制（或另外設定限制）
		  return {
			cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  resourceBonus: this.baseEffect.resourceBonus * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },

	  // 新增：僵尸指揮中心，提高獲得僵尸的機率與數量，同時減少損失
	  // 並增加武器資源消耗：1級時每秒消耗0.5%，隨等級提升，消耗率按 effectMultiplier 增長
	  zombieCommandCenter: {
	    name: '僵尸指揮中心',
	    baseCost: { materials: 250, weapons: 250, tech: 100 },
	    costMultiplier: 1.5,
	    baseEffect: { 
	      zombieBoost: 0.05, 
		  zombieLossReduction: 0.1,
		  maxZombieCapBonus: 525
	    },
	    // 新增：1級時每秒消耗武器資源 0.5%（即 0.005）
	    baseWeaponConsumptionRate: 0.02,
	    effectMultiplier: 1.015,
	    getUpgradeInfo: function(currentLevel) {
	  	  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  if (currentLevel > centerLevel) return null;
		  return {
		    cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  weapons: Math.floor(this.baseCost.weapons * Math.pow(this.costMultiplier, currentLevel - 1))
		    },
		    effect: {
			  zombieBoost: this.baseEffect.zombieBoost * Math.pow(this.effectMultiplier, currentLevel - 1),
			  zombieLossReduction: this.baseEffect.zombieLossReduction * Math.pow(this.effectMultiplier, currentLevel - 1),
			  // 動態計算武器資源消耗率：1級為 baseWeaponConsumptionRate，之後按 effectMultiplier 指數增長
			  weaponConsumptionRate: this.baseWeaponConsumptionRate * Math.pow(this.effectMultiplier, currentLevel - 1),
			  maxZombieCapBonus: this.baseEffect.maxZombieCapBonus * currentLevel  
		    }
		  };
	    }
	  },


	  // 新增：珍稀庫，提高高稀有度物品獲得率
	  rareVault: {
		name: '珍稀庫',
		baseCost: { tech: 500, materials: 150, weapons: 150 },
		costMultiplier: 1.55,
		baseEffect: { rareChanceBoost: 0.05, techConsumptionRate: 0.05},  // 初始 +5%
		effectMultiplier: 1.2,
		getUpgradeInfo: function(currentLevel) {
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  if (currentLevel > centerLevel) return null;
		  return {
			cost: {
			  tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1)),
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  rareChanceBoost: this.baseEffect.rareChanceBoost * Math.pow(this.effectMultiplier, currentLevel - 1),
			  techConsumptionRate: this.baseEffect.techConsumptionRate * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },

	  // 新增：警衛室，給予強力生產加成，但持續消耗武器資源
	  guardFacility: {
		name: '警衛室',
		baseCost: { weapons: 350, materials: 150, tech: 150 },
		costMultiplier: 1.7,
		baseEffect: { productionBonus: 0.1, weaponConsumptionRate: 0.02 },
		effectMultiplier: 1.2,
		getUpgradeInfo: function(currentLevel) {
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  if (currentLevel > centerLevel) return null;
		  return {
			cost: {
			  weapons: Math.floor(this.baseCost.weapons * Math.pow(this.costMultiplier, currentLevel - 1)),
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  productionBonus: this.baseEffect.productionBonus * Math.pow(this.effectMultiplier, currentLevel - 1),
			  weaponConsumptionRate: this.baseEffect.weaponConsumptionRate * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },
	  safetyCenter: {
		  name: '安全中心',
		  // 可根據需求自訂成本，這裡僅提供一個示例
		  baseCost: { materials: 400, tech: 150, weapons: 500 },
		  costMultiplier: 1.6,
		  baseEffect: {
			accidentReduction: 0.05,        // 1級時降低5%
			resourceConsumptionRate: 0.05     // 1級時，每秒消耗0.05×總僵尸數的資源
		  },
		  effectMultiplier: 1.025,  // 升級時效果乘子，例如每升級一次效果乘以1.1
		  getUpgradeInfo: function(currentLevel) {
			const accidentReduction = Math.min(this.baseEffect.accidentReduction * Math.pow(this.effectMultiplier, currentLevel - 1), 0.50);
			const resourceConsumptionRate = Math.min(this.baseEffect.resourceConsumptionRate * Math.pow(this.effectMultiplier, currentLevel - 1), 0.4);
			return {
			  cost: {
				materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
				tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1)),
				weapons: Math.floor(this.baseCost.weapons * Math.pow(this.costMultiplier, currentLevel - 1))
			  },
			  effect: {
				accidentReduction: accidentReduction,
				resourceConsumptionRate: resourceConsumptionRate
			  }
			};
		  }
		},
		armoredGarage: {
		  name: '拖拉機廠',
		  baseCost: { weapons: 400, materials: 300, tech: 200 },
		  costMultiplier: 1.6,
		  baseEffect: { 
			foodConsumption: 1000,               // 每一輪（或每次 gameLoop）消耗的食物量
			btrChance: 0.50,                   // 每 30 秒 50% 觸發 BTR 事件
			btrZombieEventChanceBonus: 0.20,   // 在 BTR 效果期間，增加 20% 僵尸事件觸發機率
			btrZombieMaxBonus: 0.10,           // 同時提高最大僵尸獲得比例 10%
			btrRareItemBonus: 0.20             // 增加高稀有度物品機率 20%
		  },
		  effectMultiplier: 1.05,
		  getUpgradeInfo: function(currentLevel) {
			return {
			  cost: {
				weapons: Math.floor(this.baseCost.weapons * Math.pow(this.costMultiplier, currentLevel - 1)),
				materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
				tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1))
			  },
			  effect: {
				foodConsumption: this.baseEffect.foodConsumption * Math.pow(this.effectMultiplier, currentLevel - 1),
				btrChance: this.baseEffect.btrChance * Math.pow(this.effectMultiplier, currentLevel - 1),
				btrZombieEventChanceBonus: this.baseEffect.btrZombieEventChanceBonus * Math.pow(this.effectMultiplier, currentLevel - 1),
				btrZombieMaxBonus: this.baseEffect.btrZombieMaxBonus * Math.pow(this.effectMultiplier, currentLevel - 1),
				btrRareItemBonus: this.baseEffect.btrRareItemBonus * Math.pow(this.effectMultiplier, currentLevel - 1)
			  }
			};
		  }
		},	  
	};
	

	/***** 探索隊及僵尸事件處理 *****/
	function addEventLog(message, rarity, eventType = "exploration", applyZombieStyle = false) {
	  if (eventType === "production") {
		message = message.replace(/\n/g, " ");
	  }
	  let logContainerId = (eventType === "production") ? "productionLog" : "explorationLog";
	  const logElem = document.getElementById(logContainerId);
	  if (logElem) {
		const previousScrollTop = logElem.scrollTop;
		const isAtBottom = (logElem.scrollTop + logElem.clientHeight >= logElem.scrollHeight - 5);
		const maxLogs = 20;
		let removedHeight = 0;
		while (logElem.childElementCount >= maxLogs) {
		  const first = logElem.firstElementChild;
		  removedHeight += first.offsetHeight;
		  logElem.removeChild(first);
		}
		// 定義稀有度映射對象
		// 創建新的日誌元素
		const div = document.createElement("div");
		div.className = `log-entry ${rarity}`;
		// 當事件類型為 "zombie" 或要求使用 zombie 樣式時添加對應class
		if (eventType === "zombie" || applyZombieStyle) {
		  div.className += " zombie-event";
		}
		// 根據事件類型決定使用 innerHTML 還是 textContent
		div.innerHTML = message;
		
		// 添加到日誌容器中
		logElem.appendChild(div);
		
		// 更新滾動：如果用戶在底部，則滾動到底部；如果不在底部，則調整 scrollTop，以讓原有數據上移被刪除訊息的高度
		if (isAtBottom) {
		  logElem.scrollTop = logElem.scrollHeight;
		} else {
		  logElem.scrollTop = previousScrollTop - removedHeight;
		}

	  }
	}

	function logResource(resource, itemName, amount, eventType = "production") {
	  // 使用映射表將英文資源名轉為中文
	  const resourceCn = resourceMapping[resource] || resource;
	  
	  if (eventType === "production") {
		const fullMessage = `<span style="white-space: normal; display: inline;">生產: ${itemName} +${amount} ${resourceCn}</span>`;
		addEventLog(fullMessage, 'common', eventType);
	  } else {
		addEventLog(`生產: ${itemName} +${amount} ${resourceCn}`, 'common', eventType);
	  }
	  
	  if (!productionCollection[itemName]) {
		productionCollection[itemName] = 0;
	  }
	  productionCollection[itemName] += 1;
	  
	  // 更新收藏記錄（這裡如果需要中文化，也可同步用中文顯示）
	  if (!collectedItems[itemName]) {
		collectedItems[itemName] = { count: 1, rarity: 'common' };
	  } else {
		collectedItems[itemName].count += 1;
	  }
	}


    function checkUpgradable(type, level) {
	  const centerBuilding = gameState.buildings.find(b => b && b.type.toLowerCase() === "center");
	  const centerLevel = centerBuilding ? centerBuilding.level : 1;

	  if (type === "center") {
		return true; // 讓中心基地無限制升級
	  } else {
		return level < centerLevel; // 其他建築等級不能超過中心基地
	  }
	}

	// 根據稀有度權重隨機選取一個稀有度
	function weightedRandomRarity(teamSize) {
	  const weights = {
		junk: 25,
		old: 20,
		damaged: 15,
		common: 15,
		decent: 10,
		sealed: 5,
		selected: 4,
		tested: 3,
		rare: 2,
		epic: 0.5,
		legendary: 0.3,
		divine: 0.2
	  };
	   // 例如：當 teamSize 過 10 時，給高稀有度加上額外獎勵
	  // 下面這個 bonus 使用對數函數產生一個隨著 teamSize 增長但邊際效益遞減的加成
	  let bonus = 0;
	  if (teamSize > 10) {
		bonus = 0.2 * Math.log(teamSize); // 你可以根據需求微調這裡的係數
	  }
	  
	  // 將 bonus 加到高稀有度項目上（也可以針對不同稀有度設置不同增幅）
	  weights.rare += bonus;
	  weights.epic += bonus * 0.8;
	  weights.legendary += bonus * 0.5;
	  weights.divine += bonus * 0.3;
	  
	  if (isBTRActive) {
		weights.rare *= 1.5;
		weights.epic *= 1.5;
		weights.legendary *= 1.5;
		weights.divine *= 1.5;
	  }
	  let total = Object.values(weights).reduce((a, b) => a + b, 0);
	  let rand = Math.random() * total;
	  return Object.keys(weights).find(key => (rand -= weights[key]) < 0);
	}

	// 根據稀有度倍率計算最終數值
	function applyRarityMultiplier(base, rarity) {
	  const multipliers = {
		junk: 1,
		old: 1.5,
		damaged: 2,
		common: 2.5,
		decent: 3,
		sealed: 3.5,
		selected: 4,
		tested: 5,
		rare: 6,
		epic: 8,
		legendary: 10,
		divine: 12
	  };
	  return base * multipliers[rarity];
	}

	function generateZombieChange(teamSize) {
	  // 如果存在 armoredGarage，則閱讀它的加成效果
	  let bonusPositive = 0;      // 正向事件概率加成
	  let gainBonus = 0; // 新增：专门处理增益的变量
	  let lossReduction = 0;      // 負向事件損失折扣（例如 0.25 表示損失降低 25%）
	  if (isBTRActive) {
		const garages = gameState.buildings.filter(b =>
		  b && 
		  b.type && 
		  typeof b.type === 'string' && 
		  b.type.toLowerCase() === "armoredgarage");
		  
		if (garages.length > 0) {
		  const garageInfo = BUILDINGS.armoredGarage.getUpgradeInfo(garages[0].level);
		  bonusPositive = garageInfo.effect.btrZombieEventChanceBonus || 0;
		  gainBonus = garageInfo.effect.btrZombieGainBonus || 0; // 使用新字段
		  lossReduction = garageInfo.effect.btrZombieMaxBonus || 0;
		}
	  }
	  // 若總僵尸數為 0，直接返回 0
	  if (gameState.totalZombies <= 0) return 0;
	  
	  let baseZombieChange = 0;
	  // 正向事件機率：原本 40%，加上 armoredGarage 的 bonusPositive
	  if (Math.random() < (0.4 + bonusPositive)) {
		// 增加僵尸：正向事件
		baseZombieChange = Math.floor(teamSize * (0.001 + Math.random() * 1.9));
	  } else {
		// 負向事件：損失僵尸
		// 降低負向事件的損失量：乘以 (1 - lossReduction)
		baseZombieChange = -Math.floor(teamSize * (0.001 + Math.random() * 0.7) * (1 - lossReduction));
	  }

	  // 利用探索部門與總僵尸數計算當前比例
	  let explorationRatio = (gameState.totalZombies > 0) ? (teamSize / gameState.totalZombies) : 0;
	  const targetRatio = 0.4; // 目標比例 40%

	  // 依比例計算一個偏移量
	  let offset = 0;
	  if (explorationRatio < targetRatio) {
		offset = 0.05 * gameState.totalZombies * (targetRatio - explorationRatio);
	  } else if (explorationRatio > targetRatio) {
		offset = -0.1 * gameState.totalZombies * (explorationRatio - targetRatio);
	  }
	  
	  const finalZombieChange = Math.round(baseZombieChange + offset);
	  // 定義基本上限
	  let baseCap = 80000;

	  // 累計所有僵尸指揮中心的額外收容值（注意：這裡不混淆其他建築，僅針對type === "zombiecommandcenter"）
	  const zccBuildings = gameState.buildings.filter(b =>
	  b && b.type.toLowerCase() === "zombiecommandcenter"
	  );
	  let bonusTotal = 0;
	  zccBuildings.forEach(b => {
	    const info = BUILDINGS.zombieCommandCenter.getUpgradeInfo(b.level);
	    if (info && typeof info.effect.maxZombieCapBonus === 'number') {
		  bonusTotal += info.effect.maxZombieCapBonus;
	    }
	  });
	  // 初步上限＝基本上限加上所有加成
	  let effectiveCap = baseCap + bonusTotal;

	  // 如果 BTR 事件處於激活狀態，則根據拖拉機廠的 btrZombieMaxBonus 比例進一步提升上限
	  if (isBTRActive) {
	    const garages = gameState.buildings.filter(b =>
		  b && b.type.toLowerCase() === "armoredgarage"
	    );
	    garages.forEach(b => {
		  const info = BUILDINGS.armoredGarage.getUpgradeInfo(b.level);
		  if (info && typeof info.effect.btrZombieMaxBonus === 'number') {
		    // 此處我們按比例增加上限，例如 bonus 0.10 就增加 10%：
		    effectiveCap += Math.floor(effectiveCap * info.effect.btrZombieMaxBonus);
		  }
	    });
	  }
	  // 最後，若最終計算的僵尸增加數量超過 effectiveCap，則返回上限值
	  if (finalZombieChange > effectiveCap) {
	    return effectiveCap;
	  }
	  return finalZombieChange;
	}



	// 定義資源名稱的中文映射對象

	function generateExplorationResult(teamSize) {
	  // 原有隨機生成部分
	  const location = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
	  const resourceTypes = ['food', 'materials', 'weapons', 'tech'];
	  const resource = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
	  const rarity = weightedRandomRarity(teamSize);
	  const baseAmount = Math.floor(Math.random() * 5) + 5;
	  
	  const randFactor = 0.95 + Math.random() * 0.1;
	  // 原來使用對數增長：
	  // const multiplier = 1 + 0.3 * Math.log(teamSize + 1);
	  // const computed = applyRarityMultiplier(baseAmount, rarity) * multiplier;
	  // const amount = convertProduction(computed);
	  const computed = applyRarityMultiplier(baseAmount, rarity);
	  const amount = convertProduction(computed);
	  const itemName = getRandomItemName(resource);
	  const modifier = getRandomModifier(resource);
	  
	  // 調用 generateZombieChange 定義，計算探索可能導致的僵尸增加或損失
	  const adjustedZombieChange = generateZombieChange(teamSize);
	  
	  // 返回結果時，利用 resourceMapping 將英文資源名稱轉為中文顯示，但內部仍保持 resource 為英文
	  return {
		resource,
		amount,
		rarity,
		zombieChange: adjustedZombieChange,
		item: `${modifier.name} ${itemName}`,
		log: {
		  text: `探索 ${location} 獲得 ${rarityMapping[rarity]} ${modifier.name} ${itemName} +${amount} ${resourceMapping[resource] || resource}`,
		  zombieText: adjustedZombieChange > 0
			? `⚡ 獲得 ${adjustedZombieChange} 僵尸`
			: adjustedZombieChange < 0
			  ? `☠️ 損失 ${Math.abs(adjustedZombieChange)} 僵尸`
			  : null,
		  rarity
		}
	  };
	}




	
	/**
	 * 根據類型和數量生成探索事件中的僵尸變化描述
	 * @param {string} type - "increase" 或 "decrease"
	 * @param {number} quantity - 變化的僵尸數量（正數，若減少則傳入絕對值）
	 * @returns {string} - 格式化的描述字符串
	 */
	function generateZombieEventDescription(type, quantity) {
	  // 隨機選用一個地點
	  const location = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
	  
	  if (type === "increase") {
		const encounter = ZOMBIE_ENCOUNTER_POOL[Math.floor(Math.random() * ZOMBIE_ENCOUNTER_POOL.length)];
		return `你派出的僵尸在 ${location} 遇到 ${encounter}，⚡獲得 ${quantity} 僵尸。`;
	  } else if (type === "decrease") {
		const disaster = ZOMBIE_DISASTER_POOL[Math.floor(Math.random() * ZOMBIE_DISASTER_POOL.length)];
		return `你派出的僵尸在 ${location} 遭遇 ${disaster}，☠️損失 ${quantity} 僵尸。`;
	  } else {
		return "";
	  }
	}


    /***** 輔助函數 *****/
    function convertProduction(val) {
      return (val > 0 && val < 1) ? 1 : Math.floor(val);
    }
    function formatNumber(num) {
	  if (num === null || num === undefined || isNaN(num)) return "0";
	  if (num < 10000) {
		return num.toFixed(0); // 小於 1 萬時保留 2 位小數
	  } else if (num < 1e8) {  // 1e8 約等於 1 億
		return (num / 1e4).toFixed(2) + "萬";
	  } else if (num < 1e12) {
		return (num / 1e8).toFixed(2) + "億";
	  } else {
		return num.toExponential(2); // 超大數則用科學記數法（一個簡化版）
	  }
	}

    function canAfford(cost) {
      return Object.entries(cost).every(([res, val]) => gameState.resources[res] >= val);
    }
    function payCost(cost) {
      Object.entries(cost).forEach(([res, val]) => {
        gameState.resources[res] -= val;
      });
    }
    function getRandomItemName(resource) {
      return ITEM_DATA[resource].names[Math.floor(Math.random() * ITEM_DATA[resource].names.length)];
    }
    function getRandomModifier(resource) {
      const modifiers = ITEM_DATA[resource].modifiers;
      return modifiers[Math.floor(Math.random() * modifiers.length)];
    }

    /***** 探索隊自動重分配事件 *****/
    
  
    /***** 兵營產生僵尸 *****/
    function produceZombies() {
      const production = gameState.buildings.reduce((sum, b) => {
        if (b && b.type === 'barracks') {
           const info = BUILDINGS.barracks.getUpgradeInfo(b.level);
		  // 如果 info 存在，使用其 effect.production；否則視為 0
		  const prod = info && info.effect && info.effect.production ? info.effect.production : 0;
		  return sum + prod;
		}
		return sum;
	  }, 0);
	  const newZombies = Math.floor(production);
      if (newZombies > 0) {
        let gained = newZombies;
        let toExploration = Math.round(gained * 0.7);
        let toFarming = Math.round(gained * 0.1);
        let toRecycling = Math.round(gained * 0.1);
        let toResearch = Math.round(gained * 0.1);
        let sum = toExploration + toFarming + toRecycling + toResearch;
        if(sum < gained) {
          toExploration += (gained - sum);
        } else if(sum > gained) {
          toExploration -= (sum - gained);
        }
        gameState.totalZombies += gained;
        gameState.allocations.exploration += toExploration;
        gameState.allocations.farming += toFarming;
        gameState.allocations.recycling += toRecycling;
        gameState.allocations.research += toResearch;
        addEventLog(`兵營生產：新增⚡ ${gained} 僵尸，探索+ ${toExploration}, 種植+${toFarming}, 回收+${toRecycling}, 科研+${toResearch}`, 'uncommon', 'zombie');
      }
      updateResourceDisplays();
    }
  
	   // 军械工坊生产武器
	function produceWeaponsFromArmories() {
	  // 取得所有軍械工坊
	  const armories = gameState.buildings.filter(b => b && b.type === 'armory');
	  if (armories.length === 0) return;

	  // 計算科研和回收部門的人數平均值
	  let researchCount = gameState.allocations.research || 0;
	  let recyclingCount = gameState.allocations.recycling || 0;
	  let avg = (researchCount + recyclingCount) / 2;

	  // 根據加成公式計算倍率
	  let baseMultiplier = Math.pow(avg, 0.85);
	  let bonusMultiplier = Math.pow(1.0005, avg);
	  let productionBonus = baseMultiplier * bonusMultiplier;

	  // 遍歷每個軍械工坊累計生產
	  let totalProduction = 0;
	  armories.forEach(b => {
		const config = BUILDINGS.armory;
		const upgradeInfo = config.getUpgradeInfo(b.level);
		if (upgradeInfo && upgradeInfo.effect && upgradeInfo.effect.weapons) {
		  totalProduction += upgradeInfo.effect.weapons * productionBonus;
		}
	  });

	  const roundedProduction = Math.round(totalProduction);
	  // 設定單次生產上限：基礎產量上限為 99000000
	  const productionCap = 99000000;
	  const limitedProduction = Math.min(roundedProduction, productionCap);

	  if (limitedProduction > 0) {
		// 5% 機率觸發特殊（詞條）生產
		if (Math.random() < 0.05) {
		  const modifier = getRandomModifier('weapons');
		  // 以有限制的基礎生產值作為基數，再乘以詞條效果：
		  const modProduction = Math.round(limitedProduction * modifier.effect);
		  // 使用顏色根據詞條效果分類
		  const modColor = (modifier.effect < 1) ? "var(--junk)" : "var(--sealed)";
		  const styledItemName = `<span style="color: ${modColor}; font-weight: bold;">${modifier.name} ${getRandomItemName('weapons')}</span>`;
		  
		  logResource('weapons', styledItemName, modProduction, "production");
		  gameState.resources.weapons += modProduction;
		} else {
		  logResource('weapons', getRandomItemName('weapons'), limitedProduction, "production");
		  gameState.resources.weapons += limitedProduction;
		}
	  }
	  
	  updateResourceDisplays();
	}




    function handleExploration() {
	  const teamSize = gameState.allocations.exploration;
	  if (teamSize < 1) return;
	  const baseMultiplier = Math.pow(teamSize, 0.85);
	  const bonusMultiplier = Math.pow(1.0005, teamSize);
	  const effectiveMultiplier = baseMultiplier * bonusMultiplier;

	  const result = generateExplorationResult(teamSize);
	  let amountAfterMultiplier = Math.floor(result.amount * effectiveMultiplier);
  
	  // 設定單次資源獲得上限（例如 productionCap 為 990000）
	  const normalMultiplier = 2.5;
	  const baseCapFactor = 99000000 / normalMultiplier; // 3960000
	  const rarityMultipliers = {
		  junk: 1,
		  old: 1.5,
		  damaged: 2,
		  common: 2.5,
		  decent: 3,
		  sealed: 3.5,
		  selected: 4,
		  tested: 5,
		  rare: 6,
		  epic: 8,
		  legendary: 10,
		  divine: 12
	  };
	  const rarityCap = baseCapFactor * (rarityMultipliers[result.rarity] || normalMultiplier);
      amountAfterMultiplier = Math.min(amountAfterMultiplier, rarityCap);
	  
	  result.amount = amountAfterMultiplier;
	  result.log.text = result.log.text.replace(/\+\d+/, "+" + result.amount);
	  
	  // 將獲得數量累加到對應資源上;
	  gameState.resources[result.resource] += result.amount;
	  addEventLog(result.log.text, result.rarity, "exploration");
	  
	  // 更新收藏記錄
	  if (result.item) {
		const key = `${result.item}_${result.rarity}`;
	    if (collectedItems[key]) {
		  collectedItems[key].count += 1;
	    } else {
	      collectedItems[key] = { count: 1, rarity: result.rarity, name: result.item };
	    }
      }
	  
	  // 處理僵尸變化描述（即使結果可能為0也會生成 log）
	  if (result.zombieChange !== 0) {
		let desc = "";
		if (result.zombieChange > 0) {
		  triggerZombieEntry();
		  const gain = result.zombieChange;
		  const toExploration = Math.round(gain * 0.5);
		  const toFarming = Math.round(gain * 0.3);
		  const toRecycling = Math.round(gain * 0.1);
		  const toResearch = gain - toExploration - toFarming - toRecycling;
		  gameState.totalZombies += gain;
		  gameState.allocations.exploration += toExploration;
		  gameState.allocations.farming += toFarming;
		  gameState.allocations.recycling += toRecycling;
		  gameState.allocations.research += toResearch;
		  const encounterMessage = generateZombieEventDescription("increase", gain);
		  const distributionMessage = `探索 +${toExploration}，種植 +${toFarming}，回收 +${toRecycling}，科研 +${toResearch}`;
		  desc = encounterMessage + distributionMessage;
		} else {
		  triggerZombieLying();
		  const loss = Math.abs(result.zombieChange);
		  desc = generateZombieEventDescription("decrease", loss);
		  gameState.totalZombies = Math.max(0, gameState.totalZombies - loss);
		  gameState.allocations.exploration = Math.max(0, gameState.allocations.exploration - loss);
		}
		addEventLog(desc, "uncommon", "zombie");
	  }
	  
	  updateAllDisplays();
	}

  
    /***** 資源生產 *****/
    function produceResources(dept, resource, baseRate) {
      const count = gameState.allocations[dept];
      if (count <= 0) return;
      const baseMultiplier = Math.pow(count, 0.85);
	  const bonusMultiplier = Math.pow(1.0005, count);
	  const effectiveMultiplier = baseMultiplier * bonusMultiplier;
      const computed = baseRate * effectiveMultiplier * gameState.efficiency[resource];
      const amount = convertProduction(computed);
	  
	  // 設置單次生產上限
	  const productionCap = 99000000;
	  // 限制原始生產量
	  const limitedAmount = Math.min(amount, productionCap);
	  
      if (Math.random() < 0.05) {
        const modifier = getRandomModifier(resource);
        const modAmount = convertProduction(limitedAmount * modifier.effect);
		const modColor = (modifier.effect < 1) ? "var(--junk)" : "var(--sealed)";
		const styledItemName = `<span style="color: ${modColor}; font-weight: bold;">${modifier.name} ${getRandomItemName(resource)}</span>`;
        logResource(resource, styledItemName, modAmount, "production");
		} else {
		  logResource(resource, getRandomItemName(resource), limitedAmount, "production");
		}
      gameState.resources[resource] += limitedAmount;
	  
	  // 新增隨機事件：僵尸損失（僅對種植、回收、科研部門）
	  if (dept === "farming" || dept === "recycling" || dept === "research") {
	  const baseEventProbability = 0.005; // 基礎事故觸發機率
	  // 根据部門僵尸數量，在基礎概率上加成，假設每隻僵尸增加 0.01 的概率
	  const deptZombies = gameState.allocations[dept] || 0;
	  let eventProbability = baseEventProbability + (deptZombies * 0.001);
	  // 防止機率超過 100%
	  eventProbability = Math.min(eventProbability, 0.8);

	  let lossMultiplier = 1;
	  
	  // 如安全中心存在，則按其效果降低事故觸發機率
	  const safety = gameState.buildings.find(b => b && b.type.toLowerCase() === "safetycenter");
	  if (safety) {
		const safetyInfo = BUILDINGS.safetyCenter.getUpgradeInfo(safety.level);
		const reduction = safetyInfo.effect.accidentReduction; // 如降幅 0.05 表示事故機率乘以 0.95
		eventProbability *= (1 - reduction);
		lossMultiplier = (1 - reduction);
	  }
	  
	  if (Math.random() < eventProbability) {
		// 隨機損失比例介於 5% 到 80%
		const lossPercentage = 0.01 + Math.random() * 0.8;
		// 根據該部門僵尸數計算損失量（lossMultiplier 可在未來用於進一步調整損失量）
		let lost = Math.floor(gameState.allocations[dept] * lossPercentage * lossMultiplier);
		// 若計算後的損失為 0，但部門中仍有僵尸，最低可以考慮損失 0（或保持 0 視具體需求而定）
		if (lost < 1 && gameState.allocations[dept] > 0) {
		  lost = 0;
		}
		gameState.allocations[dept] -= lost;
		gameState.totalZombies -= lost;
		
		let eventMsg = "";
		if (dept === "farming") {
		  eventMsg = `集體食物中毒：種植部門☠️損失 ${lost} 僵尸 (${(lossPercentage * 100).toFixed(1)}%)`;
		} else if (dept === "recycling") {
		  eventMsg = `僵尸操作不當：回收部門☠️損失 ${lost} 僵尸 (${(lossPercentage * 100).toFixed(1)}%)`;
		} else if (dept === "research") {
		  eventMsg = `試劑連環爆炸：科研部門☠️損失 ${lost} 僵尸 (${(lossPercentage * 100).toFixed(1)}%)`;
		}
		addEventLog(eventMsg, "warning", "production", true);
		triggerProductionAccident(dept);
	  }
	}	  
      updateResourceDisplays();
    }
	
	function updateTechConsumptionFromRareVault() {
	  let totalTechRate = 0;
	  // 選取所有珍稀庫
	  const rareVaultBuildings = gameState.buildings.filter(b => b && b.type.toLowerCase() === "rarevault");
	  rareVaultBuildings.forEach(b => {
		const info = BUILDINGS.rarevault.getUpgradeInfo(b.level);
		if (info && typeof info.effect.techConsumptionRate !== "undefined") {
		  totalTechRate += info.effect.techConsumptionRate;
		}
	  });
	  
	  // 消耗量 = 累計的tech消耗率 * 遊戲中總僵尸數
	  const consumption = totalTechRate * gameState.totalZombies;
	  
	  // 從科技資源中扣除，並保持不小於0
	  gameState.resources.tech = Math.max(0, gameState.resources.tech - consumption);
	  
	  updateResourceDisplays();
	}


	function updateSafetyCenterConsumption() {
	  // 檢查安全中心是否存在
	  const safety = gameState.buildings.find(b => b && b.type.toLowerCase() === "safetycenter");
	  if (!safety) return;
	  
	  const safetyInfo = BUILDINGS.safetyCenter.getUpgradeInfo(safety.level);
	  const consumptionRate = safetyInfo.effect.resourceConsumptionRate; // 每秒消耗百分比，如基礎 0.05，最高 0.4
	  
	  // 根據僵尸總數，對四種資源計算消耗量
	  const resourceList = ["food", "materials", "weapons", "tech"];
	  resourceList.forEach(res => {
		// 消耗量 = consumptionRate * totalZombies
		const toConsume = consumptionRate * gameState.totalZombies;
		gameState.resources[res] = Math.max(0, gameState.resources[res] - toConsume);
	  });
	  
	  updateResourceDisplays();
	}
	function updateBarracksWeaponConsumption() {
	  // 篩選出所有“barracks”建築
	  const barracksBuildings = gameState.buildings.filter(b => b && b.type.toLowerCase() === "barracks");
	  if (barracksBuildings.length === 0) return;
	  
	  let totalConsumption = 0;
	  
	  // 對每棟僵尸兵營依據其等級計算消耗率（取 getUpgradeInfo 計算的消耗率）
	  barracksBuildings.forEach(b => {
		// 若僵尸兵營的升級資訊可求得，則讀取該棟建築的武器資源消耗率
		const upgradeInfo = (typeof BUILDINGS[b.type].getUpgradeInfo === "function") 
							 ? BUILDINGS[b.type].getUpgradeInfo(b.level)
							 : null;
		if (upgradeInfo && upgradeInfo.effect.weaponConsumptionRate) {
		  totalConsumption += upgradeInfo.effect.weaponConsumptionRate;
		}
	  });
	  
	  // 以總僵尸數為基礎，計算累計的武器資源消耗量
	  // 例如：總消耗 = totalConsumption * gameState.totalZombies
	  const consumption = totalConsumption * gameState.totalZombies;
	  
	  // 從玩家的武器資源中扣除
	  gameState.resources.weapons = Math.max(0, gameState.resources.weapons - consumption);
	  
	  // 更新資源顯示
	  updateResourceDisplays();
	}


    function checkResourceCap() {
	// 檢查所有資源是否均達到 RESOURCE_CAP
	  if (
		gameState.resources.food >= RESOURCE_CAP &&
		gameState.resources.materials >= RESOURCE_CAP &&
		gameState.resources.weapons >= RESOURCE_CAP &&
		gameState.resources.tech >= RESOURCE_CAP
	  ) {
		// 重置所有資源為 RESET_VALUE
		gameState.resources.food = RESET_VALUE;
		gameState.resources.materials = RESET_VALUE;
		gameState.resources.weapons = RESET_VALUE;
		gameState.resources.tech = RESET_VALUE;
		
		// 累加每一項資源的重置次數
		gameState.resetCounts.food++;
		gameState.resetCounts.materials++;
		gameState.resetCounts.weapons++;
		gameState.resetCounts.tech++;
		
		gameState.resetCounter++; // 增加一次重置計數

		// 更新資源卡的邊框樣式
		updateResourceCardsBorder();
		updateResetCycleDisplay()
	  }
	}

    /***** 食物消耗與僵尸損失 *****/
    function updateFoodConsumption() {
      let foodNeeded = Math.floor(gameState.totalZombies * 3);
      if (foodNeeded > 0 && gameState.resources.food >= foodNeeded) {
        gameState.resources.food -= foodNeeded;
        addEventLog(`消耗食物：${foodNeeded}`, 'common');
      } else if (gameState.resources.food <= 0) {
        let removeNum = Math.ceil(gameState.totalZombies * 1);
        if (removeNum < 1) removeNum = 1;
        let priorities = ['exploration', 'research', 'recycling', 'farming'];
        for (let dept of priorities) {
          let available = gameState.allocations[dept] || 0;
          if (available >= removeNum) {
            gameState.allocations[dept] -= removeNum;
            gameState.totalZombies -= removeNum;
            addEventLog(`食物耗盡，${dept}失去 ${removeNum} 僵尸`, 'epic');
            removeNum = 0;
            break;
          } else {
            gameState.totalZombies -= available;
            addEventLog(`食物耗盡，${dept}失去 ${available} 僵尸`, 'epic');
            removeNum -= available;
            gameState.allocations[dept] = 0;
          }
        }
		gameState.totalZombies = Math.max(0, gameState.totalZombies);
        if (gameState.totalZombies <= 0) {
          addEventLog("所有僵尸均已死亡，遊戲結束！", "epic");
          clearInterval(gameLoopInterval);
        }
      }
      updateResourceDisplays();
    }
  
    /***** 更新顯示 *****/
    function updateResourceDisplays() {
	  gameState.totalZombies = Math.max(0, gameState.totalZombies);
      document.getElementById("foodCount").textContent = formatNumber(gameState.resources.food);
      document.getElementById("materialsCount").textContent = formatNumber(gameState.resources.materials);
      document.getElementById("weaponsCount").textContent = formatNumber(gameState.resources.weapons);
      document.getElementById("techCount").textContent = formatNumber(gameState.resources.tech);
      document.getElementById("totalZombies").textContent = formatNumber(gameState.totalZombies);
      const totalAllocated = gameState.allocations.exploration +
                             gameState.allocations.farming +
                             gameState.allocations.recycling +
                             gameState.allocations.research;
      document.getElementById("pendingZombies").textContent = formatNumber(gameState.totalZombies - totalAllocated);
    
	// 檢查並（如有必要）重置資源
	checkResourceCap();
	}
  
    function updateEfficiencyDisplays() {
      document.getElementById("exploreEfficiency").textContent = "效率: " + Math.floor(gameState.efficiency.exploration * 100) + "%";
      document.getElementById("farmEfficiency").textContent = "+" + Math.floor((gameState.efficiency.food - 1) * 100) + "%";
      document.getElementById("recycleEfficiency").textContent = "+" + Math.floor((gameState.efficiency.materials - 1) * 100) + "%";
      document.getElementById("researchEfficiency").textContent = "+" + Math.floor((gameState.efficiency.tech - 1) * 100) + "%";
    }
  
    function updateAllDisplays() {
      updateResourceDisplays();
      document.getElementById("explorationCount").textContent = gameState.allocations.exploration;
      document.getElementById("farmingCount").textContent = gameState.allocations.farming;
      document.getElementById("recyclingCount").textContent = gameState.allocations.recycling;
      document.getElementById("researchCount").textContent = gameState.allocations.research;
      updateEfficiencyDisplays();
      initBuildingGrid();
	  updateZombieSearchSprite();
	  checkBuildingAchievements();
    
    }
	/***** 成就系統 *****/
	const achievementRules = {
	  collectionCompleteness: [
		{ threshold: 0.001, title: "這是啥？", level: 1 },
		{ threshold: 0.1, title: "好像能用", level: 2 },
		{ threshold: 0.5, title: "拾荒者", level: 3 },
		{ threshold: 1, title: "拾荒高手", level: 4 },
		{ threshold: 5, title: "末日採購員", level: 5 },
		{ threshold: 10, title: "清空貨架！", level: 6 },
		{ threshold: 30, title: "物資收集者", level: 7 },
		{ threshold: 50, title: "末日收藏家", level: 8 },
		{ threshold: 70, title: "末日收集狂", level: 9 },
		{ threshold: 85, title: "優秀率", level: 10 },
		{ threshold: 90, title: "強迫症", level: 11 },
		{ threshold: 100, title: "頂級搜刮者", level: 12 }
	  ],
	  divineItems: [
		{ threshold: 1, title: "狗屎運", level: 1 },
		{ threshold: 5, title: "亮閃閃", level: 2 },
		{ threshold: 10, title: "金光閃閃", level: 3 },
		{ threshold: 50, title: "金碧輝煌", level: 4 },
		{ threshold: 100, title: "天選之子", level: 5 },
		{ threshold: 300, title: "鑒寶專家", level: 6 },
		{ threshold: 500, title: "被眷顧者", level: 7 },
		{ threshold: 666, title: "惡魔的祝福", level: 8 },
		{ threshold: 750, title: "科學無法解釋", level: 9 },
		{ threshold: 900, title: "命運的安排", level: 10 },
		{ threshold: 999, title: "倒立惡魔的祝福", level: 11 },
		{ threshold: 1200, title: "這有啥稀奇的？", level: 12 }
	  ],
	  totalZombies: [
		{ threshold: 100, title: "僵尸收容者", level: 1 },
		{ threshold: 200, title: "僵尸小隊", level: 2 },
		{ threshold: 300, title: "僵尸中隊", level: 3 },
		{ threshold: 400, title: "初具規模", level: 4 },
		{ threshold: 500, title: "加強營", level: 5 },
		{ threshold: 1000, title: "積少成多", level: 6 },
		{ threshold: 1500, title: "聚落領主", level: 7 },
		{ threshold: 3000, title: "所向披靡", level: 8 },
		{ threshold: 5000, title: "合成旅", level: 9 },
		{ threshold: 8000, title: "人多尸眾", level: 10 },
		{ threshold: 10000, title: "一方豪強", level: 11 },
		{ threshold: 100000, title: "區域霸主", level: 12 }
	  ],
	  btrTriggers: [
		{ threshold: 1, title: "裝甲保護", level: 1 },
		{ threshold: 5, title: "火力支援", level: 2 },
		{ threshold: 50, title: "裝甲先鋒", level: 3 },
		{ threshold: 100, title: "機械化僵尸", level: 4 },
		{ threshold: 500, title: "尸坦協同", level: 5 },
		{ threshold: 1000, title: "機炮仙人", level: 6 },
		{ threshold: 5000, title: "裝甲猛虎", level: 7 },
		{ threshold: 10000, title: "銅墻鐵壁", level: 8 },
		{ threshold: 20000, title: "堅不可摧", level: 9 },
		{ threshold: 50000, title: "裝甲大軍", level: 10 },
		{ threshold: 100000, title: "鋼鐵尸流", level: 11 },
		{ threshold: 200000, title: "金屬地獄", level: 12 }
	  ]
	};

	// 稀有度映射：根據升級等級返回稀有度
	function getRarityForAchievement(level) {
	  if (level <= 2) return "common";
	  else if (level <= 4) return "uncommon";
	  else if (level <= 6) return "rare";
	  else if (level <= 8) return "epic";
	  else if (level <= 10) return "legendary";
	  else return "divine";
	}

	// 全局陣列保存已獲得成就
	let unlockedAchievements = []; // 每項形如 { category, level, title, rarity, unlockedTime }

	function getAchievementDetails(category, rule) {
	  switch (category) {
		case "collectionCompleteness":
		  return `達到 ${rule.threshold}%收藏率`;
		case "divineItems":
		  return `獲得 ${rule.threshold}件神聖物品`;
		case "totalZombies":
		  return `達到 ${rule.threshold}隻僵尸`;
		case "btrTriggers":
		  return `呼叫BTR ${rule.threshold}次`;
		default:
		  return "";
	  }
	}
	// 檢查建築成就是否已解鎖（根據 category "building" 與成就 title 來判斷）
	function isBuildingAchievementUnlocked(title) {
	  return unlockedAchievements.some(a => a.category === "building" && a.title === title);
	}

	// 解鎖建築類成就。參數：title（成就名稱）、details（成就說明）、rarity（成就稀有度標記，例如 "uncommon"、"rare"、"legendary"）
	function awardBuildingAchievement(title, details, level) {
	  if (isBuildingAchievementUnlocked(title)) return;
	  const rarity = getRarityForAchievement(level);
	  const achievement = {
		category: "building",
		level: level,
		title: title,
		details: details,
		rarity: rarity,
		unlockedTime: Date.now()
	  };
	  unlockedAchievements.push(achievement);
	  if (!gameState.unlockedAchievements) {
		gameState.unlockedAchievements = [];
	  }
	  gameState.unlockedAchievements.push(achievement);
	  addEventLog(`成就解鎖：[${title}] (${details})`, rarity, "achievement");
	  updateAchievementsUI();
	}
	// 檢查是否已解鎖過某項建築成就
	function isBuildingAchievementUnlocked(title) {
	  return unlockedAchievements.some(a => a.category === "building" && a.title === title);
	}
	// 檢查建築成就：如果所有目標成就均已解鎖，則提前返回
	function checkBuildingAchievements() {
	  // 若所有建築成就已解鎖，就不再檢查
	  if (
		isBuildingAchievementUnlocked("報話機") &&
		isBuildingAchievementUnlocked("Алтын") &&
		isBuildingAchievementUnlocked("武裝通信兵") &&
		isBuildingAchievementUnlocked("全副武裝")
	  ) {
		return;
	  }
	  
	  // 檢查是否存在【拖拉機廠】（對應 armoredgarage）
	  const hasTractor = gameState.buildings.some(
		b => b && b.type.toLowerCase() === "armoredgarage"
	  );
	  // 檢查是否存在【軍械工廠】（armory）
	  const hasArmory = gameState.buildings.some(
		b => b && b.type.toLowerCase() === "armory"
	  );
	  // 檢查是否存在【僵尸指揮中心】（zombiecommandcenter）
	  const hasZombieCommand = gameState.buildings.some(
		b => b && b.type.toLowerCase() === "zombiecommandcenter"
	  );
	  
	  // 成就「報話機」：當拖拉機廠存在時
	  if (hasTractor && !isBuildingAchievementUnlocked("報話機")) {
		awardBuildingAchievement("報話機", "建造拖拉機廠", "6");
	  }
	  
	  // 成就「Алтын」：當存在軍械工廠或僵尸指揮中心時
	  if ((hasArmory || hasZombieCommand) && !isBuildingAchievementUnlocked("Алтын")) {
		awardBuildingAchievement("Алтын", "建造軍械工廠或僵尸指揮中心", "6");
	  }
	  if (hasTractor &&(hasArmory || hasZombieCommand) && !isBuildingAchievementUnlocked("武裝通信兵")) {
		awardBuildingAchievement("武裝通信兵", "同時擁有拖拉機廠以及軍械工廠或僵尸指揮中心", "8");
	  }
	  
	  // 成就「全副武裝」：只有當拖拉機廠、軍械工廠與僵尸指揮中心三者同時存在時
	  if (hasTractor && hasArmory && hasZombieCommand && !isBuildingAchievementUnlocked("全副武裝")) {
		awardBuildingAchievement("全副武裝", "同時擁有拖拉機廠、軍械工廠與僵尸指揮中心", "10");
	  }
	}

	
	function isAchievementUnlocked(category, level) {
	  return unlockedAchievements.some(a => a.category === category && a.level === level);
	}

	function awardAchievement(category, rule) {
	  if (isAchievementUnlocked(category, rule.level)) {
		return;
	  }
	  let rarity = getRarityForAchievement(rule.level);
	  let details = getAchievementDetails(category, rule);
	  let achievement = {
		category,
		level: rule.level,
		title: rule.title,
		rarity,
		details,
		unlockedTime: Date.now()
	  };
	  // 永久保存到 gameState
	  if (!gameState.unlockedAchievements) {
		gameState.unlockedAchievements = [];
	  }
	  gameState.unlockedAchievements.push(achievement);
	  unlockedAchievements.push(achievement);
	  addEventLog(`成就解鎖：[${rule.title}] (${category})`, rarity, "achievement");
	  updateAchievementsUI();
	}
	
	/***** (2) 修正神聖物品成就統計 *****/
	// 每次檢查成就前調用，統計 collectedItems 中神聖物品的總數
	function updateDivineItemsCount() {
	  let count = 0;
	  for (let key in collectedItems) {
		if (collectedItems[key].rarity === "divine") {
		  count += collectedItems[key].count;
		}
	  }
	  gameState.divineItemsCount = count;
	}

	function checkAchievements() {
	  updateDivineItemsCount();  // 調整神聖物品數量
	  let collValue = getCollectionCompletion();
	  achievementRules.collectionCompleteness.forEach(rule => {
		if (collValue >= rule.threshold && !isAchievementUnlocked("collectionCompleteness", rule.level)) {
		  awardAchievement("collectionCompleteness", rule);
		}
	  });
	  let divineCount = gameState.divineItemsCount || 0;
	  achievementRules.divineItems.forEach(rule => {
		if (divineCount >= rule.threshold && !isAchievementUnlocked("divineItems", rule.level)) {
		  awardAchievement("divineItems", rule);
		}
	  });
	  let totalZombies = gameState.totalZombies || 0;
	  achievementRules.totalZombies.forEach(rule => {
		if (totalZombies >= rule.threshold && !isAchievementUnlocked("totalZombies", rule.level)) {
		  awardAchievement("totalZombies", rule);
		}
	  });
	  let btrCount = gameState.btrTriggerCount || 0;
	  achievementRules.btrTriggers.forEach(rule => {
		if (btrCount >= rule.threshold && !isAchievementUnlocked("btrTriggers", rule.level)) {
		  awardAchievement("btrTriggers", rule);
		}
	  });
	  updateAchievementsUI();
	}


	function updateAchievementsUI() {
	  const grid = document.getElementById("achievementGrid");
	  if (!grid) return;
	  // 以解鎖時間倒序排序，取最新6個
	  let sorted = unlockedAchievements.slice().sort((a, b) => b.unlockedTime - a.unlockedTime);
	  let latest6 = sorted.slice(0, 6);
	  grid.innerHTML = "";
	  latest6.forEach(ach => {
		const cell = document.createElement("div");
		cell.className = "achievement-cell " + ach.rarity;
		cell.textContent = ach.title;
		grid.appendChild(cell);
	  });
	}

	function showTitlesLibrary() {
	  const container = document.getElementById("titlesContent");
	  if (!container) return;
	  
	  let sorted = unlockedAchievements.slice().sort((a, b) => b.level - a.level);

	  
	  let html = `<table class="collection-table">
		<thead>
		  <tr>
			<th>稱號</th>
			<th>詳情</th>
		  </tr>
		</thead>
		<tbody>`;
	  sorted.forEach(ach => {
		html += `<tr class="${ach.rarity}">
		  <td>${ach.title}</td>
		  <td>${ach.details}</td>
		</tr>`;
	  });
	  html += '</tbody></table>';
	  container.innerHTML = html;
	  showModal('titlesModal');
	}

	// 模擬定義 getCollectionCompletion()，請根據實際數據修改
	function getCollectionCompletion() {
	  // 例如使用 collectedItems 和 ALL_COMBINATIONS
	  const obtained = Object.keys(collectedItems || {}).length;
	  const total = ALL_COMBINATIONS || 1;
	  return (obtained / total) * 100;
	}

	function removeDuplicateAchievements() {
	  // 使用一個 Map 以 "category_title" 為鍵，保證每個稱號只保留一筆
	  const dedupMap = new Map();
	  // 遍歷 unlockedAchievements，若重複則只保留第一筆
	  unlockedAchievements = unlockedAchievements.filter(achievement => {
		// 定義鍵值（你也可以使用 category+level 作為區分依據）
		const key = achievement.category + "_" + achievement.title;
		if (dedupMap.has(key)) {
		  // 已存在則跳過
		  return false;
		} else {
		  dedupMap.set(key, true);
		  return true;
		}
	  });
	  // 同步存入 gameState 中（如果你需要統一存放）
	  gameState.unlockedAchievements = unlockedAchievements.slice();
	  // 更新成就界面
	  updateAchievementsUI();
	}
	 
	
  
    /***** 建築管理系統 *****/
	function initBuildingGrid() {
	  const grid = document.getElementById('buildingGrid');
	  grid.innerHTML = '';
	  gameState.buildings.forEach((building, index) => {
		const tile = document.createElement('div');
		let tileClass = "tile";
		if (building && building.upgradable) {
		  tileClass += " upgradable";
		}
		tile.className = tileClass;
		tile.setAttribute('data-index', index);
		tile.onclick = () => {
		  handleBuildingClick(index);
		};

		if (building) {
		  const config = BUILDINGS[building.type];
		  // 判斷是否可以升級：如果建築標記可升級且資源足夠進行下一級升級
		  let canUpgrade = false;
		  if (building.upgradable) {
			const upgradeInfo = config.getUpgradeInfo(building.level + 1);
			if (upgradeInfo && canAfford(upgradeInfo.cost)) {
			  canUpgrade = true;
			}
		  }
		  
		  // 組合建築資訊的 HTML，如果可升級則增加一個箭頭元素，並且如果可升級則附加 "upgrade-available" class
		  tile.innerHTML = `
			<div class="building-icon">${getBuildingIcon(building.type)}</div>
			<div class="building-info">
			  <div>${config.name}</div>
			  <div class="building-level">Lv.${building.level}</div>
			</div>
			${building.upgradable 
				? `<div class="upgrade-indicator ${canUpgrade ? "upgrade-available" : ""}">↑</div>` 
				: '' }
		  `;
		  // 如果可以升級，將整個 tile 邊框設為綠色
		  if (canUpgrade) {
			tile.style.borderColor = "green";
		  }
		} else {
		  // 針對空地
		  tile.innerHTML = `
			<div class="empty-plot">🟦</div>
			<div class="plot-label">空地</div>
		  `;
		}
		
		grid.appendChild(tile);
	  });
	}

  
    function handleBuildingClick(index) {
	  const building = gameState.buildings[index];
	  if (!building) {
		return showBuildMenu(index);
	  }
	  // 直接使用升級彈窗顯示資訊和操作（拆除按鈕也整合進來）
	  showUpgradeMenu(index);
	}

	let currentBuildIndex = null;
	function showBuildMenu(index) {
	  currentBuildIndex = index;
	  updateBuildMenuContent(index);
	  showModal("buildModal");

	  const modalContent = document.querySelector('#buildModal .modal-content');
	  const baseTitleElem = document.querySelector('.building-system h2.section-title');
	  const centerTile = document.querySelector('[data-index="4"]'); // 中心基地

	  if (modalContent && baseTitleElem && centerTile) {
		const titleRect = baseTitleElem.getBoundingClientRect();
		const centerRect = centerTile.getBoundingClientRect();
		
		// 如果是桌面：
		if (window.innerWidth >= 768) {
		  modalContent.style.position = "fixed";
		  // 將 top 設在基地建設標題的下邊緣：
		  modalContent.style.top = titleRect.bottom + "px";
		  // 左側根據中心基地卡片水平居中
		  const modalWidth = modalContent.offsetWidth;
		  modalContent.style.left = (centerRect.left + centerRect.width / 2 - modalWidth / 2) + "px";
		} else {
		  // 如果是移動端，則用較合理的設置，這裡我們讓彈窗寬度由上面的 CSS 控制，
		  // 只需要調整 top 為基地建設標題下方一定距離（比如20px）
		  modalContent.style.position = "absolute";
		  modalContent.style.top = (titleRect.bottom + 20) + "px";
		  modalContent.style.left = "50%";
		  modalContent.style.transform = "translateX(-50%)";
		}
	  }
	}


	function updateBuildMenuContent(index) {
	  const available = Object.entries(BUILDINGS)
		.filter(([key, cfg]) => cfg.baseCost && key.toLowerCase() !== "center");

	  let modalContent = available.map(([key, cfg]) => {
		let bonusInfo = "";
		if (typeof cfg.getUpgradeInfo === "function") {
		  const info = cfg.getUpgradeInfo(1);
		  if (info && info.effect) {
			bonusInfo = Object.entries(info.effect)
			  .map(([attr, value]) => {
				const cnAttr = effectMapping[attr] || attr;  // 利用 effectMapping 將英文鍵映射為中文
				return `${cnAttr}: +${parseFloat(value).toFixed(2)}`;
			  })
			  .join("<br>");
		  }
		}
		let costHtml = Object.entries(cfg.baseCost)
		  .map(([res, val]) => `<span class="cost-item" style="margin-right: 8px;">${costMapping[res] || res}: ${parseInt(val)}</span>`)
		  .join(' ');
		let unmet = "";
		if (!canAfford(cfg.baseCost)) {
		  unmet = " （❌）";
		}
		return `
		  <div class="build-box" onclick="startBuilding('${key}', ${index})">
			<div class="build-top-container">
			  <div class="build-row">
				<div class="build-left">
				  <span class="build-icon">${getBuildingIcon(key)}</span>
				  <span class="build-name" style="margin-left:5px; font-weight:bold;">${cfg.name}</span>
				</div>
				<div class="build-right">
				  ${bonusInfo}
				</div>
			  </div>
			</div>
			<div class="build-resources">
			  ${costHtml}${unmet}
			</div>
		  </div>
		`;
	  }).join('');
	  
	  document.getElementById('buildOptions').innerHTML = modalContent;
	}


	function closeBuildModal() {
	  closeNestedModal("buildModal");
	  // 清除更新計時器
	  if(buildMenuUpdateTimer) {
		clearInterval(buildMenuUpdateTimer);
		buildMenuUpdateTimer = null;
	  }
	}


	// 每 5 秒檢查一次，如果建造或升級彈窗打開，則刷新其內容
	setInterval(function() {
	  // 檢查建造彈窗（buildModal）的狀態
	  var buildModal = document.getElementById("buildModal");
	  if (buildModal && buildModal.style.display !== "none" && typeof currentBuildIndex !== "undefined") {
		updateBuildMenuContent(currentBuildIndex);
	  }
	  
	  // 檢查升級彈窗（upgradeModal）的狀態
	  var upgradeModal = document.getElementById("upgradeModal");
	  if (upgradeModal && upgradeModal.style.display !== "none" && typeof currentUpgradeIndex !== "undefined") {
		updateUpgradeMenuContent(currentUpgradeIndex);
	  }
	  
	  const prodModal = document.getElementById("productionCollectionModal");
	  if (prodModal && window.getComputedStyle(prodModal).display !== "none") {
		showProductionCollection();
	  }

	  const favModal = document.getElementById("favoritesModal");
	  if (favModal && window.getComputedStyle(favModal).display !== "none") {
		showCollection();
	  }
	}, 5000);

	




	function getBuildItems() {
	  // 從 BUILDINGS 過濾出具建造成本且非中心基地的項目
	  return Object.entries(BUILDINGS)
		.filter(([key, cfg]) => cfg.baseCost && key.toLowerCase() !== "center");
	}
	function calculateTotalPages() {
	  const itemsPerPage = 2;  // 每頁2個項目（根據你的 updateBuildMenuContent() 設定）
	  const totalItems = getBuildItems().length;
	  return Math.ceil(totalItems / itemsPerPage);
	}
	


	// 每 5 秒檢查一次，如果建造或升級彈窗打開，則刷新其內容
	setInterval(function() {
	  updateBuildMenuContent(currentBuildIndex);
	  updateBuildHeaderNumbers();
	  // 檢查建造彈窗（buildModal）的狀態
	  var buildModal = document.getElementById("buildModal");
	  if (buildModal && buildModal.style.display !== "none" && typeof currentBuildIndex !== "undefined") {
		updateBuildMenuContent(currentBuildIndex);
	  }
	  
	  // 檢查升級彈窗（upgradeModal）的狀態
	  var upgradeModal = document.getElementById("upgradeModal");
	  if (upgradeModal && upgradeModal.style.display !== "none" && typeof currentUpgradeIndex !== "undefined") {
		updateUpgradeMenuContent(currentUpgradeIndex);
	  }
	  
	  const prodModal = document.getElementById("productionCollectionModal");
	  if (prodModal && window.getComputedStyle(prodModal).display !== "none") {
		showProductionCollection();
	  }

	  const favModal = document.getElementById("favoritesModal");
	  if (favModal && window.getComputedStyle(favModal).display !== "none") {
		showCollection();
	  }
	}, 5000);
	

	function updateBuildHeaderNumbers() {
	  document.getElementById("foodCountDisplay").textContent = formatNumber(gameState.resources.food);
	  document.getElementById("materialsCountDisplay").textContent = formatNumber(gameState.resources.materials);
	  document.getElementById("weaponsCountDisplay").textContent = formatNumber(gameState.resources.weapons);
	  document.getElementById("techCountDisplay").textContent = formatNumber(gameState.resources.tech);
	}




  
    function updateEfficiencies() {
	  // 如果 gameState.efficiency 尚未定義，則初始化其主要鍵
	  if (!gameState.efficiency) {
		gameState.efficiency = {
		  exploration: 1,
		  food: 1,
		  materials: 1,
		  weapons: 1,
		  tech: 1
		};
	  } else {
		// 重置所有預定義的效率鍵
		gameState.efficiency.exploration = 1;
		gameState.efficiency.food = 1;
		gameState.efficiency.materials = 1;
		gameState.efficiency.weapons = 1;
		gameState.efficiency.tech = 1;
	  }

	  // 取得中心基地（center）的等級，用於作為其它建築等級的上限參考
	  const centerBuilding = gameState.buildings.find(b => b && b.type === "center");
	  const centerLevel = centerBuilding ? centerBuilding.level : 1;

	  // 初始化累計變數
	  let totalExplorationBoost = 0; // 探索提升，只由中心基地提供
	  let totalProductionBonus = 0;  // 生產加成，全局應用於 food、materials、weapons、tech
	  let totalResearchBoost = 0;    // 科研提升
	  let totalZombieEfficiency = 0; // 僵尸專屬效果
	  let totalZombieBoost = 0;      // 探索加成（zombieBoost），由僵尸指揮中心提供

	  // 遍歷所有建築，累計效果
	  gameState.buildings.forEach(b => {
		if (!b) return; // 跳過空地

		const upgradeInfo = (typeof BUILDINGS[b.type].getUpgradeInfo === "function")
		  ? BUILDINGS[b.type].getUpgradeInfo(b.level)
		  : null;
		const effects = upgradeInfo ? upgradeInfo.effect : {};

		// 將非特殊鍵（非 explorationBoost, researchBoost, zombieEfficiency, productionBonus, zombieBoost）
		// 的效果直接累加到 gameState.efficiency（例如某些建築可能直接給 food、materials 等加成）
		Object.entries(effects).forEach(([key, value]) => {
		  if (['explorationBoost', 'researchBoost', 'zombieEfficiency', 'productionBonus', 'zombieBoost'].includes(key)) {
			return;
		  }
		  if (gameState.efficiency.hasOwnProperty(key)) {
			gameState.efficiency[key] += value;
		  } else {
			gameState.efficiency[key] = 1 + value;
		  }
		});

		// 累計特殊效果：
		if (b.type === "center") {
		  // 中心基地提供探索提升（explorationBoost）等
		  totalExplorationBoost += effects.explorationBoost || 0;
		  totalResearchBoost += effects.researchBoost || 0;
		  totalZombieEfficiency += effects.zombieEfficiency || 0;
		  totalProductionBonus += effects.productionBonus || 0;
		} else {
		  // 其他建築如果有生產加成，也累計
		  if (effects.productionBonus) {
			totalProductionBonus += effects.productionBonus;
		  }
		}
	  });

	  // 將最終探索效率只使用中心基地提供的探索提升來計算
	  gameState.efficiency.exploration = 1 + totalExplorationBoost;
	  // 注意：這裡不把 zombieBoost 加入 exploration 效率，以符合你定義的區分

	  // 將生產加成全局應用到所有主要資源上
	  ['food', 'materials', 'weapons', 'tech'].forEach(res => {
		gameState.efficiency[res] = (gameState.efficiency[res] || 1) + totalProductionBonus;
	  });

	  // 更新其它專用變數，方便後續使用或顯示
	  gameState.explorationEfficiency = gameState.efficiency.exploration;
	  gameState.researchEfficiency = 1 + totalResearchBoost;
	  gameState.zombieEfficiency = 1 + totalZombieEfficiency;
	  // 如有需要，獨立存儲探索加成（zombieBoost）以供其它用途，但不納入探索效率：
	  gameState.zombieBoost = 1 + totalZombieBoost;
	  gameState.productionEfficiency = 1 + totalProductionBonus;

	  // 限制非中心基地的建築等級不得超過中心基地等級
	  gameState.buildings.forEach(b => {
		if (b && b.type !== "center" && b.level > centerLevel) {
		  b.level = centerLevel;
		}
	  });
	}



  
    function getBuildingIcon(type) {
	  const icons = {
		center: "🏰",
		barracks: "🏫",
		greenhouse: "🌿",
		armory: "🔧",
		laboratory: "🔬",
		resourceamplifier: "📈",       // 替換為更常見的符號
		zombiecommandcenter: "🧟",
		rarevault: "💎",
		guardfacility: "⚔️", // 改為交叉劍
		safetycenter: "🛡️",
		recyclingfactory: "♻️",
		armoredgarage: "🚜",
	  };
	  return icons[type.toLowerCase()] || "🟦";
	}


	
	// 更新所有建築的升級狀態，根據主基地當前等級來決定
	function updateBuildingsAfterMainBaseUpgrade() {
	  // 找出主基地並獲取當前等級（不區分大小寫）
	  const centerBuilding = gameState.buildings.find(b => b && b.type.toLowerCase() === "center");
	  const centerLevel = centerBuilding ? centerBuilding.level : 1;

	  // 遍歷所有建築，非主基地的 upgradable 狀態由自身等級與主基地等級決定
	  gameState.buildings.forEach(b => {
		if (b && b.type.toLowerCase() !== "center") {
		  b.upgradable = (b.level < centerLevel);
		};
		if (b && b.type.toLowerCase() === "armoredgarage") {
			const garageInfo = BUILDINGS.armoredGarage.getUpgradeInfo(b.level);
			gameState.resources.food = Math.max(0, gameState.resources.food - garageInfo.effect.foodConsumption);
		  }
	  });
	}
	let isBTRActive = false;
	let t80IdleInterval = null;
	let t80CannonOnCooldown = false;


	function startT80IdleAnimation(sprite) {
	  // 確保idle定時器不存在
	  if (t80IdleInterval) clearInterval(t80IdleInterval);
	  t80IdleToggle = false;
	  // 初始設為第1 幀
	  sprite.style.backgroundPosition = "0px 0";
	  t80IdleInterval = setInterval(() => {
		// 使用 toggle 變數進行交替
		t80IdleToggle = !t80IdleToggle;
		// 第1 幀： "0px 0"；第4 幀： -1440px 0 （因為 3*480 = 1440）
		sprite.style.backgroundPosition = t80IdleToggle ? "-1440px 0" : "0px 0";
	  }, 250);
	}

	// 主入口函數：生成動畫
	function triggerBTRAnimation() {
	  const container = document.getElementById("explorationAnim");
	  if (!container) {
		return;
	  }
	  const containerWidth = container.clientWidth;
	  const offset = 50;
	  const rootStyles = getComputedStyle(document.documentElement);

	  // 40%機率使用 T‑80，否則BTR
	  const useT80 = (Math.random() < 0.4);

	  let frameWidth;
	  if (useT80) {
		// T‑80的單幀寬度固定為480px
		frameWidth = 480;
	  } else {
		frameWidth = parseFloat(rootStyles.getPropertyValue('--btr-frame-width')) || 240;
	  }

	  // 計算水平位置：起始位置、停止位置，依據 frameWidth 計算
	  const centerStart = containerWidth + offset + 0.5 * frameWidth;
	  const centerStop = 0.5 * containerWidth;
	  const startLeft = centerStart - 0.5 * frameWidth;
	  const stopLeft  = centerStop - 0.5 * frameWidth;

	  // 生成水平移動 keyframes（控制 wrapper）
	  const keyframesText = `
		@keyframes btrMoveDynamic {
		  0%   { left: ${startLeft}px; }
		  20%  { left: ${stopLeft}px; }
		  60%  { left: ${stopLeft}px; }
		  100% { left: ${startLeft}px; }
		}
	  `;
	  let styleElem = document.getElementById("btrKeyframes");
	  if (!styleElem) {
		styleElem = document.createElement("style");
		styleElem.id = "btrKeyframes";
		document.head.appendChild(styleElem);
	  }
	  styleElem.textContent = keyframesText;
	  
	  const wrapper = document.createElement("div");
	  wrapper.className = "btr-wrapper";
	  wrapper.style.position = "absolute";
	  wrapper.style.left = startLeft + "px";
	  wrapper.style.animation = "btrMoveDynamic 10s ease-in-out forwards";

	  let spriteElem;
	  if (useT80) {
		// T‑80 分支：建立裁切容器
		const frameContainer = document.createElement("div");
		frameContainer.className = "frameContainer";
		frameContainer.style.width = frameWidth + "px";
		frameContainer.style.height = rootStyles.getPropertyValue('--btr-frame-height') || "120px";
		frameContainer.style.overflow = "hidden";

		spriteElem = document.createElement("div");
		spriteElem.className = "t80-animation";
		// 初始 idle：設置 backgroundPosition 為第1 幀
		spriteElem.style.backgroundPosition = "0px 0";

		frameContainer.appendChild(spriteElem);
		wrapper.appendChild(frameContainer);
	  } else {
		// BTR 分支：直接使用原來的 btr-animation
		spriteElem = document.createElement("div");
		spriteElem.className = "btr-animation";
		wrapper.appendChild(spriteElem);
	  }

	  container.appendChild(wrapper);

	  gameState.btrTriggerCount = (gameState.btrTriggerCount || 0) + 1;
	  if (useT80) {
		addEventLog('[T-80]入場，獲得僵尸事件獎勵提升！', 'btr-active', 'exploration');
	  } else {
		addEventLog('[BTR-80]入場，獲得僵尸事件獎勵提升！', 'btr-active', 'exploration');
	  }
	  isBTRActive = true;
	  setTimeout(() => { isBTRActive = false; }, 10000);
	  setTimeout(() => {
		if (container.contains(wrapper)) {
		  container.removeChild(wrapper);
		}
		// 如果 T‑80，清除 idle 定時器
		if (useT80 && t80IdleInterval) {
		  clearInterval(t80IdleInterval);
		  t80IdleInterval = null;
		}
	  }, 10000);

	  // 如果是 T‑80 分支，啟動 idle 動作
	  if (useT80) {
		startT80IdleAnimation(spriteElem);
		setTimeout(() => {
		  triggerT80Cannon();
		}, 1000);
	  }
	}

function triggerT80Cannon() {
	  if (t80CannonOnCooldown) return;
	  const sprite = document.querySelector(".t80-animation");
	  if (!sprite) {
		return;
	  }
	  t80CannonOnCooldown = true;
	  
	  // 停止 idle 定時器
	  if (t80IdleInterval) {
		clearInterval(t80IdleInterval);
		t80IdleInterval = null;
	  }
	  // 使用 setTimeout 模擬完整 4 幀播放：每帧 250ms（總耗時約1秒）
	  sprite.style.backgroundPosition = "0px 0"; // frame1
	  setTimeout(() => { sprite.style.backgroundPosition = "-480px 0"; }, 250); // frame2
	  setTimeout(() => { sprite.style.backgroundPosition = "-960px 0"; }, 500); // frame3
	  setTimeout(() => { sprite.style.backgroundPosition = "-1440px 0"; }, 750); // frame4
	  
	  // 1秒後恢復 idle 模式
	  setTimeout(() => {
		sprite.style.backgroundPosition = "0px 0"; // 復原到 frame1
		// 重新啟動 idle 動畫
		startT80IdleAnimation(sprite);
	  }, 1000);
	  
	  // 冷卻後允許再次開炮
	  setTimeout(() => {
		t80CannonOnCooldown = false;
		if (isBTRActive) {
			triggerT80Cannon();
		  }
	  }, 4250);
	}




 
	function checkBTREvent() {
	  const garages = gameState.buildings.filter(b => b && b.type.toLowerCase() === "armoredgarage");
	  if (garages.length > 0) {
		const garageInfo = BUILDINGS.armoredGarage.getUpgradeInfo(garages[0].level);
		if (Math.random() < garageInfo.effect.btrChance) {
		  triggerBTRAnimation();
		}
	   }
	 }
	setInterval(checkBTREvent, 30000); // 每 30 秒檢查一次

	
	function confirmUpgrade() {
	  if (typeof currentUpgradeIndex === "undefined") return;
	  
	  const index = currentUpgradeIndex;
	  const building = gameState.buildings[index];
	  const config = BUILDINGS[building.type];
	  const nextUpgrade = (typeof config.getUpgradeInfo === "function")
							? config.getUpgradeInfo(building.level + 1)
							: null;
							
	  if (!nextUpgrade || !nextUpgrade.cost) {
		// 無法升級（可能已達頂級）
		showTempMessage("升級失敗");
		return;
	  }
	  
	  if (!canAfford(nextUpgrade.cost)) {
		showTempMessage("升級失敗");
		return;
	  }
	  
	  payCost(nextUpgrade.cost);
	  building.level++;
	  building.upgradable = checkUpgradable(building.type, building.level);
	  if (building.type.toLowerCase() === "center") {
		updateBuildingsAfterMainBaseUpgrade();
	  }
	  updateEfficiencies();
	  updateAllDisplays();
	  
	  // **更新升級彈窗內容**
      showUpgradeMenu(index);
	  
	  showTempMessage("升級成功");
	  // 注意：此處不自動關閉升級彈窗，便於連續升級
	}


	// 新增：結果提示彈窗函數
	function showResultModal(message) {
	  document.getElementById("resultMessage").textContent = message;
	  showNestedModal("resultModal");
	}
	

	function closeResultModal() {
	  closeNestedModal("resultModal");
	}

	// 原有的升級菜單函數（修改後使用動態升級資訊）
	function updateUpgradeMenuContent(index) {
	  const building = gameState.buildings[index];
	  if (!building) return;
	  const config = BUILDINGS[building.type];
	  
	  let currentInfo = "";
	  if (typeof config.getUpgradeInfo === "function") {
	    const currentUpgrade = config.getUpgradeInfo(building.level);
	    if (currentUpgrade && currentUpgrade.effect) {
		  currentInfo = Object.entries(currentUpgrade.effect)
		    .map(([attr, value]) => {
		      const cnAttr = effectMapping[attr] || attr;  // 若找不到映射則直接用 attr
		  	  return `${cnAttr}: +${parseFloat(value).toFixed(2)}`;
		    })
		    .join("，");
	    }
	  }
	  
	  let nextInfo = "";
	  const nextUpgrade = (typeof config.getUpgradeInfo === "function")
						  ? config.getUpgradeInfo(building.level + 1)
						  : null;
	  if (nextUpgrade && nextUpgrade.cost) {
		nextInfo = " ";
		for (let [res, val] of Object.entries(nextUpgrade.cost)) {
		  const cnRes = costMapping[res] || res;
		  nextInfo += ` ${cnRes}: ${parseInt(val)}`;
		}
		if (!canAfford(nextUpgrade.cost)) {
		  nextInfo += " （❌）";
		}
	  } else {
		nextInfo = "已達最高級";
	  }
	  
	  const upperContent = `當前加成: ${currentInfo}\n升級所需: ${nextInfo}`;
	  document.getElementById("upgradeTitle").textContent = config.name;
	  document.getElementById("upgradeInfo").textContent = upperContent;
	  
	  document.getElementById("confirmUpgradeBtn").style.display = "inline-block";
	  if (building.type.toLowerCase() === "center") {
		document.getElementById("demolishBtn").style.display = "none";
	  } else {
		document.getElementById("demolishBtn").style.display = "inline-block";
	  }
	}



	function showUpgradeMenu(index) {
	  currentUpgradeIndex = index;
	  const building = gameState.buildings[index];
	  if (!building) return;
	  // 初次更新升級彈窗內容
	  updateUpgradeMenuContent(index);
	  
	  // 顯示升級彈窗
	  showNestedModal("upgradeModal");
	  // 此處不再啟動獨立定時器
	  const modalContent = document.querySelector('#upgradeModal .modal-content');
	  const baseTitleElem = document.querySelector('.building-system h2.section-title');
	  const centerTile = document.querySelector('[data-index="4"]'); // 假設中心基地所在格子索引為 4
	  
	  if (modalContent && baseTitleElem && centerTile) {
		// 取得基地建設標題區域的矩形信息
		const titleRect = baseTitleElem.getBoundingClientRect();
		// 取得中心基地 tile 的矩形信息
		const centerRect = centerTile.getBoundingClientRect();
		
		// 固定定位（必須設定為 fixed 或 absolute）
		modalContent.style.position = "fixed";
		// 將升級彈窗頂部設置到基地建設標題的上邊緣（與建造彈窗保持一致）
		modalContent.style.top = titleRect.top + "px";
		
		// 計算 modal-content 寬度並使其水平居中於中心基地
		const modalWidth = modalContent.offsetWidth;
		modalContent.style.left = (centerRect.left + centerRect.width / 2) + "px";
	  }
	}



	function closeUpgradeModal() {
	  closeNestedModal("upgradeModal");
	}

	function startBuilding(type, index) {
	  const config = BUILDINGS[type];
	  if (!canAfford(config.baseCost)) {
		addEventLog(`❌ 資源不足，無法建造 ${config.name}`, 'epic');
		showTempMessage(`建造失敗 ${config.name}`);
		return;
	  }
	  payCost(config.baseCost);
	  gameState.buildings[index] = {
		type,
		level: 1,
		upgradable: checkUpgradable(type, 1)
	  };
	  updateEfficiencies();
	  addEventLog(`🏗️ 成功建造 ${config.name}`, 'uncommon');
	  closeModal("buildModal");  // 改用 closeModal 來關閉建造彈窗
	  updateAllDisplays();
	  showTempMessage(`成功建造 ${config.name}`);
	}


	// 建築互動（包括拆除、查看資訊等）與拆除建築的邏輯

	function showBuildingInteractionMenu(index) {
	  const building = gameState.buildings[index];
	  if (!building) return;
	  const config = BUILDINGS[building.type];

	  // 生成顯示基本資訊的字串
	  const infoStr = `<div class="building-info-popup">
							<p><strong>${config.name}</strong></p>
							<p>目前等級：Lv.${building.level}</p>
						</div>`;

	  // 如果建築可升級，則添加升級按鈕
	  let buttonContent = "";
	  if (building.upgradable) {
		buttonContent += `<button class="modal-btn" onclick="showUpgradeMenu(${index})">升級建築</button>`;
	  }
	  // 僅當該建築不是中心基地時才顯示拆除按鈕
	  if (building.type.toLowerCase() !== "center") {
		buttonContent += `<button class="modal-btn danger" onclick="confirmBuildingRemoval(${index})">拆除建築</button>`;
	  }

	  // 拼接最終的互動內容
	  const interactionContent = infoStr + buttonContent;

	  document.getElementById("interactionContent").innerHTML = interactionContent;
	  document.getElementById("interactionTitle").textContent = config.name;
	  showModal("interactionModal");
	}


	function confirmBuildingRemoval(index) {
	  const building = gameState.buildings[index];
	  if (!building) return;
	  closeNestedModal("upgradeModal");
	  let confirmRemoval = confirm(`確定要拆除 ${BUILDINGS[building.type].name}？此操作不可逆！`);
	  if (!confirmRemoval) return;
	  
	  gameState.buildings[index] = null;
	  addEventLog(`🏗️ ${BUILDINGS[building.type].name} 已被拆除`, "warning");
	  updateEfficiencies();
	  updateAllDisplays();
	  showResultModal(`已拆除 ${BUILDINGS[building.type].name}`);
	}

	function showBuildingInfo(index) {
	  const building = gameState.buildings[index];
	  if (building) {
		const config = BUILDINGS[building.type];
		addEventLog(`${config.name} 等級 ${building.level}`, "common");
		showResultModal(`${config.name} 的目前等級：${building.level}`);
	  }
	}


  
    function toggleResource(resource) {
      const detailsElem = document.getElementById(resource + "Details");
      if (detailsElem.style.maxHeight && detailsElem.style.maxHeight !== "0px") {
        detailsElem.style.maxHeight = "0";
      } else {
        detailsElem.style.maxHeight = "100px";
      }
    }
  
    	/***** (3) 調整各部門僵尸分配的加減步幅為當前數量的 5%（下限 1） *****/
	function adjustZombies(dept, amount) {
	  let current = gameState.allocations[dept] || 0;
	  let step = 0;

	  if (amount > 0) {
		// 若當前部門為 0，則加 1；否則以當前部門僵尸數的 5%（向上取整，最小 1）
		step = current > 0 ? Math.max(Math.ceil(current * 0.05), 1) : 1;
	  } else {
		// 減少分配時採用相同方式（不得低於 0）
		step = current > 0 ? -Math.max(Math.ceil(current * 0.05), 1) : 0;
	  }

	  if (amount > 0) {
		// 計算其它部門已分配僵尸數
		const totalAllocatedOther = Object.keys(gameState.allocations).reduce((sum, key) => {
		  return key === dept ? sum : sum + gameState.allocations[key];
		}, 0);
		// 計算當前部門已分配後，總共分配出去的數字：current + totalAllocatedOther
		// 剩餘僵尸數應為總僵尸數減去已分配的總數
		const remainingForDept = gameState.totalZombies - (totalAllocatedOther + current);

		// 如果剩餘不足本部門按照 5% 計算應增加的數量，
		// 則直接將全部剩餘數分配進該部門
		if (remainingForDept < step && remainingForDept > 0) {
		  gameState.allocations[dept] = current + remainingForDept;
		} else {
		  // 檢查增加後是否超出總僵尸數
		  if (totalAllocatedOther + (current + step) > gameState.totalZombies) {
			addEventLog("沒有足夠的僵尸分配", "warning");
			return;
		  }
		  gameState.allocations[dept] = current + step;
		}
	  } else {
		// 減少分配情況直接更新
		gameState.allocations[dept] = Math.max(current + step, 0);
	  }

	  updateAllDisplays();
	}





  
  // 當觸摸開始時，如果目標位於我們關注的區域內（.modal-content 或 .log），則保存該容器與初始位置。
	const scrollManager = (() => {
	  let startX = 0, startY = 0;
	  let currentContainer = null;
	  // 用來標記這次觸摸操作是否是垂直手勢（只在第一次 touchmove 時確定）
	  let isVerticalGesture = null; 
	  // 垂直角度閾值（單位：度）
	  const verticalThreshold = 60; 

	  // 檢查元素是否具有垂直滾動功能
	  function isScrollable(el) {
		return el && el.scrollHeight > el.clientHeight;
	  }
	  
	  function handleTouchStart(e) {
		if (e.touches.length > 1) {
		  currentContainer = null;
		  isVerticalGesture = null;
		  return;
		}
		
		// 優先判斷是否點擊到 buildModal 內部的滾動區（.build-options）
		let buildOptions = e.target.closest('#buildModal .build-options');
		if (buildOptions && isScrollable(buildOptions)) {
		  currentContainer = buildOptions;
		} else if (e.target.closest('#explorationLog, #productionLog')) {
		  let logContainer = e.target.closest('#explorationLog, #productionLog');
		  currentContainer = isScrollable(logContainer) ? logContainer : null;
		} else if (e.target.closest('#favoritesModal .modal-content')) {
		  currentContainer = document.querySelector('#favoritesModal .modal-content');
		} else if (e.target.closest('#productionCollectionModal.modal-content')) {
		  currentContainer = document.querySelector('#productionCollectionModal .modal-content');
		} else {
		  const container = e.target.closest('.modal-content, .log');
		  currentContainer = container && isScrollable(container) ? container : null;
		}
		
		if (currentContainer) {
		  startX = e.touches[0].clientX;
		  startY = e.touches[0].clientY;
		  isVerticalGesture = null;
		}
	  }

	  function handleTouchMove(e) {
		// 如果多點觸控或未選定容器則直接返回
		if (e.touches.length > 1 || !currentContainer) return;
		
		const currentX = e.touches[0].clientX;
		const currentY = e.touches[0].clientY;
		const deltaX = currentX - startX;
		const deltaY = currentY - startY;
		
		if (isVerticalGesture === null) {
		  const angle = Math.atan2(Math.abs(deltaX), Math.abs(deltaY)) * (180 / Math.PI);
		  isVerticalGesture = angle < verticalThreshold;
		}
		
		if (isVerticalGesture) {
		  e.preventDefault();
		  e.stopPropagation();
		  currentContainer.scrollTop -= deltaY;
		}
		
		startX = currentX;
		startY = currentY;
	  }

	  function handleTouchEnd(e) {
		currentContainer = null;
		isVerticalGesture = null;
	  }

	  return {
		init() {
		  document.addEventListener('touchstart', handleTouchStart, { passive: false });
		  document.addEventListener('touchmove', handleTouchMove, { passive: false });
		  document.addEventListener('touchend', handleTouchEnd);
		}
	  };
	})();
	scrollManager.init();

	document.addEventListener("touchmove", function(e) {
	  const openModal = document.querySelector('.modal-overlay[style*="display: flex"]');
	  if (openModal && !e.target.closest('.modal-content')) {
		// 如果觸控來源並非 modal 內容內，也不是某個允許滾動的特定區域（例如，#buildModal .build-options 可滾動）
		if (!e.target.closest('#buildModal .build-options')) {
		  // 允許手勢（例如縮放）照常執行
		  return;
		}
	  }
	}, { passive: false });

	function globalTouchMoveHandler(e) {
	  // 如果彈窗遮罩已經打開，並且觸控並非發生在允許滾動的區域內
	  if (document.body.classList.contains('modal-open') &&
		  !e.target.closest('#buildModal .build-options')) {
		e.preventDefault();
	  }
	}
	// 綁定事件
	document.addEventListener("touchmove", globalTouchMoveHandler, { passive: false });



	// 弹窗控制函数
	function showNestedModal(modalId) {
	  var modal = document.getElementById(modalId);
	  if (!modal) return;
	  modal.style.display = "flex";
	  modal.offsetHeight;
	  if (modalId === "buildModal") {
		let logIds = ["explorationLog", "productionLog"];
		logIds.forEach(id => {
		  let logElem = document.getElementById(id);
		  if (logElem) {
			logElem.scrollTop = logElem.scrollHeight;
		  }
		});
	  }
	}
	function closeNestedModal(modalId) {
	  var modal = document.getElementById(modalId);
	  if (modal) {
		modal.style.display = "none";
		// 恢復 overflow
		document.documentElement.style.overflow = '';
		document.body.style.overflow = '';
		}
	}


	function updateModalPosition() {
	  // 只針對加上自定義定位標記的彈窗進行調整
	  const modals = document.querySelectorAll('.modal-overlay .modal-content[data-custom-pos="true"]');
	  if (!modals.length) return;

	  const baseTitleElem = document.querySelector('.building-system h2.section-title');
	  const centerTile = document.querySelector('[data-index="4"]');
	  if (baseTitleElem && centerTile) {
		const titleRect = baseTitleElem.getBoundingClientRect();
		const centerRect = centerTile.getBoundingClientRect();
		modals.forEach(content => {
		  content.style.position = "fixed";
		  content.style.top = `${titleRect.top}px`;
		  content.style.left = `${centerRect.left + centerRect.width / 2}px`;
		  content.style.transform = "translateX(-50%)";
		});
	  }
	}


	function closeModal(modalId) {
	  var modal = document.getElementById(modalId);
	  if (!modal) return;
	  modal.style.display = 'none';
	  document.documentElement.style.overflow = '';
	  document.body.style.overflow = '';
	}

	// 视觉视口监听器
	let currentScale = 1;
	const viewportHandler = () => {
	  currentScale = window.visualViewport.scale;	  
	};

	// 弹窗控制增强
	const modalController = {
	  init() { },
	  
	  show(modalId) {
		const modal = document.getElementById(modalId);
		currentScale = window.visualViewport.scale;
		
		// 初始化弹窗位置
		modal.style.display = 'flex';
		modal.querySelector('.modal-content').style.transform = `
		  translateX(-50%) 
		  scale(${1/currentScale})
		`;
		
		// 添加双指手势监听
		modal.addEventListener('gesturestart', e => e.preventDefault());
		modal.addEventListener('gesturechange', this.handleZoom);
	  },

	  handleZoom(e) {
		const modalContent = e.target.closest('.modal-content');
		if(!modalContent) return;
		
		// 限制缩放范围
		const newScale = Math.min(Math.max(e.scale, 0.8), 2);
		modalContent.style.setProperty('--zoom-factor', newScale);
		
		// 阻止页面级缩放
		e.preventDefault();
	  },
	  
	  close(modalId) {
		window.visualViewport.removeEventListener('scroll', viewportHandler);
		window.visualViewport.removeEventListener('resize', viewportHandler);
		document.getElementById(modalId).style.display = 'none';
	  }
	};

	// 初始化
	modalController.init();

	  

    /***** 輔助函數 結束 *****/
  
    // 遊戲初始化與核心循環
    function initGame() {
      updateAllDisplays();
      initBuildingGrid();
    
    }
	
	
    function loadSave() {
      // 如有需要，可在此讀取存檔，本例中直接設定初始部門分配
      gameState.allocations.exploration = 4;
      gameState.allocations.farming = 4;
      gameState.allocations.recycling = 1;
      gameState.allocations.research = 1;
    }
  
    /*******************
	 * 存档相关代码
	 *******************/

	// 保存游戏进度的函数
	function saveGameState() {
	  try {
		// 计算已经流逝的时间
		const elapsedTime = Date.now() - window.startTime;
		const saveData = {
		  gameState: gameState,
		  collectedItems: collectedItems,
		  productionCollection: productionCollection,
		  unlockedAchievements: unlockedAchievements, // 保存成就記錄
		  elapsedTime: elapsedTime
		};
		localStorage.setItem("gameSave", JSON.stringify(saveData));
	  } catch (err) {}
	}

	// 加载存档的函数
	function loadGameState() {
	  const saved = localStorage.getItem("gameSave");
	  if (saved) {
		try {
		  const saveData = JSON.parse(saved);
		  if (saveData.gameState) {
			gameState = saveData.gameState;
		  }
		  if (saveData.collectedItems) {
			collectedItems = saveData.collectedItems;
		  }
		  if (saveData.productionCollection) {  // <-- 新增
			productionCollection = saveData.productionCollection;
		  }
		  if (saveData.unlockedAchievements) {
			unlockedAchievements = saveData.unlockedAchievements;
			gameState.unlockedAchievements = unlockedAchievements;
		  }
		 if (saveData.elapsedTime) {
			window.startTime = Date.now() - saveData.elapsedTime;
		  } else {
			window.startTime = Date.now();
		  }
		} catch (err) {
		  window.startTime = Date.now();
		}
	  } else {
		window.startTime = Date.now();
	  }
	}

	/***** (1) 重置存檔時重置所有內容 *****/
	function confirmResetProgress() {
	  if (confirm("确定要重置存档吗？此操作不可逆！")) {
		localStorage.removeItem("gameSave");
		// 重置 gameState、collectedItems 並新增重置 productionCollection 與 unlockedAchievements
		gameState = {
		  resources: { food: 100, materials: 100, weapons: 50, tech: 20 },
		  resetCounts: { food: 0, materials: 0, weapons: 0, tech: 0 },
		  resetCounter: 0,
		  totalZombies: 10,
		  allocations: { exploration: 4, farming: 4, recycling: 1, research: 1 },
		  buildings: new Array(9).fill(null).map((_, i) =>
			i === 4 ? { type: 'center', level: 1, upgradable: true } : null),
		  explorationMilestone: 10,
		  efficiency: { food: 1, materials: 1, weapons: 1, tech: 1, exploration: 1 }
		};
		collectedItems = {};
		productionCollection = {};    // 新增：重置生產日誌內容
		unlockedAchievements = [];    // 新增：重置稱號（成就）記錄
		gameState.unlockedAchievements = [];
		// 同時清空探索、生产日誌區（如果存在）
		const prodLog = document.getElementById("productionLog");
		if (prodLog) prodLog.innerHTML = "";
		const explorationLog = document.getElementById("explorationLog");
		if (explorationLog) explorationLog.innerHTML = "";
		// 清空成就頁面
		const achievementGrid = document.getElementById("achievementGrid");
		if (achievementGrid) achievementGrid.innerHTML = "";
		window.startTime = Date.now();
		updateAllDisplays();
		showTempMessage("进度已重置");
	  }
	}


	
	 
	function showCollection() {
	  // 定義依稀有度排序的順序
	  const rarityOrder = { 
		  divine: 12,      // 神聖的
		  legendary: 11,   // 傳奇的
		  epic: 10,        // 史詩的
		  rare: 9,         // 稀有的
		  tested: 8,       // 歷經考驗的
		  selected: 7,     // 精挑細選的
		  sealed: 6,       // 未開封的
		  decent: 5,       // 看起來不錯的
		  common: 4,       // 正常的
		  damaged: 3,      // 破損的
		  old: 2,          // 陳舊的
		  junk: 1     
	  };
	  // 將 collectedItems 轉換成陣列，每個項目包含：名稱、獲得次數與稀有度
	  let items = Object.keys(collectedItems).map(key => {
		  let itemName = collectedItems[key].name;
		  if (itemName === undefined) {
			itemName = key.split("_")[0];
		  }
		  return {
			name: itemName,
			count: collectedItems[key].count,
			rarity: collectedItems[key].rarity
		  };
	  });
	  // 按照稀有度由高到低排序
	  items.sort((a, b) => (rarityOrder[b.rarity] || 0) - (rarityOrder[a.rarity] || 0));
	  items = items.slice(0, 100); // 只取前100條

	  // 建議：改用 CSS 類，避免每個 cell 都在內聯中設置樣式
	  let html = `<table class="collection-table">
		<thead>
		  <tr>
			<th>物品名稱</th>
			<th>獲得次數</th>
		  </tr>
		</thead>
		<tbody>`;
	  items.forEach(item => {
		  html += `<tr class="${item.rarity}">
			<td>${item.name}</td>
			<td>${item.count}</td>
		  </tr>`;
	  });
	  html += `</tbody></table>`;
	  
	  document.getElementById("collectionContent").innerHTML = html;
	  updateCollectionCompletion();
	  showModal('favoritesModal');
	}
	function showModal(modalId) {
	  const modal = document.getElementById(modalId);
	  if (!modal) return;
	  modal.style.display = 'flex';
	}
		
	function updateTimer() {
	  const now = Date.now();
	  const elapsed = now - window.startTime; // window.startTime 应该已初始化
	  const seconds = Math.floor((elapsed / 1000) % 60);
	  const minutes = Math.floor((elapsed / 60000) % 60);
	  const hours = Math.floor(elapsed / 3600000);
	  const formattedTime = 
		String(hours).padStart(2, '0') + ":" +
		String(minutes).padStart(2, '0') + ":" +
		String(seconds).padStart(2, '0');
	  const timerElem = document.getElementById("timerValue");
	  if (timerElem) {
		timerElem.textContent = formattedTime;
	  }
	}

	function initExplorationAnimation() {
	  const container = document.getElementById("explorationAnim");
	  if (container) {
		// 如果已经存在则不重复添加
		if (!container.querySelector('.zombie-search')) {
		  const zombie = document.createElement("div");
		  zombie.className = "zombie-search";
		  container.appendChild(zombie);
		}
	  }
	}

	// 触发入场动画（僵尸增加时调用）
	function triggerZombieEntry() {
	  const container = document.getElementById("explorationAnim");
	  if (!container) { return; }
	  
	  // 创建入场动画元素
	  const entryElem = document.createElement("div");
	  entryElem.className = "zombie-entry";
	  container.appendChild(entryElem);
	  
	  // 动画结束后清理
	  setTimeout(() => {
		if (container.contains(entryElem)) {
		  container.removeChild(entryElem);
		}
	  }, 4000); // 匹配动画时长
	}

	// 触发倒地动画（僵尸减少时调用）
	function triggerZombieLying() {
	  const container = document.getElementById("explorationAnim");
	  if (!container) return;
	  
	  // 创建倒地动画元素（在下层）
	  const lyingElem = document.createElement("div");
	  lyingElem.className = "zombie-lying";
	  container.appendChild(lyingElem);
	  
	  // 动画结束后清理
	  setTimeout(() => {
		if (container.contains(lyingElem)) {
		  container.removeChild(lyingElem);
		}
	  }, 20000); // 匹配動畫時長
	}
	function updateZombieSearchSprite() {
      const zombieElem = document.querySelector(".zombie-search");
      if (!zombieElem) return;
      zombieElem.style.backgroundImage = "url('" + window.currentZombieSprite + "')";
    }

	// 初始化生产动画：为生产动画各栏添加前景僵尸动画（常驻循环播放）
	function initProductionAnimation() {
	  const leftCol = document.getElementById("prodAnimLeft");
	  if (leftCol && !leftCol.querySelector('.prod-zombie-plow')) {
		const zombiePlow = document.createElement("div");
		zombiePlow.className = "prod-zombie-plow";
		leftCol.appendChild(zombiePlow);
	  }
	  const midCol = document.getElementById("prodAnimMid");
	  if (midCol && !midCol.querySelector('.prod-zombie-weld')) {
		const zombieWeld = document.createElement("div");
		zombieWeld.className = "prod-zombie-weld";
		midCol.appendChild(zombieWeld);
	  }
	  const rightCol = document.getElementById("prodAnimRight");
	  if (rightCol && !rightCol.querySelector('.prod-zombie-lab')) {
		const zombieLab = document.createElement("div");
		zombieLab.className = "prod-zombie-lab";
		rightCol.appendChild(zombieLab);
	  }
	}

	function triggerProductionAccident(dept) {
		  let targetElem = null;
		  if (dept === "farming") targetElem = document.getElementById("prodAnimLeft");
		  else if (dept === "recycling") targetElem = document.getElementById("prodAnimMid");
		  else if (dept === "research") targetElem = document.getElementById("prodAnimRight");
		  
		  if (!targetElem) {
			return;
		  }
		  
		  // 創建事故動畫覆蓋層
		  const accidentOverlay = document.createElement("div");
		  accidentOverlay.className = "accident-overlay";
		  accidentOverlay.style.backgroundImage = "url('images/accident.png')";
		  
		  targetElem.appendChild(accidentOverlay);
		  
		  // 3秒後清除動畫覆蓋層
		  setTimeout(() => {
			if (targetElem.contains(accidentOverlay)) {
			  targetElem.removeChild(accidentOverlay);
			}
		  }, 3000);
		}
	
	// 當文件內容完全加載後啟動遊戲
	document.addEventListener("DOMContentLoaded", function() {
		initProductionAnimation();
		initExplorationAnimation();
		updateProductionBackground(); // 初始化生产背景
		setInterval(updateProductionBackground, 60000); // 每分钟检查一次
		const titleLibraryBtn = document.getElementById("titleLibraryBtn");
	    if (titleLibraryBtn) {
		  titleLibraryBtn.addEventListener("click", showTitlesLibrary);
	    }
		
		// 探索動畫相關變數
		let explorationBackgroundsDay = [
		  "images/location_day_1.png",
		  "images/location_day_2.png",
		  "images/location_day_3.png"
		];
		let explorationBackgroundsNight = [
		  "images/location_night_1.png",
		  "images/location_night_2.png",
		  "images/location_night_3.png"
		];
		let currentExplorationBg = "";
		let explorationAnimElem = document.getElementById("explorationAnim");

		// 每分鐘隨機更換背景
		function updateExplorationBackground() {
		  let now = new Date();
		  // 判斷當前時段（08:00-20:00日間，否則夜間）
		  let isDay = now.getHours() >= 8 && now.getHours() < 20;
		  let bgArray = isDay ? explorationBackgroundsDay : explorationBackgroundsNight;
		  // 隨機選一個背景
		  let newBg = bgArray[Math.floor(Math.random() * bgArray.length)];
		  
		  const transitionElem = document.createElement("div");
		  transitionElem.className = "transition-overlay";
		  transitionElem.style.backgroundImage = "url('images/transition.png')";
		  explorationAnimElem.appendChild(transitionElem);
		  
		  setTimeout(() => {
			explorationAnimElem.removeChild(transitionElem);
			explorationAnimElem.style.backgroundImage = `url('${newBg}')`;
		    }, 500);
		}
		// 設置每分鐘更新背景
		setInterval(updateExplorationBackground, 60000);
		updateExplorationBackground(); // 初始化時先執行一次
		
		function updateProductionBackground() {
		  const now = new Date();
		  const isDay = now.getHours() >= 8 && now.getHours() < 20;
		  
		  const bgPrefix = isDay ? "day" : "night";
		  
		  const leftCol = document.getElementById("prodAnimLeft");
		  const midCol = document.getElementById("prodAnimMid");
		  const rightCol = document.getElementById("prodAnimRight");
		  
		  if (leftCol) leftCol.style.backgroundImage = `url('images/prod_${bgPrefix}_left.png')`;
		  if (midCol) midCol.style.backgroundImage = `url('images/prod_${bgPrefix}_mid.png')`;
		  if (rightCol) rightCol.style.backgroundImage = `url('images/prod_${bgPrefix}_right.png')`;
		}

	
		// 绑定重置存档按钮（假定该按钮已在 HTML 中放在末日指挥中心标题旁边，id="resetProgressBtn"）
		const resetBtn = document.getElementById("resetProgressBtn");
		if (resetBtn) {
		 resetBtn.addEventListener("click", confirmResetProgress);
		}
		  
		// 尝试加载存档
		loadGameState();
		removeDuplicateAchievements();
		  
		// 初始化游戏（使用存档或初始状态）
		initGame();
		  
		// 初始化计时器：updateTimer 每秒更新，计时器依据 window.startTime 计算已流逝时间
		setInterval(updateTimer, 1000);
		  
		// 在浏览器刷新/离开前自动保存
		window.addEventListener("beforeunload", saveGameState);
		  
		// 定时保存（例如每10秒保存一次）
		setInterval(saveGameState, 10000);
		  
		// 假設您的收藏按鈕 ID 為 favoritesBtn
	    const favBtn = document.getElementById("favoritesBtn");
		if (favBtn) {
		  favBtn.addEventListener("click", showCollection);
		}

		// 每秒更新一次
		setInterval(updateTimer, 1000);
		
		function gameLoop() {
		  checkAchievements();  // 每次循環檢查成就條件
		  // 資源生產、僵尸生產、食物消耗、探索等操作集中執行
		  produceResources('farming', 'food', 1.7 * 5);
		  produceResources('recycling', 'materials', 0.5 * 5);
		  produceResources('research', 'tech', 0.2 * 5);
		  produceWeaponsFromArmories() 
		  produceZombies();
		  updateFoodConsumption();
		  updateSafetyCenterConsumption();
		  updateBarracksWeaponConsumption();
		  // 探索事件也可以放在同一循環內，或再開一個較低頻率的循環
		  if (gameState.allocations.exploration > 0) {
			handleExploration();
		  }

		  // 統一更新所有顯示（若加上前面提到的 dirty flag 更新，就不會每次都更新）
		  updateAllDisplays();
		  const upgradeModal = document.getElementById("upgradeModal");
		  if (upgradeModal && upgradeModal.style.display === "flex" && typeof currentUpgradeIndex !== "undefined") {
			updateUpgradeMenuContent(currentUpgradeIndex);
		  }
		  // --- 新增建造彈窗自動更新 ---
		  const buildModal = document.getElementById("buildModal");
		  if (buildModal && buildModal.style.display === "flex" && currentBuildIndex !== null) {
			updateBuildMenuContent(currentBuildIndex);
		  }
		}

		// 用單一定時器啟動主循環，例如每 5 秒執行一次
		setInterval(gameLoop, 5000);

		
		
		// 為所有 modal-overlay 添加事件監聽器
		document.querySelectorAll('.modal-overlay').forEach(overlay => {
		  overlay.addEventListener('click', function(event) {
			// 精确判断点击区域是否为遮罩层本身
			if (event.target === overlay) { 
			  closeModal(overlay.id);
			}
			if (!event.target.closest('.modal-content')) {
			  closeNestedModal(overlay.id);
			}
		  });
		});
	});
	


 (function(){
	let battleModeActive = false;
	let battleMatched = false;
	let battleInterval = null;
	let battleSpecialTimer = null; 
	let battleSpecialLogTimer = null;
	let btrSpecialActive = false;
	let totalEnemyDamage = 0;
	let totalSelfDamage = 0;
	let resultCalculated = false;
	let resultData = null;
	let battleEnded = false;
	let processedCommands = {};
	const battleDuration = 60; // 戰鬥時長 180 秒（3 分鐘）
	
	const attackPhrases = {
	  normal: [
		"僵尸自信地打出一個長點射",
		"僵尸使用單發點射，進行精確射擊",
		"僵尸克制地打出兩個短點射",
		"僵尸把槍舉過頭頂，亂射一通",
		"僵尸調到全自動，進行壓制射擊"
	  ],
	  btr: [
		"BTR-80使用30mm高爆彈鏈[HE]，前出實施火力支援",
		"BTR-80使用30mm混合彈鏈[AP+HE+API]，對目標展開火力覆蓋",
		"BTR-80使用30mm對空彈鏈[API+HE+AP-T]，對目標展開精準射擊",
		"BTR-80使用30mm穿甲彈鏈[AP]，對敵方掩體展開集中射擊",
		"BTR-80使用30mm曳光彈鏈[AP-T+API+HE-T]，對敵方集群進行威懾射擊",
		"BTR-80使用30mm穿燃彈鏈[API]，對輕裝甲目標展開壓制射擊"
	  ],
	  t80: [
	    "T-80使用12.7mm高射機槍[7n34]，對目標展開精確點射",
		"T-80使用125mm高爆彈[3OF26]，對開闊地目標實施射擊",
		"T-80使用125mm高爆彈[3OF26]，對掩體內目標實施射擊",
		"T-80使用125mm穿甲彈[3BM42]，對混凝土建築實施貫穿射擊",
		"T-80採用125mm穿甲彈[3BM60]，對敵方重裝甲目標實施貫穿射擊",
		"T-80使用125mm破甲彈[3BK18M]，對混凝土建築實施破壞射擊",
		"T-80使用125mm破甲彈[3BK18M]，對敵方輕裝甲目標實施破壞射擊"
	  ]
	};
	function getRandomPhrase(type) {
	  let phrases = attackPhrases[type];
	  if (!phrases || phrases.length === 0) {
		// 沒有特定類型，返回一般攻擊的描述
		phrases = attackPhrases.normal;
	  }
	  const index = Math.floor(Math.random() * phrases.length);
	  return phrases[index];
	}

	// 修改後：進入對戰模式只初始化獨立對戰動畫
	function enterBattleMode() {
        if (battleModeActive) return;
        battleModeActive = true;
        battleMatched = false;
        document.getElementById("battleOverlay").style.display = "block";
        document.body.style.overflow = "hidden";
        // 初始化對戰動畫，己方使用 window.currentZombieSprite
        initBattleAnimation(false);
        // 為 battleOverlay 綁定雙擊退出事件
        document.getElementById("battleOverlay").addEventListener("dblclick", exitBattleMode);
      }
	  
      function exitBattleMode() {
        if (!battleModeActive) return;
        battleModeActive = false;
        battleMatched = false;
        document.getElementById("battleOverlay").style.display = "none";
        document.body.style.overflow = "";
		
		// 清理计时器
		if (battleInterval) {
		clearInterval(battleInterval);
		battleInterval = null;
	  }
	  if (battleSpecialTimer) {
		clearInterval(battleSpecialTimer);
		battleSpecialTimer = null;
	  }
	  if (battleSpecialLogTimer) {
		clearInterval(battleSpecialLogTimer);
		battleSpecialLogTimer = null;
	  }
	  if (statusCheckInterval) {
		clearInterval(statusCheckInterval);
		statusCheckInterval = null;
	  }
	  if (battleBTREventTimer) {
		clearInterval(battleBTREventTimer);
		battleBTREventTimer = null;
	  }
	  if (battleBTRInterval) {
		clearInterval(battleBTRInterval);
		battleBTRInterval = null;
	  }
		
		// 清理 Firebase 监听
		if (window.currentBattleRoom) {
		  const roomRef = firebase.database().ref("battles").child(window.currentBattleRoom);
		  
		  // 移除用户
		  if (window.myRole === "userA") {
			roomRef.child("userA").remove();
		  } else if (window.myRole === "userB") {
			roomRef.child("userB").remove();
		  }
		  
		  // 检查房间是否为空
		  roomRef.once("value").then(snapshot => {
			const data = snapshot.val();
			if ((!data.userA || !data.userA.uid) && (!data.userB || !data.userB.uid)) {
			  // 房间为空，删除整个房间
			  roomRef.remove();
			}
		  });
		  
		  // 移除结果监听
		  roomRef.child("result").off();
		}
		
		// 重置变量
		window.currentBattleRoom = null;
		window.myRole = null;
		resultData = null;
		resultCalculated = false;
		totalSelfDamage = 0;
		totalEnemyDamage = 0;
		window.location.reload();
	  }

	 function updateBattleZombieSearchSprite() {
      const battleZombieElem = document.querySelector("#battleSelfAnim .zombie-search");
      if (!battleZombieElem) return;
      battleZombieElem.style.backgroundImage = "url('" + window.currentZombieSprite + "')";
	  battleZombieElem.style.backgroundImage = "url('" + window.currentT80Sprite + "')";
	  battleZombieElem.style.backgroundImage = "url('" + window.currentBtrSprite + "')";
    }
	

	 function initBattleAnimation(match) {
        const selfAnim = document.getElementById("battleSelfAnim");
        const enemyAnim = document.getElementById("battleEnemyAnim");
        selfAnim.innerHTML = "";
        enemyAnim.innerHTML = "";
        selfAnim.style.backgroundImage = "url('images/location_day_1.png')";
        selfAnim.style.backgroundRepeat = "repeat-x";
        selfAnim.style.backgroundSize = "auto 100%";
        selfAnim.style.backgroundPosition = "center top";
        selfAnim.style.animation = "scrollBgRight 30s linear infinite";
        if (match) {
          enemyAnim.style.backgroundImage = selfAnim.style.backgroundImage;
          enemyAnim.style.backgroundRepeat = "repeat-x";
          enemyAnim.style.backgroundSize = "auto 100%";
          enemyAnim.style.backgroundPosition = "center top";
          enemyAnim.style.animation = "scrollBgRight 30s linear infinite";
        } else {
          enemyAnim.style.backgroundColor = "#000";
          enemyAnim.style.animation = "";
        }
        // 創建己方僵尸搜尋動畫元素，使用 window.currentZombieSprite
        let zombieSearch = document.createElement("div");
        zombieSearch.className = "zombie-search";
        zombieSearch.style.backgroundImage = "url('" + window.currentZombieSprite + "')";
        selfAnim.appendChild(zombieSearch);
      }
	  
	function handleIncomingDamage(damage) {
	  totalSelfDamage += damage;
	}

	// 修改 appendBattleLogEntry 函数
	function appendBattleLogEntry(messageObj) {
	  // 确保 messageObj 是对象
	  if (typeof messageObj !== 'object' || messageObj === null) {
		return;
	  }
	  
	  // 处理系统消息
	  if (messageObj.senderRole === "system") {
		const entry = document.createElement("div");
		entry.className = "log-entry battle-system-entry";
		entry.textContent = messageObj.message || "系统消息";
		
		const logContainer = document.getElementById("battleLogContent");
		if (logContainer) {
		  logContainer.appendChild(entry);
		  logContainer.scrollTop = logContainer.scrollHeight;
		}
		return;
	  }
	  
	  // 处理普通消息
	  const sender = messageObj.sender || "未知";
	  const msg = messageObj.message || "未知"; // 确保 msg 被定义
	  
	  // 组合显示文本
	  const displayText = `${sender}派遣的${msg}`;
	  
	  const entry = document.createElement("div");
	  
	  // 根据 senderRole 与本地角色区分样式
	  if (messageObj.senderRole === window.myRole) {
		entry.className = "log-entry battle-self-entry";
	  } else if (messageObj.senderRole) {
		entry.className = "log-entry battle-enemy-entry";
	  } else {
		entry.className = "log-entry battle-system-entry";
	  }
	  
	  entry.textContent = displayText;
	  
	  const logContainer = document.getElementById("battleLogContent");
	  if (logContainer) {
		logContainer.appendChild(entry);
		logContainer.scrollTop = logContainer.scrollHeight;
	  }
	  
	  // 解析伤害信息 - 现在 msg 已经被定义
	  if (messageObj.senderRole && messageObj.senderRole !== window.myRole) {
		const damageMatch = msg.match(/對方僵尸-(\d+)/);
		if (damageMatch) {
		  const damage = parseInt(damageMatch[1]);
		  handleIncomingDamage(damage);
		}
	  }
	}

	// 添加敌方伤害处理函数
	function handleIncomingDamage(damage) {
	  totalSelfDamage += damage;
	}



	
	// 當頁面加載完成後，初始化使用者 UID（直接使用暱稱）
	function initializeUser() {
	  let nickname = document.getElementById("battleNickname").value.trim();
	  if (!nickname) {
		return false;
	  }
	  window.myUid = nickname; // 將暱稱作為唯一標識
	  return true;
	}

	function startBattleModeFirebase() {
	  let pin = document.getElementById("battlePin").value.trim();
	  if (pin === "") {
		return;
	  }
	  
	  // 使用暱稱作為 uid
	  let currentUid = document.getElementById("battleNickname").value.trim();
	  if (!currentUid) {
		return;
	  }
	  
	  firebase.database().ref('pveBattles').child(pin).once('value').then((snapshot) => {
		const pveRoomData = snapshot.val();
		if (pveRoomData) {
		  // 這是一個PVE房間
		  if (pveRoomData.locked || pveRoomData.mode === 'solo') {
			return;
		  }
		  
		  if (pveRoomData.mode === 'coop' && !pveRoomData.userB) {
			return;
		  }
		  
		  // 其他情況：房間已滿或狀態異常
		  return;
		}
    
		// 不是PVE房間，繼續原有的PVP匹配邏輯
		let battleRoomRef = firebase.database().ref("battles").child(pin);
		// 使用 once("value") 檢查房間是否存在
		battleRoomRef.once("value").then(function(snapshot) {
		  let battleData = snapshot.val();
		  if (battleData === null) {
			// 房間不存在 → 設置 userA
			battleRoomRef.set({
			  userA: { uid: currentUid },
			  log: {}
			}).then(function() {
			  joinBattleRoom(pin, "userA");
			});
		  } else if (battleData.userA && battleData.userA.uid === currentUid) {
			// 當前設備已經是 userA
			joinBattleRoom(pin, "userA");
		  } else if (!battleData.userB) {
			// 房間存在但沒有 userB → 加入成為 userB
			battleRoomRef.child("userB").set({ uid: currentUid }).then(function() {
			  joinBattleRoom(pin, "userB");
			});
		  } else if (battleData.userB && battleData.userB.uid === currentUid) {
			// 當前設備已經是 userB
			joinBattleRoom(pin, "userB");
		  } else {
			alert("此戰局已滿！");
		  }
		});
	  }).catch((error) => {
		let battleRoomRef = firebase.database().ref("battles").child(pin);
	  });
	}

	// 添加系统消息推送函数
	function pushSystemMessage(message) {
	  if (!window.currentBattleRoom) return;
	  
	  const data = {
		sender: "系統",
		senderRole: "system",
		message: message
	  };
	  
	  const logRef = firebase.database().ref("battles")
							.child(window.currentBattleRoom)
							.child("log");
	  logRef.push(data);
	}
	function joinBattleRoom(battleId, roleFromServer) {
	  window.currentBattleRoom = battleId;
	  window.myRole = roleFromServer; 
	  window.myUid = document.getElementById("battleNickname").value.trim();
	   // 清理旧结果
	  resultData = null;
	  resultCalculated = false;
	  
	  // 建立房間參考
	  let roomRef = firebase.database().ref("battles").child(battleId);
	  
	  // 清除並持續監聽房間狀態
	  roomRef.off("value");
	  roomRef.on("value", function(snapshot) {
		let data = snapshot.val();
		if (data && data.userA && data.userB) {
		  if (!battleMatched) {
			battleMatched = true;
			initBattleAnimation(true);
			pushBattleLog("雙方連線成功，對戰開始！");
			startBattleTimerFirebase();
			if (battleSpecialTimer) clearInterval(battleSpecialTimer);
		  }
		} else {
		  if (battleMatched) {
			battleMatched = false;
			pushBattleLog("等待對戰對手加入...");
		  }
		}
	  });
	  
	  let logRef = roomRef.child("log");
	  logRef.off("child_added");
	  logRef.on("child_added", function(snapshot) {
	    if (battleEnded) return;
		let data = snapshot.val();
		try {  
		  // 确保数据是对象
		  if (data && typeof data === 'object') {
			appendBattleLogEntry(data);
		  } else {
			// 处理旧格式或无效数据
			appendBattleLogEntry({
			  sender: "系統",
			  senderRole: "system",
			  message: data || "未知消息"
			});
		  }
		} catch (e) {}
	  });
	  listenForZombieStatus();
	  requestZombieStatus();
	  listenForAdjustmentCommand();
	  
	  // 添加结果监听
	  const resultRef = roomRef.child("result");
	  resultRef.off("value");
	  resultRef.on("value", snapshot => {
		const result = snapshot.val();
		if (result && !resultData) {
		  resultData = result;
		  displayBattleResult(result);
		}
	  });
	  startStatusCheck();
	  initBattleBTRSystem();
	  listenForEnemyBTR();
	  listenForEnemyBTRAttacks();

	}



	function pushBattleLog(message) {
	  if (battleEnded) return;
	  if (!window.myRole) {
		return;
	  }
	  
	  const data = {
		sender: window.myUid || "未知", // 使用昵称
		senderRole: window.myRole,      // "userA" 或 "userB"
		message: message                // 攻击消息
	  };
	  if (window.currentBattleRoom) {
		  try {
			const logRef = firebase.database()
			  .ref("battles")
			  .child(window.currentBattleRoom)
			  .child("log");
			logRef.push(data)
			  .catch(() => {
			  });
		  } catch (e) {
		  }
		}
	}


	// 修改“開始對戰”按鈕事件，令其調用 Firebase 對戰流程
	document.getElementById("battleStartBtn").addEventListener("click", function(){
	  initializeUser();
	  startBattleModeFirebase();
	});
	document.getElementById("battleExitBtn").addEventListener("click", function() {
	  exitBattleMode();
	});

	// 使用 Firebase 同步對戰日誌信息的對戰事件
	function triggerBattleEventFirebase() {
	  if (battleEnded || !battleModeActive) {
		return;
	  }
	  const centerBuilding = gameState.buildings.find(b => 
		b && b.type.toLowerCase() === "center"
	  );
	  const centerLevel = centerBuilding ? centerBuilding.level : 1;
	  const hitChance = Math.min(40 + centerLevel * 0.5, 85);
	  
	  // 模拟我方攻击
	  const ourHit = (Math.random() * 100 < hitChance);
	  const baseOurDamage = ourHit ? (Math.floor(Math.random() * 10) + 1): 0;
	   // 從 gameState 中查找僵尸指揮中心的等級
	  let commandCenterLevel = 0;
	  if (window.gameState && window.gameState.buildings) {
		  const commandCenter = window.gameState.buildings.find(b => 
			  b && b.type.toLowerCase() === "zombiecommandcenter"
		  );
		  if (commandCenter) {
			  commandCenterLevel = commandCenter.level;
		  }
	  }

	  // 每級1%的加成：倍率 = 1 + (僵尸指揮中心等級 × 0.01)
	  const multiplierZ = 1 + commandCenterLevel * 0.01;

	  // 最終傷害
	  const ourDamage = Math.round(baseOurDamage * multiplierZ);
	  const phrase = getRandomPhrase("normal");
	  if (ourHit) {
	    pushBattleLog( phrase + "（命中），對方僵尸-" + ourDamage);
		totalEnemyDamage += ourDamage;
	  } else {
		pushBattleLog( phrase + "（未命中）");
	  }
	}


	function startBattleTimerFirebase() {
	   let remaining = battleDuration;
		battleInterval = setInterval(function() {
		  if (remaining <= 0) {
			endBattle(); // 直接調用我們的新函數，立即終止所有事件生成
			} else {
			  // 僅在 battleEnded 為 false 時觸發事件生成
			  if (!battleEnded) {
				triggerBattleEventFirebase();
			  }
			  remaining -= 5;
			}
		}, 5000);
	}
	function endBattle() {
	  // 立即清除所有定時器
	  if (battleInterval) {
		clearInterval(battleInterval);
		battleInterval = null;
	  }
	  if (battleSpecialTimer) {
		clearInterval(battleSpecialTimer);
		battleSpecialTimer = null;
	  }
	  if (battleBTREventTimer) {
		clearInterval(battleBTREventTimer);
		battleBTREventTimer = null;
	  }

	  // 立即卸載 Firebase 上對 log 與 btrAttacks 的監聽器
	  const roomRef = firebase.database().ref("battles").child(window.currentBattleRoom);
	  roomRef.child("log").off();
	  roomRef.child("btrAttacks").off();

	  // 設定 battleEnded 為 true，阻止未來所有事件生成入口
	  battleEnded = true;

	  // 如果本端是 userA 且結果尚未計算，則計算並上傳戰鬥結果
	  if (window.myRole === "userA" && !resultCalculated) {
		calculateAndBroadcastBattleResult();
	  }
	  
	  // 監聽結果（讓所有用戶都看到最終結果）
	  listenForBattleResult();

	  // 發送戰鬥結束系統提示
	  pushSystemMessage("戰鬥結束！戰鬥總結生成中");
	}
	function clearPendingEvents() {
	  // 清除所有计划中的事件
	  if (window.pendingEvents) {
		window.pendingEvents.forEach(timeoutId => {
		  clearTimeout(timeoutId);
		});
		window.pendingEvents = [];
	  }
	}

	function calculateAndBroadcastBattleResult() {
	  // 确保只计算一次
	  if (resultCalculated) return;
	  resultCalculated = true;
	  
	  // 获取房间数据
	  const roomRef = firebase.database().ref("battles").child(window.currentBattleRoom);
	  
	  roomRef.once("value").then(snapshot => {
		const roomData = snapshot.val();
		if (!roomData || !roomData.userA || !roomData.userB) return;
		
		// 获取双方UID
		const userAUid = roomData.userA.uid;
		const userBUid = roomData.userB.uid;
		
		// 获取双方伤害数据
		const logEntries = Object.values(roomData.log || {});
		
		// 计算双方伤害
		let damageA = 0;
		let damageB = 0;
		
		logEntries.forEach(entry => {
		  if (entry.senderRole === "userA") {
			const damageMatch = entry.message.match(/對方僵尸-(\d+)/);
			if (damageMatch) damageB += parseInt(damageMatch[1]);
		  } else if (entry.senderRole === "userB") {
			const damageMatch = entry.message.match(/對方僵尸-(\d+)/);
			if (damageMatch) damageA += parseInt(damageMatch[1]);
		  }
		});
		
		// 判定胜负
		let winnerUid = null;
		let loserUid = null;
		let isDraw = false;
		
		if (damageA < damageB) {
		  winnerUid = userAUid;
		  loserUid = userBUid;
		} else if (damageA > damageB) {
		  winnerUid = userBUid;
		  loserUid = userAUid;
		} else {
		  isDraw = true; // 平局
		}
		
		// 创建结果对象
		const result = {
		  userA: userAUid,
		  userB: userBUid,
		  damageA: damageA,
		  damageB: damageB,
		  isDraw: isDraw, // 添加平局标志
		  timestamp: Date.now()
		};
		// 只在有胜负时设置胜败方
		if (!isDraw) {
		  result.winner = winnerUid;
		  result.loser = loserUid;
		}
		
		// 保存结果到Firebase
		roomRef.child("result").set(result);
		
		// 请求双方上传僵尸状态
		const myStatus = {
		  uid: window.myUid,
		  totalZombies: gameState.totalZombies,
		  allocations: {...gameState.allocations}
		};
		
		roomRef.child("status").child(window.myRole).set(myStatus);
		
		// 通知对方也上传状态
		pushSystemMessage("戰鬥結束，自動上傳僵尸狀態...");
	  });
	}
	// 添加僵尸状态请求函数
	function requestZombieStatus() {
	  if (!window.currentBattleRoom) return;
	  
	  // 上传自己的僵尸状态
	  
  
	  const myStatus = {
		uid: window.myUid,
		totalZombies: gameState.totalZombies,
		allocations: { ...gameState.allocations },

		currentZombieSprite: window.currentZombieSprite,

		currentT80Sprite: window.currentT80Sprite,
		currentBtrSprite: window.currentBtrSprite,

		resources: {
		  food: gameState.resources.food,
		  materials: gameState.resources.materials,
		  weapons: gameState.resources.weapons,
		  tech: gameState.resources.tech
		}
	  };
	  
	  const statusRef = firebase.database().ref("battles")
		.child(window.currentBattleRoom)
		.child("status")
		.child(window.myRole);
	  
	  statusRef.transaction(current => {
		return myStatus; // 直接替换为新数据
	  }, (error, committed) => {
	  }, false); 
	}

	// 添加僵尸状态监听
	function listenForZombieStatus() {
	  if (!window.currentBattleRoom) return; 
	  const statusRef = firebase.database().ref("battles")
		.child(window.currentBattleRoom)
		.child("status");
	  
	  // 清除旧监听
	  statusRef.off("value");
	  
	  statusRef.on("value", snapshot => {
		const statusData = snapshot.val();		
		// +++ 更健壮的状态检查 +++
		const userAReady = statusData && statusData.userA && statusData.userA.uid;
		const userBReady = statusData && statusData.userB && statusData.userB.uid;
		
		if (userAReady && userBReady) {
		  const enemyRole = window.myRole === "userA" ? "userB" : "userA";
		   window.opponentZombieSprite = statusData[enemyRole].currentZombieSprite;
		   window.opponentT80Sprite = statusData[enemyRole].currentT80Sprite;
		   window.opponentBtrSprite = statusData[enemyRole].currentBtrSprite;
		  
		  initEnemyZombieSearchAnimation(window.opponentZombieSprite);
		  pushSystemMessage("雙方狀態已接收，開始計算資源調整");
		  
		  // 只有 userA 计算资源调整
		  if (window.myRole === "userA") {
			calculateResourceAdjustment(statusData);
		  }
		} else {
		  // 如果是userB没准备好且我是userA，尝试重新请求
		  if (!userBReady && window.myRole === "userA") {
			pushSystemMessage("請求userB重新上傳狀態...");
			const logRef = firebase.database().ref("battles")
			  .child(window.currentBattleRoom)
			  .child("log");
			  
			logRef.push({
			  sender: "系统",
			  senderRole: "system",
			  message: "userB请重新上传僵尸状态"
			});
		  }
		}
	  });
	}
	function startStatusCheck() {
	  if (statusCheckInterval) clearInterval(statusCheckInterval);
	  
	  statusCheckInterval = setInterval(() => {
		if (!window.currentBattleRoom) return;
		
		const statusRef = firebase.database().ref("battles")
		  .child(window.currentBattleRoom)
		  .child("status");
		
		statusRef.once("value").then(snapshot => {
		  const statusData = snapshot.val();
		  
		  // 如果userB状态不存在，且我是userB，立即上传
		  if (window.myRole === "userB" && 
			  (!statusData || !statusData.userB || !statusData.userB.uid)) {
			requestZombieStatus();
		  }
		});
	  }, 5000); // 每5秒检查一次
	}

	// 添加资源调整计算函数
	function calculateResourceAdjustment(statusData) {
	  // 确保是userA执行计算
	  if (window.myRole !== "userA") return;
	  
	  // 获取结果数据
	  const resultRef = firebase.database().ref("battles")
		.child(window.currentBattleRoom)
		.child("result");
	  
	  resultRef.once("value").then(snapshot => {
		const result = snapshot.val();
		if (!result || !result.winner) return;
		
		// 获取双方状态
		const winnerStatus = result.winner === statusData.userA.uid ? statusData.userA : statusData.userB;
		const loserStatus = result.loser === statusData.userA.uid ? statusData.userA : statusData.userB;
		
		if (!result.winner) {
			pushSystemMessage("平局，雙方資源保持不變");
			return;
		  }
		// 计算调整比例（10%-20%）
		const adjustmentFraction = 0.1 + Math.random() * 0.1;
		const adjustmentAmount = Math.floor(loserStatus.totalZombies * adjustmentFraction);
		
		// 计算赢家分配比例（探索:农业:回收:研究 = 4:4:1:1）
		const winRatios = { exploration: 4, farming: 4, recycling: 1, research: 1 };
		const winTotalRatio = 10;
		
		// 计算赢家各部门增加量
		const winnerAdjustment = {};
		for (const department in winRatios) {
		  const ratio = winRatios[department];
		  winnerAdjustment[department] = Math.floor(adjustmentAmount * (ratio / winTotalRatio));
		}
		
		// 计算输家各部门扣除量（平均扣除）
		const departments = Object.keys(loserStatus.allocations);
		const deductionPerDept = Math.floor(adjustmentAmount / departments.length);
		const loserAdjustment = {};
		
		for (const department of departments) {
		  loserAdjustment[department] = deductionPerDept;
		}
		// +++ 新增资源转移计算 +++
	    const resourceTypes = ['food', 'materials', 'weapons', 'tech'];
	    const selectedResource = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
	  
	    // 获取失败方该资源数量
	    const loserResource = loserStatus.resources[selectedResource] || 0;
	  
	    // 计算转移量（20%）
	    const resourceAdjustment = Math.floor(loserResource * 0.2);
		// 创建调整指令
		const adjustmentCommand = {
		  winner: result.winner,
		  loser: result.loser,
		  adjustmentAmount: adjustmentAmount,
		  winnerAdjustment: winnerAdjustment,
		  loserAdjustment: loserAdjustment,
		  // +++ 新增资源转移字段 +++
		  resourceType: selectedResource, // 随机选择的资源类型
		  resourceAmount: resourceAdjustment // 转移数量
		};
		
		// 广播调整指令
		const commandRef = firebase.database().ref("battles")
		  .child(window.currentBattleRoom)
		  .child("command");
		
		commandRef.set(adjustmentCommand);
	  });
	}
	// 添加调整指令监听
	function listenForAdjustmentCommand() {
	  if (!window.currentBattleRoom) return;
	  
	  const commandRef = firebase.database().ref("battles")
		.child(window.currentBattleRoom)
		.child("command");
	  
	  commandRef.off("value");
	  commandRef.on("value", snapshot => {
		const command = snapshot.val();
		if (!command) return;
    
		// +++ 添加指令唯一性检查 +++
		const commandId = command.timestamp; // 使用时间戳作为唯一ID
		
		// 如果已经处理过这个指令，则跳过
		if (processedCommands[commandId]) {
		  return;
		}
		
		// 标记指令已处理
		processedCommands[commandId] = true;
		applyResourceAdjustment(command);
	  });
	}
	function endBattleFirebase() {
	  if (window.currentBattleRoom) {
		firebase.database().ref("battles")
		  .child(window.currentBattleRoom)
		  .child("log")
		  .off();
	  }
	}

	function listenForBattleResult() {
	  if (!window.currentBattleRoom) return;
	  
	  const resultRef = firebase.database().ref("battles")
		.child(window.currentBattleRoom)
		.child("result");
	  resultRef.off("value");
	  
	  resultRef.on("value", snapshot => {
		const result = snapshot.val();
		if (result && !resultData) {
		  resultData = result;
		
		  displayBattleResult(result);
		  
		 // +++ 确保所有玩家都上传状态 +++
		  const myStatus = {
			uid: window.myUid,
			totalZombies: gameState.totalZombies,
			allocations: {...gameState.allocations},
			// +++ 新增资源数据 +++
			resources: {
			  food: gameState.resources.food,
			  materials: gameState.resources.materials,
			  weapons: gameState.resources.weapons,
			  tech: gameState.resources.tech
			}
		  };
		  
		  // +++ 使用统一路径格式 +++
		  const statusRef = firebase.database().ref("battles")
			.child(window.currentBattleRoom)
			.child("status")
			.child(window.myRole); // 直接存储在 userA/userB 下
		  
		  statusRef.set(myStatus)
			.then(() => {
			  pushSystemMessage(`狀態已上傳: ${gameState.totalZombies} 僵尸`);
			})
			.catch(error => {
			  pushSystemMessage("狀態上傳失敗，請檢查網絡連接");
			  setTimeout(() => statusRef.set(myStatus), 2000);
			});
		}
	  });
	}

	// 添加结果显示函数
	function displayBattleResult(result) {
	  if (!result) return;
	  
	  // 显示伤害统计
	  const damageMessage = `戰鬥報告：
		${result.userA} 擊斃: ${result.damageB} 名僵尸
		${result.userB} 擊斃: ${result.damageA} 名僵尸`;
	  
	  pushSystemMessage(damageMessage);
	  
	  // +++ 处理平局情况 +++
	  if (result.isDraw) {
		pushSystemMessage("最終結果：平手");
	  } else if (result.winner) {
		const winnerName = result.winner === result.userA ? result.userA : result.userB;
		const loserName = result.winner === result.userA ? result.userB : result.userA;
		
		const resultMessage = `最終結果：
		  ${result.winner} 勝利
		  ${result.loser} 失敗`;
		
		pushSystemMessage(resultMessage);
	  }
	}
	function applyResourceAdjustment(command) {
	  // 确定当前玩家身份
	  const isWinner = window.myUid === command.winner;
	  const isLoser = window.myUid === command.loser;
	  
	  if (!command.winner) {
		pushSystemMessage("平局，无资源调整");
		return;
	  }
	  
	  // 应用调整
	  if (isWinner) {
		// 赢家：按比例增加各部门僵尸
		for (const department in command.winnerAdjustment) {
		  const amount = command.winnerAdjustment[department];
		  gameState.allocations[department] += amount;
		  gameState.totalZombies += amount;
		}
		
		// 显示调整信息
		const adjustmentMessage = `勝方（${window.myUid}）掠奪量：
		  探索部門 +${command.winnerAdjustment.exploration || 0}
		  農業部門 +${command.winnerAdjustment.farming || 0}
		  回收部門 +${command.winnerAdjustment.recycling || 0}
		  研究部門 +${command.winnerAdjustment.research || 0}
		  總計 +${command.adjustmentAmount}隻僵尸`;
		
		pushSystemMessage(adjustmentMessage);
	  } 
	  else if (isLoser) {
		// 输家：平均扣除各部门僵尸
		for (const department in command.loserAdjustment) {
		  const amount = command.loserAdjustment[department];
		  // 确保不超过当前数量
		  const deduction = Math.min(amount, gameState.allocations[department] || 0);
		  gameState.allocations[department] -= deduction;
		  gameState.totalZombies -= deduction;
		}
		
		// 显示调整信息
		const adjustmentMessage = `敗方（${window.myUid}）損失量：
		  探索部門 -${command.loserAdjustment.exploration || 0}
		  農業部門 -${command.loserAdjustment.farming || 0}
		  回收部門 -${command.loserAdjustment.recycling || 0}
		  研究部門 -${command.loserAdjustment.research || 0}
		  總計 -${command.adjustmentAmount}隻僵尸`;
		
		pushSystemMessage(adjustmentMessage);
	  }
	  // +++ 新增资源转移处理 +++
	  if (command.resourceType && command.resourceAmount) {
		const resourceName = resourceMapping[command.resourceType];
		
		if (isWinner) {
		  // 胜方增加资源
		  gameState.resources[command.resourceType] += command.resourceAmount;
		  
		  // 添加系统消息
		  const gainMessage = `勝方（${window.myUid}）獲得${resourceName}資源: +${command.resourceAmount}`;
		  pushSystemMessage(gainMessage);
		  
		  // 更新UI显示
		  updateResourceDisplays(command.resourceType);
		} 
		else if (isLoser) {
		  // 败方扣除资源（确保不低于0）
		  const currentAmount = gameState.resources[command.resourceType] || 0;
		  const deduction = Math.min(command.resourceAmount, currentAmount);
		  
		  gameState.resources[command.resourceType] -= deduction;
		  
		  // 添加系统消息
		  const lossMessage = `敗方（${window.myUid}）損失${resourceName}資源: -${deduction}`;
		  pushSystemMessage(lossMessage);
		  
		  // 更新UI显示
		  updateResourceDisplays(command.resourceType);
		}
	  }
	  
	  // 保存游戏状态
	  saveGameState();
	  
	  // 更新UI
	  updateResourceDisplays();
	}
	

	function triggerBattleEvent() {
	  if (!battleMatched) return;
	  
	  const centerBuilding = gameState.buildings.find(b => b && b.type.toLowerCase() === "center");
	  const centerLevel = centerBuilding ? centerBuilding.level : 1;
	  const hitChance = Math.min(40 + centerLevel * 0.5, 85);

	  const ourHit = (Math.random() * 100 < hitChance);
	  const baseOurDamage = ourHit ? (Math.floor(Math.random() * 10) + 1): 0;
	   // 從 gameState 中查找僵尸指揮中心的等級
	  let commandCenterLevel = 0;
	  if (window.gameState && window.gameState.buildings) {
		  const commandCenter = window.gameState.buildings.find(b => 
			  b && b.type.toLowerCase() === "zombiecommandcenter"
		  );
		  if (commandCenter) {
			  commandCenterLevel = commandCenter.level;
		  }
	  }

	  // 每級1%的加成：倍率 = 1 + (僵尸指揮中心等級 × 0.01)
	  const multiplierZ = 1 + commandCenterLevel * 0.01;

	  // 最終傷害
	  const ourDamage = Math.round(baseOurDamage * multiplierZ);
	  const phrase = getRandomPhrase("normal");
	  if (ourHit) {
		pushBattleLog( phrase + "（命中），對方僵尸-" + ourDamage);
		totalEnemyDamage += ourDamage;
	  } else {
		pushBattleLog( phrase + "（未命中）");
	  }

	}


	
	function initEnemyZombieSearchAnimation(sprite) {
	  const enemyAnim = document.getElementById("battleEnemyAnim");
	  if (!enemyAnim) return;
	  
	  // 清除舊動畫（如果存在）
	  const oldZombie = enemyAnim.querySelector(".enemy-zombie-search");
	  if (oldZombie) {
		enemyAnim.removeChild(oldZombie);
	  }
	  
	  // 創建僵尸搜索元素，直接使用傳入的 sprite
	  const zombieSearch = document.createElement("div");
	  zombieSearch.className = "zombie-search enemy-zombie-search";
	  zombieSearch.style.backgroundImage = `url('${sprite}')`;
	  
	  // 添加到敵方動畫窗口
	  enemyAnim.appendChild(zombieSearch);
	}

	
	/***** 对战模式BTR/T-80事件系统 *****/
	let battleBTREventTimer = null;
	let battleBTRActive = false;
	let battleBTRType = null;
	let battleBTRInterval = null;
	let battleBTRWrapper = null;
	let statusCheckInterval = null;

	// 1. 初始化对战模式BTR事件系统
	function initBattleBTRSystem() {
	  if (battleBTREventTimer) clearInterval(battleBTREventTimer);
	  
	  // 每30秒检查一次BTR事件
	  battleBTREventTimer = setInterval(() => {
		if (!battleModeActive || battleEnded || !battleMatched) return;
		
		const garages = gameState.buildings.filter(b => 
		  b && b.type.toLowerCase() === "armoredgarage"
		);
		
		if (garages.length > 0) {
		  const garageInfo = BUILDINGS.armoredGarage.getUpgradeInfo(garages[0].level);
		  if (Math.random() < garageInfo.effect.btrChance) {
			triggerBattleBTRAnimation();
		  }
		}
	  }, 30000);
	}

	// 2. 触发对战模式BTR动画
	function triggerBattleBTRAnimation() {
	  const container = document.getElementById("battleSelfAnim");
	  if (!container) {
		return;
	  }
	  
	  const containerWidth = container.clientWidth;
	  const offset = 50;
	  const rootStyles = getComputedStyle(document.documentElement);
	  
	  // 40%几率使用T-80，否则BTR
	  const useT80 = (Math.random() < 0.4);
	  battleBTRType = useT80 ? "t80" : "btr";
	  
	  let frameWidth;
	  if (useT80) {
		frameWidth = 480;
	  } else {
		frameWidth = parseFloat(rootStyles.getPropertyValue('--btr-frame-width')) || 240;
	  }
	  
	  const centerStart = containerWidth + offset + 0.5 * frameWidth;
	  const centerStop = 0.5 * containerWidth;
	  const startLeft = centerStart - 0.5 * frameWidth;
	  const stopLeft  = centerStop - 0.5 * frameWidth;
	  
	  const keyframesText = `
		@keyframes btrMoveDynamicBattle {
		  0%   { left: ${startLeft}px; }
		  20%  { left: ${stopLeft}px; }
		  60%  { left: ${stopLeft}px; }
		  100% { left: ${startLeft}px; }
		}
	  `;
	  
	  let styleElem = document.getElementById("btrKeyframesBattle");
	  if (!styleElem) {
		styleElem = document.createElement("style");
		styleElem.id = "btrKeyframesBattle";
		document.head.appendChild(styleElem);
	  }
	  styleElem.textContent = keyframesText;
	  
	  // 创建动画容器
	  battleBTRWrapper = document.createElement("div");
	  battleBTRWrapper.className = "btr-wrapper";
	  battleBTRWrapper.style.position = "absolute";
	  battleBTRWrapper.style.top = "25%";
	  battleBTRWrapper.style.left = startLeft + "px";
	  battleBTRWrapper.style.animation = "btrMoveDynamicBattle 10s ease-in-out forwards";
	  
	  let spriteElem;
	  if (useT80) {
		const frameContainer = document.createElement("div");
		frameContainer.className = "frameContainer";
		frameContainer.style.width = frameWidth + "px";
		frameContainer.style.height = rootStyles.getPropertyValue('--btr-frame-height') || "120px";
		frameContainer.style.overflow = "hidden";
		
		spriteElem = document.createElement("div");
		spriteElem.className = "t80-animation";
		spriteElem.style.backgroundPosition = "0px 0";
		
		frameContainer.appendChild(spriteElem);
		battleBTRWrapper.appendChild(frameContainer);
		
		// 启动T-80空闲动画
		startT80IdleAnimation(spriteElem);
	  } else {
		// BTR动画保持不变
		spriteElem = document.createElement("div");
		spriteElem.className = "btr-animation";
		battleBTRWrapper.appendChild(spriteElem);
	  }
  
		container.appendChild(battleBTRWrapper);
	  
	  // 上传事件到Firebase
	  uploadBattleBTREvent(battleBTRType);
	  
	  // 启动特殊攻击
	  startBattleBTRSpecialAttack();
	  
	  battleBTRActive = true;
	  if (useT80) {
		setTimeout(() => {
		// 修复：传递spriteElem参数
		triggerBattleT80Cannon(spriteElem);
		}, 1000);
	  }
	  
	  // 10秒后清理
	  setTimeout(() => {
		if (container.contains(battleBTRWrapper)) {
		  container.removeChild(battleBTRWrapper);
		  battleBTRWrapper = null;
		}
		
		if (useT80 && t80IdleInterval) {
		  clearInterval(t80IdleInterval);
		  t80IdleInterval = null;
		}
		
		if (battleBTRInterval) {
		  clearInterval(battleBTRInterval);
		  battleBTRInterval = null;
		}
		
		battleBTRActive = false;
	  }, 10000);
	}

	// 3. 上传BTR事件到Firebase
	function uploadBattleBTREvent(type) {
	  if (!window.currentBattleRoom) return;
	  
	  const eventData = {
		type: type,
		senderRole: window.myRole,
		timestamp: Date.now()
	  };
	  
	  const eventRef = firebase.database().ref("battles")
		.child(window.currentBattleRoom)
		.child("btrEvents");
	  
	  eventRef.push(eventData);
	}

	// 4. 监听敌方BTR事件
	function listenForEnemyBTR() {
	  if (!window.currentBattleRoom) return;
	  
	  const eventRef = firebase.database().ref("battles")
		.child(window.currentBattleRoom)
		.child("btrEvents");
	  
	  eventRef.off("child_added");
	  eventRef.on("child_added", snapshot => {
		const event = snapshot.val();
		
		// 忽略自己发送的事件
		if (event.senderRole === window.myRole) return;
		
		// 在敌方区域显示动画
		showEnemyVehicleAnimation(event);
	  });
	}

	// 5. 在敌方区域显示车辆动画
	function showEnemyVehicleAnimation(event) {
	  const enemyAnim = document.getElementById("battleEnemyAnim");
	  if (!enemyAnim) return;
	  
	  const containerWidth = enemyAnim.clientWidth;
	  const offset = 50;
	  const rootStyles = getComputedStyle(document.documentElement);
	  
	  let frameWidth;
	  if (event.type === "t80") {
		frameWidth = 480;
	  } else {
		frameWidth = parseFloat(rootStyles.getPropertyValue('--btr-frame-width')) || 240;
	  }
	  
	  // 修复：敌方动画从右向左移动
	  const startRight = containerWidth + offset + 0.5 * frameWidth;
	  const stopRight = 0.5 * containerWidth - 0.5 * frameWidth;
	  
	  const keyframesText = `
		@keyframes btrMoveDynamicBattleEnemy {
		  0%   { left: ${startRight}px; }
		  20%  { left: ${stopRight}px; }
		  60%  { left: ${stopRight}px; }
		  100% { left: ${containerWidth + offset}px; }
		}
	  `;
	  
	  let styleElem = document.getElementById("btrKeyframesBattleEnemy");
	  if (!styleElem) {
		styleElem = document.createElement("style");
		styleElem.id = "btrKeyframesBattleEnemy";
		document.head.appendChild(styleElem);
	  }
	  styleElem.textContent = keyframesText;
	  
	  // 创建动画容器
	  const enemyWrapper = document.createElement("div");
	  enemyWrapper.className = "btr-wrapper enemy";
	  enemyWrapper.style.position = "absolute";
	  enemyWrapper.style.top = "25%";
	  enemyWrapper.style.left = startRight + "px";
	  enemyWrapper.style.animation = "btrMoveDynamicBattleEnemy 10s ease-in-out forwards";
	  
	  let spriteElem;
	  if (event.type === "t80") {
		// T-80动画
		const frameContainer = document.createElement("div");
		frameContainer.className = "frameContainer";
		frameContainer.style.width = frameWidth + "px";
		frameContainer.style.height = rootStyles.getPropertyValue('--btr-frame-height') || "120px";
		frameContainer.style.overflow = "hidden";
		
		spriteElem = document.createElement("div");
		spriteElem.className = "t80-animation";
		const t80URL = window.opponentT80Sprite ? window.opponentT80Sprite : "default_t80.png";
		spriteElem.style.backgroundImage = "url('" + t80URL + "')";
		spriteElem.style.backgroundPosition = "0px 0";
		
		frameContainer.appendChild(spriteElem);
		enemyWrapper.appendChild(frameContainer);
		
		// 启动空闲动画
		startT80IdleAnimation(spriteElem);
		
		// ===== 修复1：声明并初始化冷却状态变量 =====
		let enemyT80CannonOnCooldown = false;
		
		// ===== 修复2：确保使用正确的空闲动画函数 =====
		const startLocalIdleAnimation = (sprite) => {
		  // 确保idle定時器不存在
		  if (window.enemyT80IdleInterval) clearInterval(window.enemyT80IdleInterval);
		  window.enemyT80IdleToggle = false;
		  // 初始設為第1幀
		  sprite.style.backgroundPosition = "0px 0";
		  window.enemyT80IdleInterval = setInterval(() => {
			// 使用 toggle 變數進行交替
			window.enemyT80IdleToggle = !window.enemyT80IdleToggle;
			// 第1幀： "0px 0"；第4幀： -1440px 0（因為 3*480 = 1440）
			sprite.style.backgroundPosition = window.enemyT80IdleToggle ? "-1440px 0" : "0px 0";
		  }, 250);
		};
		
		const triggerEnemyT80Cannon = () => {
		  if (enemyT80CannonOnCooldown) return;
		  enemyT80CannonOnCooldown = true;
		  
		  // 停止空闲动画
		  if (window.enemyT80IdleInterval) {
			clearInterval(window.enemyT80IdleInterval);
			window.enemyT80IdleInterval = null;
		  }
		  
		  // 播放开炮动画序列
		  spriteElem.style.backgroundPosition = "0px 0"; // frame1
		  setTimeout(() => { spriteElem.style.backgroundPosition = "-480px 0"; }, 250); // frame2
		  setTimeout(() => { spriteElem.style.backgroundPosition = "-960px 0"; }, 500); // frame3
		  setTimeout(() => { spriteElem.style.backgroundPosition = "-1440px 0"; }, 750); // frame4
		  
		  // 1秒后恢复空闲帧
		  setTimeout(() => {
			if (spriteElem && spriteElem.parentNode) {
			  spriteElem.style.backgroundPosition = "0px 0";
			  startLocalIdleAnimation(spriteElem); // 使用修复后的空闲动画函数
			}
			enemyT80CannonOnCooldown = false;
		  }, 1000);
		};
		
		// ===== 修复3：确保正确启动开炮循环 =====
		// 启动开炮循环
		setTimeout(() => {
		  triggerEnemyT80Cannon(); // 首次开炮
		  
		  // 每4.25秒开炮一次
		  const cannonInterval = setInterval(() => {
			if (enemyAnim.contains(enemyWrapper)) {
			  triggerEnemyT80Cannon();
			} else {
			  clearInterval(cannonInterval); // 动画元素已移除时停止
			}
		  }, 4250);
		}, 1000); // 延迟1秒开始
		
	  } else {
		// BTR动画
		spriteElem = document.createElement("div");
		spriteElem.className = "btr-animation";
		const btrURL = window.opponentBtrSprite ? window.opponentBtrSprite : "default_btr.png";
	    spriteElem.style.backgroundImage = "url('" + btrURL + "')";
		enemyWrapper.appendChild(spriteElem);
	  }
	  
	  enemyAnim.appendChild(enemyWrapper);
	  
	  // 10秒后清理
	  setTimeout(() => {
		if (enemyAnim.contains(enemyWrapper)) {
		  enemyAnim.removeChild(enemyWrapper);
		}
		// 清理空闲动画定时器
		if (window.enemyT80IdleInterval) {
		  clearInterval(window.enemyT80IdleInterval);
		  window.enemyT80IdleInterval = null;
		}
	  }, 10000);
	}

	// 6. 启动特殊攻击
	function startBattleBTRSpecialAttack() {
	  if (!battleModeActive || battleEnded || !battleMatched) return;
	  if (battleBTRInterval) clearInterval(battleBTRInterval);
	  
	  // 立即执行第一次攻击
	  triggerBattleBTRSpecialAttack();
	  
	  // 之后每5秒执行一次
	  battleBTRInterval = setInterval(() => {
		triggerBattleBTRSpecialAttack();
	  }, 5000);
	}

	// 7. 执行特殊攻击
	function triggerBattleBTRSpecialAttack() {
	  if (battleEnded) return;
	  if (!battleBTRActive) return;
	    
	  const centerBuilding = gameState.buildings.find(b => 
		b && b.type.toLowerCase() === "center"
	  );
	  const centerLevel = centerBuilding ? centerBuilding.level : 1;
	  const baseHitChance = 40;
	  const hitChanceVal = Math.min(baseHitChance + centerLevel * 0.5, 85);
	  
	  const hitRoll = Math.random() * 100;
	  const baseDamage = battleBTRType === "t80" ? 
		  Math.floor(Math.random() * 20) + 15 :  // T-80伤害15-35
		  Math.floor(Math.random() * 15) + 10;     // BTR伤害10-25

	  // 從全局 gameState.buildings 中查找拖拉機廠（armoredgarage）的等級
	  let tractorLevel = 0;
	  if (window.gameState && window.gameState.buildings) {
		  const tractor = window.gameState.buildings.find(b => 
			  b && b.type.toLowerCase() === "armoredgarage"
		  );
		  if (tractor) {
		     tractorLevel = tractor.level;
		  }
	  }

	  // 每級0.5%的加成：倍率 = 1 + (拖拉機廠等級 × 0.005)
	  const multiplier = 1 + tractorLevel * 0.005;

	  // 根據倍率調整最終傷害，並取整（四捨五入）
	  const damage = Math.round(baseDamage * multiplier);
	  
	  const hitSuccess = hitRoll < hitChanceVal;
	  
	  if (hitSuccess) {
	    totalEnemyDamage += damage;
		
	    let type = battleBTRType === "t80" ? "t80" : "btr";
		  // 從對應詞庫中獲取一個隨機短語
		  let phrase = getRandomPhrase(type);
		  
		  // 上傳攻擊日志，使用隨機短語來描述事件
		  const attackMessage = `${phrase}（命中），對方僵尸-${damage}`;
		  pushBattleLog(attackMessage);

		  // 如果是 T-80 事件，觸發開炮動畫
		  if (battleBTRType === "t80") {
			triggerBattleT80Cannon();
		  }
		} else {
		  // 未命中時也同樣隨機採用對應詞庫中的描述
		  let type = battleBTRType === "t80" ? "t80" : "btr";
		  let phrase = getRandomPhrase(type);
		  const missMessage = `${phrase}（未命中）`;
		  pushBattleLog(missMessage);
		}
	  
	  // 上传攻击结果到Firebase
	  uploadBattleBTRAttack({
		type: battleBTRType,
		hit: hitSuccess,
		damage: hitSuccess ? damage : 0,
		timestamp: Date.now(),
		senderRole: window.myRole
	  });
	}

	// 8. 上传攻击结果
	function uploadBattleBTRAttack(attackData) {
	  if (!window.currentBattleRoom) return;
	  
	  const attackRef = firebase.database().ref("battles")
		.child(window.currentBattleRoom)
		.child("btrAttacks");
	  
	  attackRef.push(attackData);
	}

	// 9. 监听敌方攻击
	function listenForEnemyBTRAttacks() {
	  if (!window.currentBattleRoom) return;
	  
	  const attackRef = firebase.database().ref("battles")
						.child(window.currentBattleRoom)
						.child("btrAttacks");
	  
	  attackRef.off("child_added");
	  attackRef.on("child_added", function(snapshot) {
	    if (battleEnded) return;
		const attack = snapshot.val();
		
		// 忽略自己发送的攻击
		if (attack.senderRole === window.myRole) return;
		
		if (attack.hit) {
		  totalSelfDamage += attack.damage;
		}
	  });
	}

	// 10. T-80开炮动画（对战模式简化版）
	function triggerBattleT80Cannon(sprite) {
	  if (!sprite) return;
	  
	  // 修复：使用主文件中的开炮逻辑
	  if (window.t80CannonOnCooldown) return;
	  window.t80CannonOnCooldown = true;
	  
	  // 停止idle定时器
	  if (window.t80IdleInterval) {
		clearInterval(window.t80IdleInterval);
		window.t80IdleInterval = null;
	  }
	  
	  // 播放完整开炮动画序列（主文件逻辑）
	  sprite.style.backgroundPosition = "0px 0"; // frame1
	  setTimeout(() => { sprite.style.backgroundPosition = "-480px 0"; }, 250); // frame2
	  setTimeout(() => { sprite.style.backgroundPosition = "-960px 0"; }, 500); // frame3
	  setTimeout(() => { sprite.style.backgroundPosition = "-1440px 0"; }, 750); // frame4
	  
	  // 1秒后恢复空闲帧
	  setTimeout(() => {
		sprite.style.backgroundPosition = "0px 0"; 
		// 重新启动idle动画
		startT80IdleAnimation(sprite);
	  }, 1000);
	  
	  // 冷却后允许再次开炮
	  setTimeout(() => {
		window.t80CannonOnCooldown = false;
		if (battleBTRActive) {
		  triggerBattleT80Cannon(sprite);
		}
	  }, 4250);
	}

	function handleBattleEvent(eventData) {
	  // 忽略自己发送的事件
	  if (eventData.senderRole === window.myRole) return;
	  
	  // 根据事件类型处理
	  switch (eventData.type) {
		case "btr":
		case "t80":
		  // 在右侧显示敌方动画
		  showEnemyVehicleAnimation(eventData);
		  break;
	  }
	}

	function startBattleTimer() {
	  let remaining = battleDuration;
	  battleInterval = setInterval(function(){
		if (remaining <= 0) {
		  clearInterval(battleInterval);
		  battleInterval = null;
		} else {
		  triggerBattleEvent();
		  remaining -= 5;
		}
	  }, 5000);
	}


	// 添加系统消息推送函数（确保使用正确）
	function pushSystemMessage(message) {
	  const data = {
		sender: "系統",
		senderRole: "system",
		message: message
	  };
	  
	  appendBattleLogEntry(data);
	  
	  // 如果需要同步到对方，上传到Firebase
	  if (window.currentBattleRoom) {
		const logRef = firebase.database().ref("battles")
							  .child(window.currentBattleRoom)
							  .child("log");
		logRef.push(data);
	  }
	}

	window.battleMode = {
        enter: enterBattleMode,
        exit: exitBattleMode
    };
	document.getElementById("battleStartBtn").addEventListener("click", function(){
        if(initializeUser()){
          startBattleModeFirebase();
        }
      });
	document.getElementById("explorationAnim").addEventListener("dblclick", function(e) {
	  battleMode.enter();
	});
	document.getElementById("encounterBattleBtn").addEventListener("click", function() {
	  battleMode.enter();
	});

    })();

	// 用本地 unlockedAchievements 生成一个称号集合
	function syncAchievements() {
	  const set = new Set();
	  // 我們遍歷 unlockedAchievements 這個全局變量
	  unlockedAchievements.forEach(a => {
		if (a.title) {
		  // 進行 Unicode 正規化、轉小寫並修剪空格
		  set.add(a.title.normalize("NFC").toLowerCase().trim());
		}
	  });
	  return set;
	}

  (function(){
    // ──────────────────────────────
    // 模塊內定義精靈圖數據：原有的僵尸精靈圖與新增的裝甲系列
    const zombieSpriteOptions = [
      { src: "images/zombie_search_sprite.png", unlock: true },
      { src: "images/zombie_search_sprite_helmet.png", unlock: "Алтын" },
      { src: "images/zombie_search_sprite_btr.png", unlock: "報話機" },
      { src: "images/zombie_search_sprite_equipped.png", unlock: "武裝通信兵" },
      { src: "images/zombie_search_sprite_svd.png", unlock: "拾荒高手" },
      { src: "images/zombie_search_sprite_svd_b.png", unlock: "清空貨架！" },
	  { src: "images/zombie_search_sprite_svd_h.png", unlock: "物資收集者" },
      { src: "images/zombie_search_sprite_elite.png", unlock: "全副武裝" },
      { src: "images/zombie_search_sprite_pkm_e.png", unlock: "裝甲猛虎" },
      { src: "images/zombie_search_sprite_pkm_m.png", unlock: "銅墻鐵壁" },
	  { src: "images/zombie_search_sprite_pkm_ms.png", unlock: "堅不可摧" },
    ];
    const btrSpriteOptions = [
      { src: "images/btr_sprite_80.png", unlock: true },
	  { src: "images/btr_sprite_80_a.png", unlock: "尸坦協同" },
      { src: "images/btr_sprite_80_mg.png", unlock: "機炮仙人" },
    ];
    const t80SpriteOptions = [
      { src: "images/t-80_sprite.png", unlock: true },
      { src: "images/t-80_sprite_u.png", unlock: "裝甲猛虎" },
	  { src: "images/t-80_sprite_um.png", unlock: "裝甲大軍" },
    ];
    
    // ──────────────────────────────
    // 全局精靈圖變量初始化，從 localStorage 讀取；如無則採用默認值
    window.currentZombieSprite = localStorage.getItem("currentZombieSprite") || "images/zombie_search_sprite.png";
    window.currentBtrSprite = localStorage.getItem("currentBtrSprite") || "images/btr_sprite.png";
    window.currentT80Sprite = localStorage.getItem("currentT80Sprite") || "images/t-80_sprite.png";
    
    // ──────────────────────────────
    // 覆蓋CSS規則函數：當用戶選定 T‑80 裝甲精靈圖後，更新 head 中的規則
   function overrideT80SpriteCSS() {
	  const spritePath = localStorage.getItem("currentT80Sprite") || "images/t-80_sprite.png";
	  let styleEl = document.getElementById("t80OverrideStyle");
	  
	  if (!styleEl) {
		styleEl = document.createElement("style");
		styleEl.id = "t80OverrideStyle";
		document.head.appendChild(styleEl);
	  }

	  // 排除敌方窗口的覆盖
	  styleEl.innerHTML = `
		.t80-animation:not(#battleEnemyAnim *) {
		  background-image: url('${spritePath}') !important;
		}
	  `;

	  let styleEl2 = document.getElementById("btrOverrideStyle");
	  if (!styleEl2) {
		styleEl2 = document.createElement("style");
		styleEl2.id = "btrOverrideStyle";
		document.head.appendChild(styleEl2);
	  }

	  const btrPath = localStorage.getItem("currentBtrSprite") || "images/btr_sprite.png";
	  
	  // 排除敌方窗口的覆盖
	  styleEl2.innerHTML = `
		.btr-animation:not(#battleEnemyAnim *) {
		  background-image: url('${btrPath}') !important;
		}
	  `;
	}
    
    // 每次更新用戶選擇後調用覆蓋函數以保證 css 覆蓋生效
    overrideT80SpriteCSS();
    
    // ──────────────────────────────
     function isSpriteUnlocked(option) {
		// 如果 unlock 為 true，表示始終可用
		if(option.unlock === true) return true;
		
		// 先對 item.unlock 進行正規化處理：
		let need = "";
		if (typeof option.unlock === "string") {
		  need = option.unlock.normalize("NFC").toLowerCase().trim();
		}
		// 通常你也可能定義 "default" 為可用
		if (need === "default") return true;

		// 獲取同步後的稱號庫
		const unlockedSet = syncAchievements();
		return unlockedSet.has(need);
	  }
    
    // ──────────────────────────────
    // 更新動畫窗口中僵尸精靈圖的函數（僵尸系列）
    function updateZombieSearchSprite(){
      const zombieElem = document.querySelector(".zombie-search");
      if (!zombieElem) return;
      zombieElem.style.backgroundImage = "url('" + window.currentZombieSprite + "')";
    }
    // 更新對戰模式中己方動畫窗口。這裡不進行判斷，僅供參考：如果對戰模式的T‑80動畫元素生成時
    // 已經採用 CSS 覆蓋規則，那麼這裡就不必另外設置。
    function updateBattleZombieSearchSprite(){
      const battleZombieElem = document.querySelector("#battleSelfAnim .zombie-search");
      if (!battleZombieElem) return;
      // 由於T‑80動畫將依靠 CSS 覆蓋，所以這裡可以不做修改，或者強制書寫：
      battleZombieElem.style.backgroundImage = "url('" + window.currentT80Sprite + "')";
    }
    
    // ──────────────────────────────
    // 渲染原有的僵尸衣櫥分頁：使用 zombieSpriteOptions
    function renderWardrobeTab(){
      const container = document.getElementById("wardrobeContent");
      container.innerHTML = "";
      zombieSpriteOptions.forEach(function(option){
        const card = document.createElement("div");
        card.className = "wardrobe-card";
        const thumb = option.src.replace(/(\.\w+)$/, "_card$1");
        card.style.backgroundImage = "url('" + thumb + "')";
        if (!isSpriteUnlocked(option)){
          card.classList.add("locked");
        }
        if (option.src === window.currentZombieSprite){
          card.classList.add("selected");
          const label = document.createElement("div");
          label.className = "label";
          label.textContent = "使用中";
          card.appendChild(label);
        }
        card.addEventListener("click", function(){
          if (!isSpriteUnlocked(option)) return;
          document.querySelectorAll(".wardrobe-card.selected").forEach(function(el){
            el.classList.remove("selected");
            const lab = el.querySelector(".label");
            if (lab) lab.remove();
          });
          card.classList.add("selected");
          const label = document.createElement("div");
          label.className = "label";
          label.textContent = "使用中";
          card.appendChild(label);
          window.currentZombieSprite = option.src;
          localStorage.setItem("currentZombieSprite", window.currentZombieSprite);
          updateZombieSearchSprite();
          updateBattleZombieSearchSprite();
        });
        container.appendChild(card);
      });
    }
    
    // ──────────────────────────────
    // 渲染裝甲系列衣櫥：根據 mode ("btr" 或 "t80") 播放對應卡片
    function renderArmorSprites(mode){
      const container = document.getElementById("armorSprites");
      container.innerHTML = "";
      let optionsArray = (mode === "btr") ? btrSpriteOptions : t80SpriteOptions;
      optionsArray.forEach(function(option){
        const card = document.createElement("div");
        card.className = "wardrobe-card";
        const thumb = option.src.replace(/(\.\w+)$/, "_card$1");
        card.style.backgroundImage = "url('" + thumb + "')";
        if (!isSpriteUnlocked(option)){
          card.classList.add("locked");
        }
        if (mode === "btr" && option.src === window.currentBtrSprite){
          card.classList.add("selected");
          const label = document.createElement("div");
          label.className = "label";
          label.textContent = "使用中";
          card.appendChild(label);
        }
        if (mode === "t80" && option.src === window.currentT80Sprite){
          card.classList.add("selected");
          const label = document.createElement("div");
          label.className = "label";
          label.textContent = "使用中";
          card.appendChild(label);
        }
        card.addEventListener("click", function(){
          if (!isSpriteUnlocked(option)) return;
          document.querySelectorAll("#armorSprites .wardrobe-card.selected").forEach(function(el){
            el.classList.remove("selected");
            const lab = el.querySelector(".label");
            if (lab) lab.remove();
          });
          card.classList.add("selected");
          const label = document.createElement("div");
          label.className = "label";
          label.textContent = "使用中";
          card.appendChild(label);
          if (mode === "btr"){
            window.currentBtrSprite = option.src;
            localStorage.setItem("currentBtrSprite", window.currentBtrSprite);
          } else if (mode === "t80"){
            window.currentT80Sprite = option.src;
            localStorage.setItem("currentT80Sprite", window.currentT80Sprite);
          }
          // 覆蓋 CSS 規則，以便對戰動畫使用最新精靈圖
          overrideT80SpriteCSS();
          updateZombieSearchSprite();
          updateBattleZombieSearchSprite();
        });
        container.appendChild(card);
      });
    }
    
    // ──────────────────────────────
    // 衣櫃模式模塊：分頁切換及顯示邏輯
    (function(){
      const wardrobeOverlay = document.getElementById("wardrobeOverlay");
      const wardrobeModal = document.getElementById("wardrobeModal");
      const wardrobeContent = document.getElementById("wardrobeContent");
      const tabZombie = document.getElementById("tabZombie");
      const tabArmor = document.getElementById("tabArmor");
      
      tabZombie.addEventListener("click", function(){
        tabZombie.classList.add("active");
        tabArmor.classList.remove("active");
        wardrobeContent.innerHTML = "";
        renderWardrobeTab();
      });
      
      tabArmor.addEventListener("click", function(){
        tabArmor.classList.add("active");
        tabZombie.classList.remove("active");
        wardrobeContent.innerHTML = `
          <div id="armorTabs" style="display: flex; justify-content: center; margin-bottom: 1em;">
            <button id="armorTabBTR" class="active" style="flex: 1;">BTR</button>
            <button id="armorTabT80" style="flex: 1;">T‑80</button>
          </div>
          <div id="armorSprites" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;"></div>
        `;
        document.getElementById("armorTabBTR").addEventListener("click", function(){
          this.classList.add("active");
          document.getElementById("armorTabT80").classList.remove("active");
          renderArmorSprites("btr");
        });
        document.getElementById("armorTabT80").addEventListener("click", function(){
          this.classList.add("active");
          document.getElementById("armorTabBTR").classList.remove("active");
          renderArmorSprites("t80");
        });
        // 初始默認渲染 BTR 系列
        renderArmorSprites("btr");
      });
      
      window.showWardrobeMode = function(){
        wardrobeOverlay.style.display = "block";
        tabZombie.classList.add("active");
        tabArmor.classList.remove("active");
        renderWardrobeTab();
      };
      window.hideWardrobeMode = function(){
        wardrobeOverlay.style.display = "none";
      };
      
      const wardrobeBtn = document.getElementById("wardrobeBtn");
      if (wardrobeBtn) {
        wardrobeBtn.addEventListener("click", function(){
          window.showWardrobeMode();
        });
      }
      const closeBtn = document.getElementById("wardrobeCloseBtn");
      if (closeBtn) {
        closeBtn.addEventListener("click", function(){
          window.hideWardrobeMode();
        });
      }
      wardrobeOverlay.addEventListener("click", function(e){
          if (e.target === wardrobeOverlay) {
            window.hideWardrobeMode();
          }
      });
      wardrobeModal.addEventListener("click", function(e){
        e.stopPropagation();
      });
    })();
    
  })();


/* PVE模式 - 末日控制中心擴展模塊 - San1tater - 2025-06-24 17:57:16 */
(function(){
  function updatePlayerSpriteToDead(role) {
    const deadSprite = 'images/zombie_dead_sprite.png';
    const el = document.getElementById(`zombie-${role}`);
    if (el) {
      el.style.backgroundImage = `url('${deadSprite}')`;
    }
  }
  // 確保 Firebase 已初始化
  if (!window.firebase || !window.firebase.database) {
    return;
  }


  // ======== 1. 全局變量定義 ========
  let pveActive = false;
  let pveMatched = false;
  let pveInterval = null;
  let bossAttackInterval = null;
  let bossHp = 0;
  let bossMaxHp = 0;
  let playerHp = 0;
  let playerMaxHp = 0;
  let playerIsDown = false;
  let totalPlayerDamage = 0;
  let pveEnded = false;
  let selectedBoss = "zombieKing"; 
  let pveMode = "solo"; 
  let battleBTRType = "";
  let battleBTRActive = false;      // BTR/T80是否在場標志
  let battleBTREventTimer = null;   // BTR事件觸發計時器
  let battleBTRInterval = null;     // BTR攻擊間隔計時器
  let t80IdleInterval = null;       // T80閒置動畫計時器
  let t80CannonTimeout = null;      // T80開炮動畫計時器
  let t80CannonOnCooldown = false;  // T80開炮冷卻標志
  let currentBattleRoomRef = null;  // Firebase 房間參考
  let processedMessages = {};       // 用於防止訊息重複顯示
  let latestRoomData = null;
  
  // BOSS配置
  const bossConfigs = {
    "zombieKing": {
      name: "BTR-80A 「守護者」",
      hp: 1000,
      damageRange: {min: 25, max: 75},
      attackInterval: 7000, 
      singleAttackRate: 0.7,
	  hitChance: 75,
      sprite: "images/boss_zombie_king_sprite.png", 
      frames: 4,  // 精靈圖幀數
      frameWidth: 200, // 每幀寬度
      rewards: {
        food: 1000000,
        materials: 3000000,
        weapons: 5000000,
        tech: 3000000
      },
      attackPhrases: {
        single: [
          "使用30mm混合彈鏈[AP+HE+API]，狂暴射擊",
          "使用30mm曳光彈鏈[AP-T+API+HE-T]，嘗試鎖定",
          "使用30mm穿燃彈鏈[API]，試圖引燃",
		  "使用30mm穿甲彈鏈[AP]，專注破壞"
        ],
        aoe: [
          "使用30mm高爆彈鏈[HE]，覆蓋射擊",
          "釋放引擎煙霧，籠罩戰場",
          "將引擎調到最大功率，橫衝直撞"
        ]
      }
    },
  };
  
  // 攻擊詞庫
  const pveAttackPhrases = {
    normal: [
      "僵尸自信地打出一個長點射",
      "僵尸使用單發點射，進行精確射擊",
      "僵尸克制地打出兩個短點射",
      "僵尸把槍舉過頭頂，亂射一通",
      "僵尸調到全自動，進行壓制射擊"
    ],
    btr: [
      "BTR-80使用30mm高爆彈鏈[HE]，實施火力支援",
      "BTR-80使用30mm混合彈鏈[AP+HE+API]，展開火力覆蓋",
      "BTR-80使用30mm對空彈鏈[API+HE+AP-T]，展開精準射擊",
      "BTR-80使用30mm穿甲彈鏈[AP]，展開集中射擊",
      "BTR-80使用30mm曳光彈鏈[AP-T+API+HE-T]，進行威懾射擊",
      "BTR-80使用30mm穿燃彈鏈[API]，展開壓制射擊"
    ],
    t80: [
      "T-80使用12.7mm高射機槍[7n34]，展開精確點射",
      "T-80使用125mm高爆彈[3OF26]，實施覆蓋射擊",
      "T-80使用125mm高爆彈[3OF26]，實施弱點破壞",
      "T-80使用125mm穿甲彈[3BM42]，實施一般貫穿射擊",
      "T-80採用125mm穿甲彈[3BM60]，實施強勢貫穿射擊",
      "T-80使用125mm破甲彈[3BK18M]，實施破壞射擊",
      "T-80使用125mm破甲彈[3BK18M]，實施削弱射擊"
    ]
  };

  // ======== 2. 事件綁定 ========
  document.addEventListener('DOMContentLoaded', function() {
    // 模式選擇
    const modeSelect = document.getElementById('battleModeSelect');
    if (modeSelect) {
      modeSelect.addEventListener('change', handleModeChange);
    }
    
    // BOSS選擇
    const bossList = document.getElementById('bossList');
    if (bossList) {
      bossList.addEventListener('change', function() {
        selectedBoss = this.value;
      });
    }
    
    // PVE模式選擇
    const pveModeSelect = document.getElementById('pveModeSelect');
    if (pveModeSelect) {
      pveModeSelect.addEventListener('change', function() {
        pveMode = this.value;
      });
    }
    
    // 開始按鈕
    const startBtn = document.getElementById('battleStartBtn');
    if (startBtn) {
      startBtn.addEventListener('click', function(e) {
        const modeSelect = document.getElementById('battleModeSelect');
        if (modeSelect && modeSelect.value === 'pve') {
          startPveBattle();
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      });
    }
    
    // 退出按鈕
    const exitBtn = document.getElementById('battleExitBtn');
    if (exitBtn) {
      exitBtn.addEventListener('click', function(e) {
        if (pveActive) {
          exitPveBattle();
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      });
    }
  });
  
  function handleModeChange() {
    const bossList = document.getElementById('bossList');
    const pveModeSelect = document.getElementById('pveModeSelect');
    
    if (this.value === 'pve') {
      bossList.style.display = 'inline-block';
      pveModeSelect.style.display = 'inline-block';
    } else {
      bossList.style.display = 'none';
      pveModeSelect.style.display = 'none';
    }
  }
  
  // ======== 3. 核心功能 ========
  
  // 添加必要的CSS樣式
  function addPveStyles() {
    if (document.getElementById('pve-styles')) return;
    
    const styleSheet = document.createElement('style');
    styleSheet.id = 'pve-styles';
    styleSheet.textContent = `
      .health-bar {
        width: 100%;
        height: 20px;
        background: #333;
        border-radius: 5px;
        margin-bottom: 0px;
        overflow: hidden;
        position: relative;
      }
      
      .health-fill {
        height: 100%;
        background: var(--health-color, green);
        width: 100%;
        transition: width 0.5s;
      }
      
      .boss-health-fill {
        background: var(--boss-health-color, red);
      }
      
      .health-text {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        text-align: center;
        line-height: 20px;
        font-size: 12px;
        font-weight: bold;
        color: white;
        text-shadow: 0 0 2px black;
      }
      
      .boss-animation {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        width: var(--boss-frame-width);
        height: var(--boss-frame-height);
        background-image: url(var(--boss-sprite-url));
        background-size: var(--boss-sprite-total-width) var(--boss-frame-height);
        background-repeat: no-repeat;
        animation: bossSearchAnim 1.5s steps(4) infinite;
      }
      
      @keyframes bossSearchAnim {
        from { background-position: 0 0; }
        to { background-position: calc(-1 * var(--boss-sprite-total-width)) 0; }
      }
      
      @keyframes bossPulse {
        0% { transform: translateX(-50%) scale(1); }
        50% { transform: translateX(-50%) scale(1.05); }
        100% { transform: translateX(-50%) scale(1); }
      }
      
      .boss-animation.attack {
        animation: bossPulse 0.5s ease-in-out;
      }
      
      .pve-background {
        background-image: url('images/location_day_1.png');
        background-repeat: repeat-x;
        background-size: auto 100%;
        background-position: center top;
        animation: pveBgScroll 30s linear infinite;
      }
      
      @keyframes pveBgScroll {
        0% { background-position: 0 top; }
        100% { background-position: -1000px top; }
      }
      
      /* 修改容器佈局，將健康條放在底部 */
      .battle-half {
        display: flex;
        flex-direction: column;
        height: 100%;
      }
      
      .battle-inner {
        flex: 1;
        position: relative;
        overflow: hidden;
      }
      
      .health-bars-container {
        padding: 5px;
        background: rgba(0,0,0,0.5);
      }
      
      /* 合作模式血条样式 */
      .coop-health-container {
        display: flex;
        justify-content: space-between;
        gap: 8px;
      }
      
      .coop-health-bar {
        width: calc(50% - 4px); /* 减去间隔的一半 */
        margin-bottom: 0;
      }
      
      .player-down .health-fill {
        background: #888 !important; /* 灰色表示倒地 */
      }
      
      .player-down .health-text {
        color: #ff6666;
        font-weight: bold;
      }
      
      /* 合作模式玩家B位置调整 */
		#zombie-userA, #zombie-userB {
		  position: absolute !important;
		  bottom: 20% !important;
		  top: auto !important;
		  margin-bottom: 0 !important;
		  transform: none !important; /* 移除所有翻转 */
		}
		
		/* userA位置 */
		#zombie-userA {
		  left: 50% !important;
		  transform: translateX(-50%) !important; /* 居中 */
		}
		
		/* userB位置 */
		#zombie-userB {
		  left: 60% !important;
		  right: auto !important;
		}
		
		/* 标签样式统一 */
		.player-name-tag {
		  position: absolute !important;
		  top: -20px !important;
		  bottom: auto !important;
		  width: 100% !important;
		  text-align: center !important;
		  color: #fff !important;
		  font-size: 12px !important;
		  text-shadow: 0 0 2px #000 !important;
		  transform: scaleX(-1) !important;
		}
    `;
    
    document.head.appendChild(styleSheet);
  }
  
  // 初始化PVE戰鬥
  function initPveBattle() {
    if (!pveActive) return;
    
    addPveStyles();
    
    const bossConfig = bossConfigs[selectedBoss];
    if (!bossConfig) return;
    
    // 設置背景和動畫
    setupBattleAnimation();
    
    // 修改：先設置健康條容器，再添加生命條和BOSS
    addHealthBarsContainers();
    addHealthBarsAndBoss();
    
    // 開始戰鬥循環
    startCombatLoop();
    
    // 清除已處理消息記錄
    processedMessages = {};
    
    // 推送戰鬥開始消息
    appendBattleLogEntry({
      sender: "系統",
      senderRole: "system",
      message: `戰鬥開始！挑戰 ${bossConfig.name}！`,
      battleMode: "pve"
    });
  }
  
  // 添加健康條容器
  function addHealthBarsContainers() {
    const selfContainer = document.querySelector('.battle-half.left');
    const enemyContainer = document.querySelector('.battle-half.right');
    
    if (!selfContainer || !enemyContainer) return;
    
    // 创建健康条容器 - 清除可能已存在的
    const existingPlayerContainer = document.getElementById('player-health-container');
    if (existingPlayerContainer) {
      existingPlayerContainer.remove();
    }
    
    const existingBossContainer = document.getElementById('boss-health-container');
    if (existingBossContainer) {
      existingBossContainer.remove();
    }
    
    // 新建容器
    const playerHealthContainer = document.createElement('div');
    playerHealthContainer.id = 'player-health-container';
    playerHealthContainer.className = 'health-bars-container';
    
    // 合作模式时添加特殊样式
    if (pveMode === 'coop') {
      playerHealthContainer.classList.add('coop-health-container');
    }
    
    selfContainer.appendChild(playerHealthContainer);
    
    const bossHealthContainer = document.createElement('div');
    bossHealthContainer.id = 'boss-health-container';
    bossHealthContainer.className = 'health-bars-container';
    enemyContainer.appendChild(bossHealthContainer);
  }
  
  function setupBattleAnimation() {
  const selfAnim = document.getElementById('battleSelfAnim');
  const enemyAnim = document.getElementById('battleEnemyAnim');
  
  if (!selfAnim || !enemyAnim) return;
  
  // 清空现有内容
  selfAnim.innerHTML = "";
  enemyAnim.innerHTML = "";
  
  // 应用背景 - 与PVP模式一致
  selfAnim.style.backgroundImage = "url('images/location_day_1.png')";
  selfAnim.style.backgroundRepeat = "repeat-x";
  selfAnim.style.backgroundSize = "auto 100%";
  selfAnim.style.backgroundPosition = "center top";
  selfAnim.style.animation = "scrollBgRight 30s linear infinite";
  
  enemyAnim.style.backgroundImage = "url('images/location_day_1.png')";
  enemyAnim.style.backgroundRepeat = "repeat-x";
  enemyAnim.style.backgroundSize = "auto 100%";
  enemyAnim.style.backgroundPosition = "center top";
  enemyAnim.style.animation = "scrollBgRight 30s linear infinite";
  
  // 确保容器可见
  selfAnim.style.display = "block";
  enemyAnim.style.display = "block";
  
  // 根据角色添加对应角色的动画
  addUserCharacters(selfAnim);
}

// 修改addUserCharacters函数，确保不重复创建角色
function addUserCharacters(container) {
  if (!container) return;
  
  // 清除所有现有僵尸动画
  const existingZombies = container.querySelectorAll('.zombie-search');
  existingZombies.forEach(zombie => zombie.remove());
  
  // 添加userA的僵尸动画
  const zombieA = document.createElement("div");
  zombieA.className = "zombie-search";
  zombieA.id = "zombie-userA";
  zombieA.style.backgroundImage = "url('" + window.currentZombieSprite + "')";
  
  // 添加userA的名称标签
  const nameTagA = document.createElement("div");
  nameTagA.className = "player-name-tag";
  nameTagA.textContent = pveMode === 'coop' ? (window.myRole === "userA" ? window.myUid : "等待玩家A...") : window.myUid;
  zombieA.appendChild(nameTagA);
  
  container.appendChild(zombieA);
  
  // 如果是合作模式，同时添加userB的僵尸动画
  if (pveMode === 'coop') {
    const zombieB = document.createElement("div");
    zombieB.className = "zombie-search";
    zombieB.id = "zombie-userB";
    // 初始状态 - 稍后会由updatePartnerInfo更新
    zombieB.style.backgroundImage = "url('" + window.currentZombieSprite + "')";
    
    // 添加userB的名称标签
    const nameTagB = document.createElement("div");
    nameTagB.className = "player-name-tag";
    nameTagB.textContent = window.myRole === "userB" ? window.myUid : "等待玩家B...";
    zombieB.appendChild(nameTagB);
    
    container.appendChild(zombieB);
    
    // 立即尝试更新伙伴信息
    setTimeout(() => updatePartnerInfo(), 500); // 给Firebase有时间同步数据
  }
}

// 改进updatePartnerInfo函数
function updatePartnerInfo() {
  if (!currentBattleRoomRef || pveMode !== 'coop') return;
  
  const partnerRole = window.myRole === "userA" ? "userB" : "userA";
  
  currentBattleRoomRef.child(partnerRole).once('value').then((snapshot) => {
    const partnerData = snapshot.val();
    if (!partnerData || !partnerData.uid) return;
    // 更新对应玩家的名称标签
    const partnerZombieId = `zombie-${partnerRole}`;
    const partnerZombie = document.getElementById(partnerZombieId);
    if (partnerZombie) {
      // 更新伙伴的精灵图
      if (partnerData.spriteUrl) {
        partnerZombie.style.backgroundImage = `url('${partnerData.spriteUrl}')`;
      }
	  if (partnerData.btrSpriteUrl) {
        window.partnerBtrSprite = partnerData.btrSpriteUrl;
      }
      if (partnerData.t80SpriteUrl) {
        window.partnerT80Sprite = partnerData.t80SpriteUrl;
      }
      
      const nameTag = partnerZombie.querySelector('.player-name-tag');
      if (nameTag && partnerData.uid) {
        nameTag.textContent = partnerData.uid;
      }
    }
  });
}
  

  
  // 添加生命條和BOSS
  function addHealthBarsAndBoss() {
    const playerHealthContainer = document.getElementById('player-health-container');
    const bossHealthContainer = document.getElementById('boss-health-container');
    
    if (!playerHealthContainer || !bossHealthContainer) return;
    
    // 如果是合作模式，添加两个玩家生命条
    if (pveMode === 'coop') {
      // UserB的生命条 - 左侧
      const userBBar = document.createElement('div');
      userBBar.id = 'userB-health-bar';
      userBBar.className = 'health-bar coop-health-bar';
      userBBar.innerHTML = `
        <div class="health-fill" style="background:green"></div>
        <div class="health-text">等待玩家B...</div>
      `;
      playerHealthContainer.appendChild(userBBar);
      
      // UserA的生命条 - 右侧
      const userABar = document.createElement('div');
      userABar.id = 'userA-health-bar';
      userABar.className = 'health-bar coop-health-bar';
      userABar.innerHTML = `
        <div class="health-fill" style="background:green"></div>
        <div class="health-text">等待玩家A...</div>
      `;
      playerHealthContainer.appendChild(userABar);
      
      // 立即尝试更新生命值
      updateCoopHealthDisplay();
    } else {
      // 单人模式 - 只显示自己的血条
      const playerBar = document.createElement('div');
      playerBar.id = 'player-health-bar';
      playerBar.className = 'health-bar';
      playerBar.innerHTML = `
        <div class="health-fill" style="background:green"></div>
        <div class="health-text">${window.myUid}: ${playerHp}/${playerMaxHp}</div>
      `;
      playerHealthContainer.appendChild(playerBar);
    }
    
    // BOSS生命條
    const bossBar = document.createElement('div');
    bossBar.id = 'boss-health-bar';
    bossBar.className = 'health-bar';
    bossBar.innerHTML = `
      <div class="health-fill boss-health-fill" style="background:red"></div>
      <div class="health-text">${bossConfigs[selectedBoss].name}: 100%</div>
    `;
    bossHealthContainer.appendChild(bossBar);
    
	// 添加BOSS精灵图
	const enemyAnim = document.getElementById('battleEnemyAnim');
	if (enemyAnim && !document.getElementById('boss-animation')) {
	  const bossAnim = document.createElement('div');
	  bossAnim.id = 'boss-animation';
	  
	  // 使用原始CSS变量
	  const rootStyles = getComputedStyle(document.documentElement);
	  const frameHeight = parseFloat(rootStyles.getPropertyValue('--btr-frame-height')) || 120;
	  const frameWidth = parseFloat(rootStyles.getPropertyValue('--btr-frame-width')) || 480;
	  
	  // 精灵图总宽度 (4帧)
	  const framesTotal = 4;
	  const totalWidth = frameWidth * framesTotal;
	  
	  // 设置样式
	  bossAnim.style.position = 'absolute';
	  bossAnim.style.left = '70%';
	  bossAnim.style.top = '50%';
	  bossAnim.style.marginLeft = `-${frameWidth / 2}px`;
	  bossAnim.style.marginTop = `-${frameHeight / 2}px`;
	  bossAnim.style.width = `${frameWidth}px`;
	  bossAnim.style.height = `${frameHeight}px`;
	  bossAnim.style.backgroundImage = `url(${bossConfigs[selectedBoss].sprite})`;
	  bossAnim.style.backgroundSize = `${totalWidth}px ${frameHeight}px`;
	  bossAnim.style.backgroundRepeat = 'no-repeat';
	  bossAnim.style.zIndex = '10';
	  
	  // 创建动画
	  const keyframesText = `
		@keyframes bossFrameAnim {
		  from { background-position: 0 0; }
		  to { background-position: -${totalWidth}px 0; }
		}
	  `;
	  
	  let styleElem = document.getElementById('boss-animation-keyframes');
	  if (!styleElem) {
		styleElem = document.createElement('style');
		styleElem.id = 'boss-animation-keyframes';
		document.head.appendChild(styleElem);
	  }
	  styleElem.textContent = keyframesText;
	  
	  // 应用动画
	  bossAnim.style.animation = 'bossFrameAnim 0.5s steps(4) infinite';
	  
	  enemyAnim.appendChild(bossAnim);
	}
    
    // 更新生命值顯示
    updateHealthDisplay();
  }
  
  // 更新生命值顯示
  function updateHealthDisplay() {
    if (pveMode === 'coop') {
      // 合作模式下更新双方血条
      updateCoopHealthDisplay();
    } else {
      // 单人模式只更新自己
      const playerBar = document.getElementById('player-health-bar');
      if (playerBar) {
        const percentage = Math.round((playerHp / playerMaxHp) * 100);
        playerBar.querySelector('.health-fill').style.width = `${percentage}%`;
        playerBar.querySelector('.health-text').textContent = `${window.myUid}: ${playerHp}/${playerMaxHp}`;
      }
    }
    
    if (pveMode === 'coop' && window.myRole === 'userB') {
    // userB需要从Firebase读取最新值
    if (currentBattleRoomRef) {
      currentBattleRoomRef.child('bossHealth').once('value')
        .then(snapshot => {
          if (snapshot.exists()) {
            const remoteBossHp = snapshot.val();
            updateBossHealthBar(remoteBossHp);
          } else {
            updateBossHealthBar(bossHp); // 回退到本地值
          }
        })
        .catch(() => {
          updateBossHealthBar(bossHp); // 出错时使用本地值
        });
    }
  } else {
    // userA或单人模式直接使用本地值
    updateBossHealthBar(bossHp);
  }
}
	function updateBossHealthBar(currentBossHp) {
	  const bossBar = document.getElementById('boss-health-bar');
	  if (bossBar) {
		const percentage = Math.round((currentBossHp / bossMaxHp) * 100);
		bossBar.querySelector('.health-fill').style.width = `${percentage}%`;
		bossBar.querySelector('.health-text').textContent = `${bossConfigs[selectedBoss].name}: ${percentage}%`;
	  }
	}
  
  // 合作模式下更新双方血条
  function updateCoopHealthDisplay() {
    if (!currentBattleRoomRef) return;
  
  currentBattleRoomRef.once('value').then((snapshot) => {
    updateAllPlayerHealth(snapshot.val());
  });
}
  
  // 開始PVE戰鬥
  function startPveBattle() {
    // 檢查暱稱
    let nickname = document.getElementById('battleNickname').value.trim();
    if (!nickname) {
      return;
    }
    window.myUid = nickname;
    
    // 檢查PIN碼
    let pin = document.getElementById('battlePin').value.trim();
    if (!pin) {
      return;
    }
    
    // 獲取選擇
    selectedBoss = document.getElementById('bossList').value;
    pveMode = document.getElementById('pveModeSelect').value;
    
    // 初始化生命值 - 正確讀取中心建築等級
    initializePlayerHealth();
    
    // 標記PVE模式活躍
    pveActive = true;
    
    // 無論單人還是合作模式，都創建Firebase房間
    createPveRoom(pin);
  }
  
  // 初始化玩家生命值 - 確保正確讀取中心建築等級
  function initializePlayerHealth() {
    let centerLevel = 1;
    
    try {
      // 直接從全局gameState獲取中心建築等級
      const centerBuilding = gameState.buildings.find(b => 
        b && b.type.toLowerCase() === "center"
      );
      if (centerBuilding) {
        centerLevel = centerBuilding.level || 1;
      }
    } catch (error) {
      centerLevel = 1; // 出錯時使用默認值
    }
    
    // 基礎生命值100，每級提升5%
    const baseHealth = 100;
    const healthMultiplier = Math.pow(1.05, centerLevel - 1);
    playerMaxHp = playerHp = Math.round(baseHealth * healthMultiplier);
    
    // 初始化BOSS生命值
    const bossConfig = bossConfigs[selectedBoss];
    bossMaxHp = bossHp = bossConfig.hp;
  }
  
  // 創建PVE房間
  function createPveRoom(pin) {
    // 確保Firebase已初始化
    if (!firebase.database) {
      alert("Firebase 數據庫未初始化");
      return;
    }
    
    // 創建房間參考
    currentBattleRoomRef = firebase.database().ref('pveBattles').child(pin);
	const playerData = {
		uid: window.myUid,
		health: playerHp,
		maxHp: playerMaxHp,
		isDown: false,
		spriteUrl: window.currentZombieSprite, // 僵尸精灵图
		btrSpriteUrl: window.currentBtrSprite, // BTR精灵图
		t80SpriteUrl: window.currentT80Sprite  // T80精灵图
	  };
    
    if (pveMode === 'solo') {
      // 單人模式 - 直接創建並開始
      currentBattleRoomRef.set({
        bossId: selectedBoss,
        mode: pveMode,
        type: 'pve',         // 标记房间类型为PVE
        locked: true,        // 锁定房间，不允许其他玩家加入
        userA: playerData,
        bossHealth: bossHp,
        status: 'active',
        startTime: firebase.database.ServerValue.TIMESTAMP
      }).then(() => {
	    currentBattleRoomRef.onDisconnect().remove();
        window.myRole = "userA";
        pveMatched = true; // 單人模式直接標記為已匹配
		currentBattleRoomRef.child('userA').onDisconnect().remove();
        // 保存房間ID以便後續使用
        window.currentBattleRoom = pin;
        // 初始化戰鬥
        initPveBattle();
        // 設置監聽
        setupFirebaseListeners();
      }).catch(error => {
        alert('創建PVE房間失敗，請稍後再試');
      });
    } else {
      // 合作模式 - 檢查是否已存在房間
      currentBattleRoomRef.once('value').then((snapshot) => {
        const roomData = snapshot.val();
		if (roomData && roomData.locked) {
		  return;
		}
        if (!roomData) {
          // 創建新房間
          currentBattleRoomRef.set({
            bossId: selectedBoss,
            mode: pveMode,
            type: 'pve',     // 标记房间类型为PVE
            userA: playerData,
            bossHealth: bossHp,
            status: 'waiting',
            startTime: firebase.database.ServerValue.TIMESTAMP
          }).then(() => {
		    currentBattleRoomRef.onDisconnect().remove();
            window.myRole = "userA";
			currentBattleRoomRef.child('userA').onDisconnect().remove();
            window.currentBattleRoom = pin;
            // 等待另一位玩家加入
            appendBattleLogEntry({
              sender: "系統",
              senderRole: "system",
              message: "等待另一名玩家加入...",
              battleMode: "pve"
            });
            // 設置監聽
            setupFirebaseListeners();
          }).catch(err => {
            alert("創建合作模式房間失敗");
          });
        } else if (!roomData.userB) {
          // 加入為玩家B
          currentBattleRoomRef.child('userB').set(playerData).then(() => {
		    currentBattleRoomRef.onDisconnect().remove();
            window.myRole = "userB";
			currentBattleRoomRef.child('userB').onDisconnect().remove();
            window.currentBattleRoom = pin;
            // 更新房間狀態
            currentBattleRoomRef.update({ status: 'active' });
            // 設置監聽
            setupFirebaseListeners();
            // 獲取BOSS信息
            selectedBoss = roomData.bossId;
            bossHp = bossMaxHp = roomData.bossHealth;
            // 初始化戰鬥
            pveMatched = true;
            initPveBattle();
          }).catch(() => {});
        } else {}
      }).catch(() => {});
    }
  }
  
function setupFirebaseListeners() {
  if (!currentBattleRoomRef) return;
  
  // 移除現有監聽器
  currentBattleRoomRef.off();
  currentBattleRoomRef.child('log').off();
  currentBattleRoomRef.child('events').off();
  
  // 1. 监听房间状态变化 - 重要：死亡后仍需继续监听
  currentBattleRoomRef.on('value', (snapshot) => {
    const roomData = snapshot.val();
    if (!roomData) return;
	latestRoomData = roomData;
	updateAllPlayerHealth(roomData);
	if (pveMode === 'coop') {
		if (roomData.userA?.isDown && !processedMessages['bossLoop_taken']) {
          processedMessages['bossLoop_taken'] = true;
          enableBossLoop();
        }
        if (roomData.userA?.isDown && !processedMessages['userA_death']) {
          processedMessages['userA_death'] = true;
          updatePlayerSpriteToDead('userA');
        }
        if (roomData.userB?.isDown && !processedMessages['userB_death']) {
          processedMessages['userB_death'] = true;
          updatePlayerSpriteToDead('userB');
        }
      }
    currentBattleRoomRef.on('child_removed', snapshot => {
    const role = snapshot.key;  // 'userA' 或 'userB'
    if (role !== 'userA' && role !== 'userB') return;
    // 避免重复执行
    const flag = `${role}_exit_death`;
    if (processedMessages[flag]) return;
    processedMessages[flag] = true;

    // 1) 切死亡精灵
    updatePlayerSpriteToDead(role);

    // 2) 更新血条：该玩家血量归零
    const rem = snapshot.val() || {};
    const fakeData = {
      userA: role==='userA'
        ? { uid: rem.uid || '玩家A', health: 0, maxHp: rem.maxHp || playerMaxHp, isDown: true }
        : latestRoomData.userA,
      userB: role==='userB'
        ? { uid: rem.uid || '玩家B', health: 0, maxHp: rem.maxHp || playerMaxHp, isDown: true }
        : latestRoomData.userB
    };
    updateAllPlayerHealth(fakeData);
  });
    
	    
    // 检查游戏结束
    if (roomData.status === 'ended') {
      if (!pveEnded) {
        pveEnded = true;
        setTimeout(() => endPveBattle(roomData.result === 'victory'), 1000);
      }
      return;
    }
    
    // 关键改进：无论任何状态，始终更新所有血量显示
    updateAllPlayerHealth(roomData);
      
      // 檢查是否已有兩名玩家
      if (roomData.status === 'active' && roomData.userA && roomData.userB) {
        if (!pveMatched) {
          pveMatched = true;
          appendBattleLogEntry({
            sender: "系統",
            senderRole: "system",
            message: "雙方連線成功，準備開始對戰！",
            battleMode: "pve"
          });
          
          // 如果是玩家A，初始化戰鬥
          if (window.myRole === "userA") {
            initPveBattle();
          }
          
          // 添加伙伴角色
          const selfAnim = document.getElementById('battleSelfAnim');
          if (selfAnim) {
            addUserCharacters(selfAnim);
          }
          
          // 更新双方血条
          updateCoopHealthDisplay();
        }
      }
      
      // 同步BOSS生命值
      if (window.myRole === "userB" && roomData.bossHealth !== undefined) {
        bossHp = roomData.bossHealth;
        updateHealthDisplay();
      }
      
      // ===== 玩家倒地检测与处理 =====
      if (window.myRole === "userA") {
      // 检查userA是否刚刚死亡
      if (roomData.userA && roomData.userA.isDown) {
        const userADownKey = `userA_${roomData.userA.uid}_down`;
        if (!processedMessages[userADownKey]) {
          processedMessages[userADownKey] = true;
          
          appendBattleLogEntry({
            sender: "系統",
            senderRole: "system",
            message: `${roomData.userA.uid} 受到致命一擊，重傷倒地。`,
            battleMode: "pve"
          });
		   currentBattleRoomRef.child('_processedMessages').update({
            [userADownKey]: true
          });
        }
      }
      
      // 检查userB是否刚刚死亡
      if (roomData.userB && roomData.userB.isDown) {
        const userBDownKey = `userB_${roomData.userB.uid}_down`;
        if (!processedMessages[userBDownKey]) {
          processedMessages[userBDownKey] = true;
          
          appendBattleLogEntry({
            sender: "系統",
            senderRole: "system",
            message: `${roomData.userB.uid} 受到致命一擊，重傷倒地。`,
            battleMode: "pve"
          });
        }
      }
      
      // 检查是否双方都死亡 - 战斗失败
      if (roomData.userA && roomData.userA.isDown && 
          roomData.userB && roomData.userB.isDown && !pveEnded) {
        setTimeout(() => endPveBattle(false), 1000);
      }
    }
  });
  
  // 2. 監聽事件 - 用于同步BTR/T80支援
  if (pveMode === 'coop') {
    currentBattleRoomRef.child('events').on('child_added', (snapshot) => {
      const event = snapshot.val();
      if (event && event.type === 'btrSupport' && event.sender !== window.myRole) {
        // 显示伙伴的BTR/T80支援
        battleBTRType = event.btrType;
        showPartnerBtrSupport();
      }
    });
  }
  
  // 3. 監聽日誌 - 修復：使用唯一ID防止重複
  currentBattleRoomRef.child('log').on('child_added', (snapshot) => {
    if (pveEnded) return;
    
    const logEntry = snapshot.val();
    if (!logEntry) return;
    
    const entryId = snapshot.key;
    
    // 檢查是否已處理過該消息
    if (processedMessages[entryId]) {
      return; // 跳過已處理的消息
    }
    
    // 標記消息為已處理
    processedMessages[entryId] = true;
    
    // 確保消息來自PVE戰鬥
    if (logEntry.battleMode !== 'pve' && logEntry.battleMode !== undefined) {
      return; // 跳过非PVE消息
    }
    
    // 避免顯示自己本地已顯示過的消息（僅檢查發送者和角色）
    if (logEntry.sender === window.myUid && logEntry.senderRole === window.myRole) {
      return;
    }
    
    // 顯示日誌
    displayBattleLogEntry(logEntry);
  });
}

function updateAllPlayerHealth(roomData) {
  if (!roomData) return;

  // 玩家 A 的血条
  const userA = roomData.userA || {};
  const barA  = document.getElementById('userA-health-bar');
  if (barA) {
    // 如果 roomData 中存了 maxHp 就用它，否则回退到本地 playerMaxHp
    const maxHpA = userA.maxHp != null ? userA.maxHp : playerMaxHp;
    const hpA    = userA.health != null ? userA.health : 0;
    const pctA   = maxHpA > 0 ? Math.round((hpA / maxHpA) * 100) : 0;

    barA.querySelector('.health-fill').style.width       = pctA + '%';
    barA.querySelector('.health-text').textContent       =
      `${userA.uid || '玩家A'}: ${hpA}/${maxHpA}`;
    barA.classList.toggle('player-down', !!userA.isDown);
  }

  // 玩家 B 的血条（Coop 模式下才会有）
  const userB = roomData.userB || {};
  const barB  = document.getElementById('userB-health-bar');
  if (barB) {
    const maxHpB = userB.maxHp != null ? userB.maxHp : playerMaxHp;
    const hpB    = userB.health != null ? userB.health : 0;
    const pctB   = maxHpB > 0 ? Math.round((hpB / maxHpB) * 100) : 0;

    barB.querySelector('.health-fill').style.width       = pctB + '%';
    barB.querySelector('.health-text').textContent       =
      `${userB.uid || '玩家B'}: ${hpB}/${maxHpB}`;
    barB.classList.toggle('player-down', !!userB.isDown);
  }
}


// 显示伙伴的BTR/T80支援
function showPartnerBtrSupport() {
  if (!window.currentBattleRoom) return;
  const selfAnim = document.getElementById("battleSelfAnim");
  if (!selfAnim) return;
  const useT80 = (battleBTRType === "t80");
  const partnerRole = window.myRole === "userA" ? "userB" : "userA";
  currentBattleRoomRef.child(partnerRole).once("value").then(snap => {
    const pd = snap.val();
    if (!pd) return;
    // 1) 取对方上传的精灵图 URL
    const spriteUrl = (battleBTRType === "t80")
      ? (pd.t80SpriteUrl || window.currentT80Sprite)
      : (pd.btrSpriteUrl  || window.currentBtrSprite);
  
   // 动态计算位置
  const containerWidth = selfAnim.clientWidth;
  const offset = 50;
  const rootStyles = getComputedStyle(document.documentElement);
  
  let frameWidth;
  if (useT80) {
    frameWidth = 480;
  } else {
    frameWidth = parseFloat(rootStyles.getPropertyValue('--btr-frame-width')) || 240;
  }
  
  // 计算位置 - 在伙伴僵尸附近
  const centerStart = containerWidth + offset + 0.5 * frameWidth;
  const centerStop = window.myRole === "userB" ? containerWidth * 0.4 : containerWidth * 0.6; 
  const startLeft = centerStart - 0.5 * frameWidth;
  const stopLeft  = centerStop - 0.5 * frameWidth;
  
  // 创建关键帧动画
  const keyframesText = `
    @keyframes btrMovePartnerBattle {
      0%   { left: ${startLeft}px; }
      20%  { left: ${stopLeft}px; }
      60%  { left: ${stopLeft}px; }
      100% { left: ${startLeft}px; }
    }
  `;
  
  let styleElem = document.getElementById("btrKeyframesPartnerBattle");
  if (!styleElem) {
    styleElem = document.createElement("style");
    styleElem.id = "btrKeyframesPartnerBattle";
    document.head.appendChild(styleElem);
  }
  styleElem.textContent = keyframesText;
  
  // 创建动画容器
  const btrWrapper = document.createElement("div");
  btrWrapper.className = "btr-wrapper partner-btr";
  btrWrapper.style.position = "absolute";
  btrWrapper.style.top = "25%";
  btrWrapper.style.left = startLeft + "px";
  btrWrapper.style.animation = "btrMovePartnerBattle 10s ease-in-out forwards";
  btrWrapper.style.zIndex = "5";
  
  let spriteElem;
  if (useT80) {
    // T80动画
    const frameContainer = document.createElement("div");
    frameContainer.className = "frameContainer";
    frameContainer.style.width = frameWidth + "px";
    frameContainer.style.height = rootStyles.getPropertyValue('--btr-frame-height') || "120px";
    frameContainer.style.overflow = "hidden";
    
    spriteElem = document.createElement("div");
    spriteElem.className = "t80-animation partner-t80";
    spriteElem.style.backgroundImage = `url("${spriteUrl}")`;
    spriteElem.style.backgroundPosition = "0px 0";
    
    frameContainer.appendChild(spriteElem);
    btrWrapper.appendChild(frameContainer);
	startT80IdleAnimation(spriteElem);
    setTimeout(() => {
      const originalBTRActive = battleBTRActive;
      const originalCooldown = t80CannonOnCooldown;
      battleBTRActive = true;
      t80CannonOnCooldown = false;
      triggerT80Cannon(spriteElem);
      setTimeout(() => {
        battleBTRActive = originalBTRActive;
        t80CannonOnCooldown = originalCooldown;
      }, 100);
    }, 1000);
  } else {
    // BTR动画
    spriteElem = document.createElement("div");
    spriteElem.className = "btr-animation partner-btr";
    spriteElem.style.backgroundImage = `url("${spriteUrl}")`;
    btrWrapper.appendChild(spriteElem);
  }
  
  selfAnim.appendChild(btrWrapper);
  spriteElem.style.setProperty(
      "background-image",
      `url("${spriteUrl}")`,
      "important"
    );
  
  // 10秒后清理
  setTimeout(() => {
    if (selfAnim.contains(btrWrapper)) {
      selfAnim.removeChild(btrWrapper);
    }
  }, 10000);
  });
}

// 顯示戰鬥日誌條目
function displayBattleLogEntry(messageObj) {
  if (typeof messageObj !== 'object' || messageObj === null) return;
  
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  
  // 根據發送者設置樣式
  if (messageObj.senderRole === "system") {
    // 系统事件 - 使用系统样式
    entry.className += ' battle-system-entry';
    entry.innerHTML = `<span>[系統] ${messageObj.message}</span>`;
  } else if (messageObj.senderRole === "boss") {
    // Boss事件 - 使用敌方样式
    entry.className += ' battle-enemy-entry';
    entry.innerHTML = `<span>[${messageObj.sender}] ${messageObj.message}</span>`;
  } else {
    // 玩家事件 - 使用己方样式
    entry.className += ' battle-self-entry';
    entry.innerHTML = `<span>[${messageObj.sender}] ${messageObj.message}</span>`;
  }
  
  const logContainer = document.getElementById('battleLogContent');
  if (logContainer) {
    logContainer.appendChild(entry);
    logContainer.scrollTop = logContainer.scrollHeight;
  }
}

// 向戰鬥日誌添加條目並上傳到Firebase
function appendBattleLogEntry(messageObj) {
  if (typeof messageObj !== 'object' || messageObj === null) return;
  
  // 添加PVE标识
  if (!messageObj.battleMode) {
    messageObj.battleMode = "pve";
  }
  
  // 顯示在本地
  displayBattleLogEntry(messageObj);
  
  // 上傳到Firebase
  if (currentBattleRoomRef) {
    // 生成唯一ID
    const newLogRef = currentBattleRoomRef.child('log').push();
    const messageId = newLogRef.key;
    
    // 已將此消息標記為已處理，防止重複顯示
    processedMessages[messageId] = true;
    
    // 上傳消息到Firebase
    newLogRef.set(messageObj);
  }
}
function enableBossLoop() {
    if (bossAttackInterval) return; // 已经在运行
    const cfg = bossConfigs[selectedBoss];
    // Solo：userA 执行；Coop：只有 userA 活着或 userB 接手后才执行
    if (
      pveMode === 'solo' && window.myRole === 'userA'
      || pveMode === 'coop' && (
           !latestRoomData.userA?.isDown && window.myRole === 'userA'
        ||  latestRoomData.userA?.isDown && window.myRole === 'userB'
      )
    ) {
      bossAttackInterval = setInterval(() => {
        // 如果游戏结束或自己已倒地，跳过
        if (pveEnded || latestRoomData?.[window.myRole]?.isDown) return;
        triggerBossAttack();
      }, cfg.attackInterval);
    }
  }
// 開始戰鬥循環
function startCombatLoop() {
  // 清除現有計時器
  clearCombatTimers();
  
  // 玩家攻擊循環 - 每5秒
  pveInterval = setInterval(() => {
    if (pveEnded || playerIsDown) return;
    triggerPlayerAttack();
  }, 5000);
  
  // BOSS攻擊循環
  enableBossLoop();
  
  // BTR/T80事件 - 每30秒檢查一次，與PVP一致
  battleBTREventTimer = setInterval(() => {
    if (pveEnded || playerIsDown) return;
    checkBTREvent();
  }, 30000);
}



// 檢查BTR事件
function checkBTREvent() {
  // 直接從gameState獲取裝甲車庫（拖拉機廠）
  try {
    const garages = gameState.buildings.filter(b => 
      b && b.type.toLowerCase() === "armoredgarage"
    );
    
    if (garages.length > 0 && BUILDINGS && BUILDINGS.armoredGarage) {
      const garageInfo = BUILDINGS.armoredGarage.getUpgradeInfo(garages[0].level);
      
      // 檢查觸發機率
      if (Math.random() < garageInfo.effect.btrChance) {
        triggerBtrSupport();
      }
    }
  } catch (error) {
    // 靜默處理錯誤
  }
}

// 清除戰鬥計時器
function clearCombatTimers() {
  if (pveInterval) clearInterval(pveInterval);
  if (bossAttackInterval) clearInterval(bossAttackInterval);
  if (battleBTREventTimer) clearInterval(battleBTREventTimer);
  if (battleBTRInterval) clearInterval(battleBTRInterval);
  if (t80IdleInterval) clearInterval(t80IdleInterval);
  if (t80CannonTimeout) clearTimeout(t80CannonTimeout);
  
  pveInterval = null;
  bossAttackInterval = null;
  battleBTREventTimer = null;
  battleBTRInterval = null;
  t80IdleInterval = null;
  t80CannonTimeout = null;
}

// 觸發玩家攻擊
function triggerPlayerAttack() {
  let centerLevel = 1;
  
  try {
    // 直接從gameState獲取中心基地等級
    const centerBuilding = gameState.buildings.find(b => 
      b && b.type.toLowerCase() === "center"
    );
    if (centerBuilding) {
      centerLevel = centerBuilding.level || 1;
    }
  } catch (error) {
    centerLevel = 1;
  }
  
  // 與PVP一致的命中率計算：40 + centerLevel * 0.5，最高85%
  const hitChanceVal = Math.min(40 + centerLevel * 0.5, 85);
  const hitRoll = Math.random() * 100;
  const hit = (hitRoll < hitChanceVal);
  
  // 傷害計算
  const baseDamage = hit ? (Math.floor(Math.random() * 10) + 1) : 0;
  
  // 僵尸指揮中心加成
  let commandCenterLevel = 0;
  try {
    const commandCenter = gameState.buildings.find(b => 
      b && b.type.toLowerCase() === "zombiecommandcenter"
    );
    if (commandCenter) {
      commandCenterLevel = commandCenter.level;
    }
  } catch (error) {
    commandCenterLevel = 0;
  }
  
  // 傷害加成
  const multiplier = 1 + commandCenterLevel * 0.01;
  const damage = Math.round(baseDamage * multiplier);
  
  // 獲取攻擊短語
  const phrase = pveAttackPhrases.normal[Math.floor(Math.random() * pveAttackPhrases.normal.length)];
  
  // 處理戰鬥結果
  if (hit && damage > 0) {
    appendBattleLogEntry({
      sender: window.myUid,
      senderRole: window.myRole,
      message: `派遣的 ${phrase}（命中），${bossConfigs[selectedBoss].name} 受到 ${damage} 點傷害`,
      targetType: "boss",
      battleMode: "pve"
    });
    
    // 更新BOSS生命值
    if (window.myRole === "userA") {
      // 更新BOSS生命值
      bossHp = Math.max(0, bossHp - damage);
      totalPlayerDamage += damage;
    
    // 同步到Firebase
    if (currentBattleRoomRef) {
        currentBattleRoomRef.update({ 
          bossHealth: bossHp,
          lastDamageBy: "userA",
          lastDamageAmount: damage,
          lastUpdateTime: firebase.database.ServerValue.TIMESTAMP
        });
      }
    
    // 檢查BOSS是否被擊敗
    if (bossHp <= 0) {
        endPveBattle(true);
      }
    } else {
      // userB只更新自己的本地伤害统计，不修改bossHp
      totalPlayerDamage += damage;
    }
  } else {
    appendBattleLogEntry({
      sender: window.myUid,
      senderRole: window.myRole,
      message: `派遣的 ${phrase}（未命中）`,
      targetType: "boss",
      battleMode: "pve"
    });
  }
  
  // 更新生命值顯示
  updateHealthDisplay();
}


function triggerBossAttack() {
  const cfg = bossConfigs[selectedBoss];

  // Solo：只让 userA 发起；Coop：由存活者接手
  if (pveMode === 'solo') {
    if (window.myRole !== 'userA') return;
  } else {
    if (latestRoomData?.[window.myRole]?.isDown) return;
    if (latestRoomData.userA?.isDown && latestRoomData.userB?.isDown) return;
  }

  // 1) 命中判定
  const hitChance = cfg.hitChance ?? 75;
  const hit = Math.random() * 100 < hitChance;

  // 2) 单体 vs AOE
  const singleRate = cfg.singleAttackRate ?? 0.7;
  const isSingle  = Math.random() < singleRate;

  // —— 3) 选词库：单体攻击（或 Solo 模式）一定取 single 词库 —— 
  const useSinglePool = isSingle || pveMode === 'solo';
  const pool = useSinglePool
    ? cfg.attackPhrases.single
    : (cfg.attackPhrases.aoe || cfg.attackPhrases.single);
  const phrase = pool[Math.floor(Math.random() * pool.length)];

  // 4) 计算伤害
  let damage = 0;
  if (hit) {
    const raw = Math.floor(
      cfg.damageRange.min +
      Math.random() * (cfg.damageRange.max - cfg.damageRange.min)
    );
    damage = isSingle ? raw : Math.floor(raw * 0.8);
  }

  // 5) 扣血 & 日志
  if (hit && damage > 0) {
    if (useSinglePool) {
      // 单体：随机选个存活玩家或 Solo
      let targets = [];
      if (pveMode === 'solo') {
        targets.push('userA');
      } else {
        if (!latestRoomData.userA?.isDown) targets.push('userA');
        if (!latestRoomData.userB?.isDown) targets.push('userB');
      }
      if (targets.length === 0) return;

      const role = targets[Math.floor(Math.random() * targets.length)];
      const uid  = latestRoomData[role].uid;

      appendBattleLogEntry({
        sender: cfg.name,
        senderRole: 'boss',
        message: `${phrase}${uid}（命中），造成 ${damage} 點傷害！`,
        timestamp: Date.now(),
        battleMode: 'pve',
        aoe: false
      });

      // 扣血
      const ref = currentBattleRoomRef.child(role);
      ref.once('value').then(snap => {
	    const data = snap.val() || {};
		if (data.isDown) return;
        const prev = snap.val()||{};
        const newHp = Math.max(0, (prev.health||playerMaxHp) - damage);
        ref.update({ health: newHp, isDown: newHp<=0 });
        if (role === window.myRole && newHp <= 0 && !playerIsDown) {
          handlePlayerDown();
        }
      });
    } else {
      // 群体
      appendBattleLogEntry({
        sender: cfg.name,
        senderRole: 'boss',
        message: `${phrase}（範圍攻擊）→ 我方各受 ${damage} 點傷害！`,
        timestamp: Date.now(),
        battleMode: 'pve',
        aoe: true
      });

      ['userA','userB'].forEach(role => {
        if (pveMode==='solo' && role!=='userA') return;
        const ref = currentBattleRoomRef.child(role);
        ref.once('value').then(snap => {
		  const data = snap.val() || {};
		  if (data.isDown) return; 
          const prev = snap.val()||{};
          const newHp = Math.max(0, (prev.health||playerMaxHp) - damage);
          ref.update({ health: newHp, isDown: newHp<=0 });
          if (role === window.myRole && newHp <= 0 && !playerIsDown) {
            handlePlayerDown();
          }
        });
      });
    }
  } else {
    // 未命中也走同一 pool
    appendBattleLogEntry({
      sender: cfg.name,
      senderRole: "boss",
      message: `${phrase}（未命中）！`,
      timestamp: Date.now(),
      battleMode: "pve",
      aoe: !useSinglePool
    });
  }

  // 6) 刷新血条
  updateAllPlayerHealth(latestRoomData || { userA:{ health:playerHp, maxHp:playerMaxHp, isDown:playerIsDown, uid:window.myUid } });
}



// 觸發BTR/T80支援
function triggerBtrSupport() {
  // 隨機選擇T80或BTR (40%機率使用T80)
  const useT80 = (Math.random() < 0.4);
  battleBTRType = useT80 ? "t80" : "btr";
  
  // 獲取動畫容器
  const selfAnim = document.getElementById('battleSelfAnim');
  if (!selfAnim) return;
  
  // 動態計算位置
  const containerWidth = selfAnim.clientWidth;
  const offset = 50;
  const rootStyles = getComputedStyle(document.documentElement);
  
  let frameWidth;
  if (useT80) {
    frameWidth = 480;
  } else {
    frameWidth = parseFloat(rootStyles.getPropertyValue('--btr-frame-width')) || 240;
  }
  const centerStart = containerWidth + offset + 0.5 * frameWidth;
  const centerStop = window.myRole === "userA" ? containerWidth * 0.4 : containerWidth * 0.6;
  const startLeft = centerStart - 0.5 * frameWidth;
  const stopLeft  = centerStop - 0.5 * frameWidth;
  
  // 創建關鍵幀動畫
  const keyframesText = `
    @keyframes btrMoveDynamicBattle {
      0%   { left: ${startLeft}px; }
      20%  { left: ${stopLeft}px; }
      60%  { left: ${stopLeft}px; }
      100% { left: ${startLeft}px; }
    }
  `;
  
  let styleElem = document.getElementById("btrKeyframesBattle");
  if (!styleElem) {
    styleElem = document.createElement("style");
    styleElem.id = "btrKeyframesBattle";
    document.head.appendChild(styleElem);
  }
  styleElem.textContent = keyframesText;
  
  // 創建動畫容器
  const btrWrapper = document.createElement("div");
  btrWrapper.className = "btr-wrapper";
  btrWrapper.style.position = "absolute";
  btrWrapper.style.top = "25%";
  btrWrapper.style.left = startLeft + "px";
  btrWrapper.style.animation = "btrMoveDynamicBattle 10s ease-in-out forwards";
  btrWrapper.style.zIndex = window.myRole === "userA" ? "10" : "5";
  let spriteElem;
  if (useT80) {
    // T80動畫
    const frameContainer = document.createElement("div");
    frameContainer.className = "frameContainer";
    frameContainer.style.width = frameWidth + "px";
    frameContainer.style.height = rootStyles.getPropertyValue('--btr-frame-height') || "120px";
    frameContainer.style.overflow = "hidden";
    
    spriteElem = document.createElement("div");
    spriteElem.className = "t80-animation";
    spriteElem.style.backgroundImage = "url('" + window.currentT80Sprite + "')";
    spriteElem.style.backgroundPosition = "0px 0";
    
    frameContainer.appendChild(spriteElem);
    btrWrapper.appendChild(frameContainer);
    
    // 啟動T-80閒置動畫
    startT80IdleAnimation(spriteElem);
  } else {
    // BTR動畫
    spriteElem = document.createElement("div");
    spriteElem.className = "btr-animation";
    spriteElem.style.backgroundImage = "url('" + window.currentBtrSprite + "')";
    btrWrapper.appendChild(spriteElem);
  }
  
  selfAnim.appendChild(btrWrapper);
  
  // 設置BTR活躍標志
  battleBTRActive = true;
  
  // 啟動特殊攻擊 - 每5秒攻擊一次
  startBtrSpecialAttack();
  
  if (useT80) {
    setTimeout(() => {
      triggerT80Cannon(spriteElem);
    }, 1000);
  }
  
  // 10秒後清理
  setTimeout(() => {
    battleBTRActive = false;
    
    if (selfAnim.contains(btrWrapper)) {
      selfAnim.removeChild(btrWrapper);
    }
    
    if (t80IdleInterval) {
      clearInterval(t80IdleInterval);
      t80IdleInterval = null;
    }
    
    if (battleBTRInterval) {
      clearInterval(battleBTRInterval);
      battleBTRInterval = null;
    }
    
  }, 10000);
  
  // 合作模式時通知伙伴
  if (pveMode === 'coop' && currentBattleRoomRef) {
    currentBattleRoomRef.child('events').push({
      type: 'btrSupport',
      btrType: battleBTRType,
      sender: window.myRole,
      timestamp: firebase.database.ServerValue.TIMESTAMP
    });
  }
}

// 啟動T80閒置動畫
function startT80IdleAnimation(spriteElem) {
  if (!spriteElem) return;
  
  // 清除現有的閒置計時器
  if (t80IdleInterval) {
    clearInterval(t80IdleInterval);
  }
  
  // 初始設為第1幀
  spriteElem.style.backgroundPosition = "0px 0";
  
  // 使用與PVP模式相同的動畫邏輯
  let t80IdleToggle = false;
  t80IdleInterval = setInterval(() => {
    t80IdleToggle = !t80IdleToggle;
    spriteElem.style.backgroundPosition = t80IdleToggle ? "-1440px 0" : "0px 0";
  }, 250);
}

// 觸發T80開炮動畫
function triggerT80Cannon(spriteElem) {
  if (!spriteElem || !spriteElem.parentNode || t80CannonOnCooldown) return;
  
  // 設置冷卻標志
  t80CannonOnCooldown = true;
  
  // 暫停閒置動畫
  if (t80IdleInterval) {
    clearInterval(t80IdleInterval);
    t80IdleInterval = null;
  }
  
  // 播放完整開炮動畫序列
  spriteElem.style.backgroundPosition = "0px 0"; // frame1
  setTimeout(() => { spriteElem.style.backgroundPosition = "-480px 0"; }, 250); // frame2
  setTimeout(() => { spriteElem.style.backgroundPosition = "-960px 0"; }, 500); // frame3
  setTimeout(() => { spriteElem.style.backgroundPosition = "-1440px 0"; }, 750); // frame4
  
  // 1秒後恢復閒置動畫
  setTimeout(() => {
    if (spriteElem && spriteElem.parentNode) {
      spriteElem.style.backgroundPosition = "0px 0";
      startT80IdleAnimation(spriteElem);
    }
  }, 1000);
  
  // 4.25秒後允許再次開炮
  setTimeout(() => {
    t80CannonOnCooldown = false;
    // 如果BTR仍然活躍，且元素存在，再次開炮
    if (battleBTRActive && spriteElem && spriteElem.parentNode) {
      triggerT80Cannon(spriteElem);
    }
  }, 4250);
}

// 啟動BTR特殊攻擊
function startBtrSpecialAttack() {
  if (pveEnded || playerIsDown) return;
  if (battleBTRInterval) clearInterval(battleBTRInterval);
  
  // 立即執行第一次攻擊
  triggerBtrSpecialAttack();
  
  // 之後每5秒執行一次
  battleBTRInterval = setInterval(() => {
    if (!pveEnded && !playerIsDown && battleBTRActive) {
      triggerBtrSpecialAttack();
    }
  }, 5000);
}

// 執行BTR特殊攻擊
function triggerBtrSpecialAttack() {
  if (pveEnded || !battleBTRActive) return;
  
  // 從gameState獲取中心建築等級計算命中率
  let centerLevel = 1;
  try {
    const centerBuilding = gameState.buildings.find(b => 
      b && b.type.toLowerCase() === "center"
    );
    if (centerBuilding) {
      centerLevel = centerBuilding.level || 1;
    }
  } catch (error) {
    centerLevel = 1;
  }
  
  // 與PVP模式使用相同的命中率計算
  const baseHitChance = 40;
  const hitChanceVal = Math.min(baseHitChance + centerLevel * 0.5, 85);
  
  // 計算傷害
  const hitRoll = Math.random() * 100;
  const baseDamage = battleBTRType === "t80" ? 
    Math.floor(Math.random() * 20) + 15 :  // T-80伤害15-35
    Math.floor(Math.random() * 15) + 10;   // BTR伤害10-25
  
  // 讀取裝甲車庫等級計算加成
  let tractorLevel = 0;
  try {
    const tractor = gameState.buildings.find(b => 
      b && b.type.toLowerCase() === "armoredgarage"
    );
    if (tractor) {
      tractorLevel = tractor.level;
    }
  } catch (error) {
    tractorLevel = 0;
  }
  
  // 每級0.5%的加成
  const multiplier = 1 + tractorLevel * 0.005;
  const damage = Math.round(baseDamage * multiplier);
  
  // 命中判定
  const hitSuccess = hitRoll < hitChanceVal;
  
  // 獲取攻擊短語
  let type = battleBTRType === "t80" ? "t80" : "btr";
  let phrase = pveAttackPhrases[type][Math.floor(Math.random() * pveAttackPhrases[type].length)];
  
  if (hitSuccess) {
    // 命中
    appendBattleLogEntry({
      sender: window.myUid,
      senderRole: window.myRole,
      message: `派遣的 ${phrase}（命中），${bossConfigs[selectedBoss].name} 受到 ${damage} 點傷害`,
      timestamp: Date.now(),
      targetType: "boss",
      battleMode: "pve"
    });
    
    // 更新BOSS生命值
    if (window.myRole === "userA") {
      // 更新BOSS生命值
      bossHp = Math.max(0, bossHp - damage);
      totalPlayerDamage += damage;
      
      // 同步到Firebase
      if (currentBattleRoomRef) {
        currentBattleRoomRef.update({ 
          bossHealth: bossHp,
          lastDamageBy: "userA_btr",
          lastDamageAmount: damage
        });
      }
    
    // 檢查BOSS是否被擊敗
   if (bossHp <= 0) {
        endPveBattle(true);
      }
    } else {
      // userB只更新自己的伤害统计
      totalPlayerDamage += damage;
    }
  } else {
    // 未命中
    appendBattleLogEntry({
      sender: window.myUid,
      senderRole: window.myRole,
      message: `派遣的 ${phrase}（未命中）`,
      timestamp: Date.now(),
      targetType: "boss",
      battleMode: "pve"
    });
  }
  
  // 更新生命值顯示
  updateHealthDisplay();
}

// 玩家倒地處理
function handlePlayerDown() {
  if (playerIsDown) return; // 防止重复处理
  playerIsDown = true;
  updatePlayerSpriteToDead(window.myRole);
  // 同步到Firebase
  if (currentBattleRoomRef) {
    currentBattleRoomRef.child(window.myRole).update({
      isDown: true
    });
  }
  // 單人模式直接戰敗
  if (pveMode === 'solo') {
    endPveBattle(false);
  }
}

// 結束PVE戰鬥
function endPveBattle(isVictory) {
  if (pveEnded) return;
  pveEnded = true;
  
  // 停止所有計時器
  clearCombatTimers();
  
  // 結算獎勵
  const bossConfig = bossConfigs[selectedBoss];
  let rewardRatio = isVictory ? 1.0 : Math.min(totalPlayerDamage / bossMaxHp, 0.75);
  
  // 計算最終獎勵
  const rewards = {};
  for (const resource in bossConfig.rewards) {
    rewards[resource] = Math.round(bossConfig.rewards[resource] * rewardRatio);
  }
  
  // 顯示結果
  const damagePercentage = Math.round((totalPlayerDamage / bossMaxHp) * 100);
  
  let resultMessage = `戰鬥${isVictory ? '勝利' : '失敗'}！\n`;
  resultMessage += `BOSS: ${bossConfig.name}\n`;
  resultMessage += `造成傷害: ${totalPlayerDamage}/${bossMaxHp} (${damagePercentage}%)\n\n`;
  resultMessage += `獎勵資源:\n`;
  resultMessage += `食物: +${rewards.food}\n`;
  resultMessage += `材料: +${rewards.materials}\n`;
  resultMessage += `武器: +${rewards.weapons}\n`;
  resultMessage += `科技: +${rewards.tech}\n`;
  
  appendBattleLogEntry({
    sender: "系統",
    senderRole: "system",
    message: resultMessage,
    battleMode: "pve"
  });
  
   // 添加獎勵資源
  try {
    if (gameState && gameState.resources) {
      gameState.resources.food += rewards.food;
      gameState.resources.materials += rewards.materials;
      gameState.resources.weapons += rewards.weapons;
      gameState.resources.tech += rewards.tech;
      
      // 保存遊戲狀態
      if (typeof saveGameState === 'function') {
        saveGameState();
      }
      if (typeof updateResourceDisplays === 'function') {
        updateResourceDisplays();
      }
    }
  } catch (e) {}
  
  // 標記戰鬥結束
  if (currentBattleRoomRef) {
    currentBattleRoomRef.update({
      status: 'ended',
      result: isVictory ? 'victory' : 'defeat',
      endTime: firebase.database.ServerValue.TIMESTAMP
    });
  }
}
async function exitPveBattle() {
  const pin = window.currentBattleRoom;
  if (!pin) return;
  const roomRef = firebase.database().ref(`pveBattles/${pin}`);

  // 1) 取消监听
  roomRef.off();
  roomRef.child('log').off();
  roomRef.child('events').off();

  // 2) 真删除自己 userA/userB 节点
  await roomRef.child(window.myRole).remove();

  // 3) 检查剩余玩家，若都不存在则删房间
  const snap = await roomRef.once('value');
  const data = snap.val() || {};
  if (!data.userA && !data.userB) {
    await roomRef.remove();
  }

  // 4) 本地清理
  clearCombatTimers();
  document.getElementById('battleOverlay').style.display = 'none';
  document.body.style.overflow = '';
  pveActive   = false;
  pveMatched  = false;
  pveEnded    = false;
  playerIsDown= false;
  window.currentBattleRoom = null;
  window.myRole            = null;
}


})();

	
	</script>
</body>
</html>
