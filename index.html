<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>末日控制中心 - 關鍵版本擴展調整版</title>
  <style>
    /* 彈窗系統 */
       .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal-content {
      background: #2d2d2d;
      padding: 2rem;
      border-radius: 12px;
      width: min(90vw, 500px);
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
	/* 收藏彈窗繼承現有 modal 的樣式，若需要與行動日誌區重合，可加入如下設定 */
	#favoritesModal .modal-content,
	#productionCollectionModal .modal-content {
	  width: 90%;         /* 或直接與行動日誌區同寬 */
	  max-width: 600px;    /* 根據行動日誌所在區域調整 */
	}
	html {
	  touch-action: manipulation;
	}
	html, body {
	  overscroll-behavior: none;
	}
	


    :root {
      --bg-color: #1a1a1a;
      --text-color: #e0e0e0;
      --border-color: #4a4a4a;
      --hover-bg: #333333;
       /* 基础级别 - 提升亮度和饱和度 */
	  --junk: #A1887F;     /* 亮棕色 (原色亮度↑35%) */
	  --old: #BCAAA4;      /* 浅灰棕 (原色亮度↑30%) */
	  --damaged: #D7CCC8;  /* 浅米灰 (原色亮度↑25%) */
	  
	  /* 普通级别 - 增强对比度 */
	  --common: #BDBDBD;   /* 亮灰色 (原色亮度↑30%) */
	  --decent: #66BB6A;   /* 鲜绿色 (原色亮度↑15%) */
	  --sealed: #26A69A;   /* 亮青绿 (原色亮度↑20%) */
	  
	  /* 精良级别 - 保持专业感但提亮 */
	  --selected: #42A5F5; /* 亮蓝色 (原色亮度↑15%) */
	  --tested: #5C6BC0;   /* 浅群青 (原色亮度↑10%) */
	  
	  /* 高级别 - 增强发光效果 */
	  --rare: #AB47BC;     /* 亮紫色 (原色亮度↑10%) */
	  --epic: #EC407A;     /* 品红色 (原色亮度↑10%) */
	  
	  /* 顶级级别 - 保持醒目特性 */
	  --legendary: #FF9800; /* 亮橙色 (原色亮度↑5%) */
	  --divine: #FFEE58;    /* 荧光黄 (原色亮度↑15%) */
      --danger: #d32f2f;
      --warning: #fbc02d;
      --efficiency-green: #66BB6A;
      --production-blue: #42A5F5;
    }
	.log-entry.zombie-event {
	  background-color: rgba(255, 69, 0, 0.2); /* 半透明橙紅色背景 */
	  color: #DAA520; /* Goldenrod，較柔和的金色 */
	  font-weight: bold;
	  border-left: 4px solid #ff4500; /* 用一條醒目的邊框做強調 */
	}

    /* 基礎布局 */
    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: 'Segoe UI', system-ui, sans-serif;
      margin: 0;
      padding: 20px;
      line-height: 1.6;
      min-height: 100vh;
    }
    .container {
      display: grid;
      grid-template-columns: 300px 1fr;
      gap: 25px;
      max-width: 1400px;
      margin: 0 auto;
    }
    /* 資源儀表盤 */
	.main-grid-container {
	  display: grid;
	  grid-template-columns: 1fr 1fr;         /* 兩列等分 */
	  grid-template-rows: auto auto auto;      /* 三行，第二行的高度自動調整，第一行與第二行保持等高 */
	  gap: 20px;
	  margin-top: 20px;
	}
	.grid-container {
	  display: grid;
	  grid-template-columns: 1fr 1fr;
	  grid-auto-rows: minmax(300px, auto);
	  gap: 20px;
	  margin-top: 20px;
	}
	.grid-item {
	  background: #262626;
	  padding: 1rem;
	  border-radius: 12px;
	  border: 1px solid var(--border-color);
	  box-sizing: border-box;
	}
	/* 第一行與第二行的 grid-item  */
	#resourceDashboard,
	#zombieCommand,
	#explorationLogContainer,
	#productionLogContainer {
	  position: relative;
	  /* 固定高度（根據需求調整數值），例如 350px */
	  height: 600px;
	  overflow: hidden;  /* 若內容超出，可自行加入 overflow 設定 */
	}
	/* 基地建設容器，跨兩列 */
	.building-system-container {
	  position: relative;
	  grid-column: 1 / span 2; /* 跨越第1-2列 */
	  /* 固定高度，例如 300px，可根據需要調整 */
	  height: 600px;
	  overflow: auto;
	}
    .dashboard {
      background: #262626;
      padding: 1.5rem;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      height: fit-content;
    }
    .resource-group {
      margin-bottom: 1rem;
      background: #2d2d2d;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .resource-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      cursor: pointer;
      transition: background 0.3s ease;
      background: #373737;
    }
    .resource-header:hover {
      background: var(--hover-bg);
    }
    .resource-details {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .resource-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 15px;
      font-size: 0.9em;
      background: linear-gradient(to right, #2d2d2d 50%, #373737);
      border-top: 1px solid var(--border-color);
    }
    /* 部門管理界面 */
    .operations-panel {
      display: flex;
      flex-direction: column;
	  gap: 10px;          /* 卡片間距 */
	  height: 100%;       /* 或指定固定高度，如350px */
      box-sizing: border-box;
    }
    .department-card {
	  flex: 1;
      background: #262626;
      padding: 0.5rem;
      border-radius: 5px;
	  height:80px
    }
	.dept-header h3 {
	  font-size: 1em;        /* 調小標題字體 */
	  margin: 0;
	  line-height: 1.2;
	}
    .department {
      background: #2d2d2d;
      border-left: 4px solid;
      border-radius: 8px;
      margin: 1rem 0;
      padding: 1rem;
      transition: transform 0.2s;
    }
    .department:hover {
      transform: translateX(5px);
    }
    #exploration { border-color: var(--danger); }
    #farming { border-color: var(--uncommon); }
    #recycling { border-color: var(--warning); }
    #research { border-color: var(--rare); }
    .zombie-control {
      display: flex;
	  justify-content: space-evenly;
      align-items: center;
      gap: 10px;
	  padding: 0 10px;
      margin-top: 12px;
    }
    .zombie-btn {
      width: 28px;
      height: 28px;
      border: none;
      border-radius: 50%;
      background: #404040;
      color: white;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.2s;
    }
    .zombie-btn:hover {
      background: #4a4a4a;
      transform: scale(1.1);
    }
	.large-btn {
	  font-size: 1.2em;
	  padding: 0.6em 1em;
	}

    /* 建築系統 */
    .building-system {
      background: #262626;
      padding: 1.5rem;
      border-radius: 12px;
      border: 1px solid var(--border-color);
    }
    .construction-grid {
      display: grid;
      grid-template-columns: repeat(3, 120px);
      gap: 15px;
      justify-content: center;
    }
    .tile {
      width: 120px;
      height: 120px;
      background: #2d2d2d;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      position: relative;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .tile:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .upgradable {
      border-color: var(--uncommon);
      animation: pulse-border 2s infinite;
    }
    .building-icon {
      font-size: 2.5rem;
      margin-bottom: 8px;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    }
    .building-info { text-align: center; }
    .building-name {
      font-weight: 500;
      font-size: 0.9em;
    }
    .building-level {
      font-size: 0.8em;
      color: var(--common);
    }
    .upgrade-badge {
      position: absolute;
      top: 8px;
      right: 8px;
      background: var(--uncommon);
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      box-shadow: 0 0 10px var(--uncommon);
    }
	 .build-box {
	  border: 1px solid var(--border-color);  /* 始終顯示邊框 */
	  background-color: #2d2d2d;
	  border-radius: 8px;
	  padding: 10px;
	  margin: 10px 0;
	  transition: background 0.2s;
	  cursor: pointer;
	}

	/* 懸停時僅改變背景色，但邊框保持不變 */
	.build-box:hover {
	  background-color: #3a3a3a;
	}

	.build-top {
	  display: flex;
	  align-items: center;
	  gap: 10px;
	  margin-bottom: 5px;
	}

	.build-icon {
	  font-size: 2rem;
	  width: 50px;
	  text-align: center;
	}

	.build-name {
	  font-size: 1.1rem;
	  font-weight: bold;
	}


	.cost-item {
	  display: inline-block;
	  margin-right: 8px;
	}
	
	
	/* 固定每個建造卡片高度 */
	.build-box {
	  height: 150px;
	  display: flex;
	  flex-direction: column;
	  border: 1px solid var(--border-color);
	  border-radius: 8px;
	  margin-bottom: 10px;
	  padding: 10px;
	  cursor: pointer;
	}

	/* 上半部分容器，佔滿剩餘空間並垂直居中 */
	.build-top-container {
	  flex: 1;
	  display: flex;
	  align-items: center;  /* 垂直居中 */
	  justify-content: center;
	}

	/* 下方資源信息部分，不變 */
	.build-resources {
	  text-align: center;
	  margin-top: 5px;
	}

	/* 左右容器，內部分欄 */
	.build-row {
	  display: flex;
	  width: 100%;
	}

	/* 左邊：建築圖示與名稱，50% 寬度，左對齊，右側有分界線 */
	.build-left {
	  flex: 1;
	  text-align: left;
	  border-right: 1px solid var(--border-color);
	  padding-right: 10px;
	}

	/* 右邊：加成描述，50% 寬度，左對齊 */
	.build-right {
	  flex: 1;
	  text-align: left;
	  padding-left: 10px;
	}
	.building-info {
	  display: flex;
	  flex-direction: column;
	  justify-content: center; /* 垂直居中 */
	  text-align: center;
	}




	
    /* 事件日誌系統 */
    .log {
      height: 320px;
      background: #1f1f1f;
      border-radius: 8px;
      padding: 15px;
      margin-top: 1.5rem;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--border-color) transparent;
    }
    .log-entry {
      padding: 10px;
      margin: 8px 0;
      background: #2d2d2d;
      border-left: 3px solid;
      border-radius: 4px;
      animation: fadeIn 0.4s ease;
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-size: 0.9em;
    }
    .log-entry::before {
      content: "•";
      color: currentColor;
      font-weight: bold;
    }
	
	}
    /* 稀有度顏色 */
    /* 基础级别 */
	.junk { color: var(--junk); }
	.old { color: var(--old); }
	.damaged { color: var(--damaged); }

	/* 普通级别 */
	.common { color: var(--common); }
	.decent { color: var(--decent); }
	.sealed { 
	  color: var(--sealed);
	  animation: pulse 1.5s infinite;
	}

	/* 精良级别 */
	.selected { 
	  color: var(--selected);
	  text-shadow: 0 0 5px rgba(30, 136, 229, 0.5);
	}
	.tested {
	  color: var(--tested);
	  animation: float 2s ease-in-out infinite;
	}

	/* 高级别 */
	.rare {
	  color: var(--rare);
	  animation: rare-glow 2s infinite alternate;
	}
	.epic {
	  color: var(--epic);
	  text-shadow: 0 0 8px rgba(142, 36, 170, 0.7);
	  animation: epic-pulse 1.5s infinite;
	}

	/* 顶级级别 */
	.legendary {
	  color: var(--legendary);
	  animation: 
		legendary-glow 2s infinite alternate,
		shake 0.5s infinite alternate;
	}
	.divine {
	  color: var(--divine);
	  text-shadow: 
		0 0 10px rgba(255, 214, 0, 0.8),
		0 0 20px rgba(255, 214, 0, 0.4);
	  animation: 
		divine-shine 3s infinite alternate;
	}

	/* 动画定义 */
	@keyframes pulse {
	  0%, 100% { opacity: 0.9; }
	  50% { opacity: 1; transform: scale(1.02); }
	}
	@keyframes float {
	  0%, 100% { transform: translateY(0); }
	  50% { transform: translateY(-3px); }
	}
	@keyframes rare-glow {
	  from { text-shadow: 0 0 5px rgba(142, 36, 170, 0.3); }
	  to { text-shadow: 0 0 15px rgba(142, 36, 170, 0.7); }
	}
	@keyframes epic-pulse {
	  0%, 100% { transform: scale(1); }
	  50% { transform: scale(1.05); }
	}
	@keyframes legendary-glow {
	  from { text-shadow: 0 0 5px rgba(245, 124, 0, 0.5); }
	  to { text-shadow: 0 0 20px rgba(245, 124, 0, 0.9); }
	}
	@keyframes shake {
	  0% { transform: translateX(-1px); }
	  100% { transform: translateX(1px); }
	}
	@keyframes divine-shine {
	  from { 
		filter: brightness(1);
		text-shadow: 0 0 10px rgba(255, 214, 0, 0.8);
	  }
	  to { 
		filter: brightness(1.2);
		text-shadow: 0 0 25px rgba(255, 214, 0, 1);
	  }
	}
    }
    
  
    @keyframes pulse-border {
      0% { border-color: var(--uncommon); }
      50% { border-color: rgba(76,175,80,0.5); }
      100% { border-color: var(--uncommon); }
    }
    @keyframes resource-glow {
      0% { box-shadow: 0 0 5px currentColor; }
      50% { box-shadow: 0 0 15px currentColor; }
      100% { box-shadow: 0 0 5px currentColor; }
    }
    @media (max-width: 768px) {
      .container { grid-template-columns: 1fr; padding: 10px; }
      .construction-grid { grid-template-columns: repeat(3, 1fr); }
      .tile { width: 100%; height: 100px; }
      .zombie-control { flex-wrap: wrap; }
	}
    @media (max-width: 480px) {
      .building-system { padding: 1rem; }
      .construction-grid { grid-template-columns: repeat(2, 1fr); }
    }
    .efficiency-badge {
      color: var(--efficiency-green);
      font-size: 0.8em;
      padding: 2px 8px;
      border-radius: 4px;
      background: rgba(76,175,80,0.1);
    }
    .production-rate {
      color: var(--production-blue);
      font-size: 0.9em;
      margin-top: 5px;
    }
    .pending-zombies {
      color: var(--warning);
      animation: resource-glow 1.5s infinite;
    }
  </style>
</head>
<body>
  <div class="main-grid-container">
   <!-- 上排：左 - 末日指揮中心；右 - 尸群指揮系統 -->
   <div class="grid-item" id="resourceDashboard">
    <!-- 左側資源面板 -->
    <div class="dashboard">
      <h2 class="section-title">🏚️ 末日指揮中心</h2>
      <div class="resource-panel">
        <div class="resource-group">
          <div class="resource-header" onclick="toggleResource('food')">
            <span class="resource-icon">🍖</span>
            <span class="resource-name">食物</span>
            <span class="resource-count" id="foodCount">0</span>
          </div>
          <div class="resource-details" id="foodDetails"></div>
        </div>
        <div class="resource-group">
          <div class="resource-header" onclick="toggleResource('materials')">
            <span class="resource-icon">🔩</span>
            <span class="resource-name">材料</span>
            <span class="resource-count" id="materialsCount">0</span>
          </div>
          <div class="resource-details" id="materialsDetails"></div>
        </div>
        <div class="resource-group">
          <div class="resource-header" onclick="toggleResource('weapons')">
            <span class="resource-icon">🔫</span>
            <span class="resource-name">武器</span>
            <span class="resource-count" id="weaponsCount">0</span>
          </div>
          <div class="resource-details" id="weaponsDetails"></div>
        </div>
        <div class="resource-group">
          <div class="resource-header" onclick="toggleResource('tech')">
            <span class="resource-icon">💾</span>
            <span class="resource-name">科技</span>
            <span class="resource-count" id="techCount">0</span>
          </div>
          <div class="resource-details" id="techDetails"></div>
        </div>
      </div>
	</div>
   </div>	
	   <div class="grid-item" id="zombieCommand">
		<!-- 尸群指揮系統：操作控制區域 -->
		<div class="operations-panel">
		  <h2 class="section-title">🧟 尸群指揮系統</h2>
		  <div class="production-grid">
			<div class="department-card" id="exploration">
			  <div class="dept-header">
				<h3>🔍 偵察軍團</h3>
				<div class="efficiency-badge" id="exploreEfficiency">效率: 100%</div>
			  </div>
			  <div class="zombie-control">
				<button class="zombie-btn" onclick="adjustZombies('exploration', -1)">−</button>
				<span class="zombie-count" id="explorationCount">0</span>
				<button class="zombie-btn" onclick="adjustZombies('exploration', 1)">+</button>
			  </div>
			</div>
			  <div class="department-card" id="farming">
				<div class="dept-header">
				  <h3>🌾 種植部門</h3>
				  <div class="efficiency-badge" id="farmEfficiency">+0%</div>
				</div>
				<div class="zombie-control">
				  <button class="zombie-btn" onclick="adjustZombies('farming', -1)">−</button>
				  <span class="zombie-count" id="farmingCount">0</span>
				  <button class="zombie-btn" onclick="adjustZombies('farming', 1)">+</button>
				</div>
			  </div>
			  <div class="department-card" id="recycling">
				<div class="dept-header">
				  <h3>♻ 回收工廠</h3>
				  <div class="efficiency-badge" id="recycleEfficiency">+0%</div>
				</div>
				<div class="zombie-control">
				  <button class="zombie-btn" onclick="adjustZombies('recycling', -1)">−</button>
				  <span class="zombie-count" id="recyclingCount">0</span>
				  <button class="zombie-btn" onclick="adjustZombies('recycling', 1)">+</button>
				</div>
			  </div>
			  <div class="department-card" id="research">
				<div class="dept-header">
				  <h3>🔬 科研中心</h3>
				  <div class="efficiency-badge" id="researchEfficiency">+0%</div>
				</div>
				<div class="zombie-control">
				  <button class="zombie-btn" onclick="adjustZombies('research', -1)">−</button>
				  <span class="zombie-count" id="researchCount">0</span>
				  <button class="zombie-btn" onclick="adjustZombies('research', 1)">+</button>
				</div>
			  </div>
			</div>
		 </div>
	  </div>
      <!-- 下排：左 - 行動日誌；右 - 生產日誌 -->
	  <div class="grid-item" id="explorationLogContainer">
		<h3 class="log-title">
		  📜 行動日誌
		 <!-- 在標題右側加入收藏按鈕 -->
		 <button id="favoritesBtn">收藏</button>
		</h3>
		<div class="log-header">
          <span class="zombie-status">待分配僵尸: <span id="pendingZombies">0</span></span>
          <span class="total-zombies">總數: <span id="totalZombies">10</span></span>
        </div>
		<div class="log" id="explorationLog">
		  <div class="log-entry uncommon">✅ 系統初始化完成</div>
		</div>
	 </div>
	  <div class="grid-item" id="productionLogContainer">
	   <h3 class="log-title">🛠 生產日誌
	   <button id="productionFavoritesBtn" class="modal-btn" onclick="showProductionCollection()">收藏</button>
	   </h3>
	   	<div id="timerContainer" class="timer-container">
          <span class="timer-label">用時</span>
          <span id="timerValue">00:00:00</span>
        </div>
	   <div class="log" id="productionLog">
		 <!-- 生產事件將在此顯示 -->
	   </div>
	 </div>
    <div class="grid-item building-system-container" id="buildingSystem">
      <div class="building-system">
        <h2 class="section-title">🏗️ 基地建設</h2>
        <div class="construction-grid" id="buildingGrid">
          <!-- 動態生成的建築格子 -->
        </div>
      </div>
    </div>
  </div>
  
  <!-- 建造彈窗 -->
  <div id="buildModal" class="modal-overlay">
    <div class="modal-content">
      <h3>選擇建造項目</h3>
      <div class="build-options" id="buildOptions"></div>
    </div>
  </div>
  
 
  <!-- 升級彈窗 -->
	<div id="upgradeModal" class="modal-overlay">
	  <div class="modal-content">
		<h3 id="upgradeTitle"></h3>
		<!-- 上半部分：顯示當前加成信息與升級所需資源 -->
		<div id="upgradeInfo" style="white-space: pre-wrap; margin-bottom: 1em;"></div>
		<!-- 下半部分：使用 Flex 對齊兩個按鍵 -->
		<div class="button-row" style="display: flex; justify-content: space-between;">
		  <button id="confirmUpgradeBtn" class="modal-btn large-btn" onclick="confirmUpgrade()" style="flex: 1; margin-right: 5px;">升級</button>
		  <button id="demolishBtn" class="modal-btn large-btn" onclick="confirmBuildingRemoval(currentUpgradeIndex)" style="flex: 1; margin-left: 5px;">拆除</button>
		</div>
	  </div>
	</div>




  <!-- 收藏彈窗 -->
   <div id="favoritesModal" class="modal-overlay">
	 <div class="modal-content">
	 <h3 style="display: flex; justify-content: space-between; align-items: center;">收藏記錄
	 <!-- 新增收藏完成度 -->
       <div id="collectionCompletion" style="display: inline-block; margin-left: 10px; font-weight: bold;"></div>
	 </h3>
	 <div class="collection-content" id="collectionContent">
		  <!-- 收藏內容將在此填充 -->
	 </div>
	</div>
   </div>
   <div id="productionCollectionModal" class="modal-overlay">
    <div class="modal-content">
		<h3>生產記錄</h3>
		<div id="productionCollectionContent"></div>
	  </div>
	</div>

   
  <!-- 建築互動彈窗（管理建築資訊／拆除） -->
	<div id="interactionModal" class="modal-overlay">
	  <div class="modal-content">
		<h3 id="interactionTitle">建築管理</h3>
		<div id="interactionContent"></div>
	  </div>
	</div>
  <!-- 結果提示彈窗 -->
	<div id="resultModal" class="modal-overlay">
	  <div class="modal-content">
		<p id="resultMessage"></p>
		<button class="modal-btn" onclick="closeResultModal()">確定</button>
	  </div>
	</div>



  
  <script>
    let ITEM_DATA = {
	  food: {
		names: ['罐頭食品', '壓縮餅乾', '軍用口糧', '脫水蔬菜', '肉類罐頭', '水果乾', '能量棒', '即食麥片', '奶粉', '速食湯包', '真空包裝米', '乾燥豆類', '堅果混合物', '巧克力塊', '蜂蜜', '果醬', '魚罐頭', '醃製肉類', '乾燥麵條', '速食馬鈴薯泥', '即食粥', '咖啡粉', '茶包', '糖', '鹽', '食用油', '花生醬', '乾酪', '餅乾', '泡麵', '乾燥蘑菇', '風乾肉條', '穀物棒', '乾燥湯塊', '燕麥片', '玉米罐頭', '番茄罐頭', '燉煮豆罐頭', '壓縮乾糧', '黑糖', '葡萄乾', '椰子粉', '芝麻糊', '速食蛋花湯', '乾燥海帶', '凍乾水果', '牛肉乾', '豬肉鬆', '即食布丁', '乾燥馬鈴薯', '速食咖哩', '罐裝煉乳', '乾燥香腸', '速食味噌湯', '罐裝玉米濃湯', '乾燥南瓜', '速食燉飯', '罐裝燉肉', '乾燥洋蔥', '速食馬鈴薯餅', '罐裝蔬菜湯', '乾燥胡蘿蔔', '速食義大利麵', '罐裝鮪魚', '乾燥高麗菜', '速食濃湯', '罐裝紅豆', '乾燥青豆', '速食炒飯', '罐裝沙丁魚', '乾燥菠菜', '速食玉米粥', '罐裝奶油蘑菇湯', '乾燥甜椒', '速食燉蔬菜', '罐裝雞肉', '乾燥蘋果', '速食南瓜湯', '罐裝牛肉醬', '乾燥香蕉片', '速食馬鈴薯沙拉', '罐裝羊肉', '乾燥鳳梨', '速食蔬菜泥', '罐裝海鮮濃湯', '乾燥藍莓', '速食燉牛肉', '罐裝火腿', '乾燥芒果', '速食燉豆', '罐裝奶油玉米', '乾燥草莓', '速食燉雞', '罐裝番茄醬', '乾燥奇異果', '速食燉魚', '罐裝奶油南瓜湯', '乾燥覆盆子', '速食燉馬鈴薯'],
		modifiers: [
		   { name: '冷凍乾燥的', effect: 1.3 },   // 保存技術
		   { name: '輻射變異的', effect: 0.8 },  // 環境影響
		   { name: '軍用密封的', effect: 1.5 },  // 包裝規格
		   { name: '部分霉變的', effect: 0.7 },  // 物理狀態
		   { name: '營養強化的', effect: 1.4 },   // 功能屬性
		   { name: '野戰烹製的', effect: 1.1 },  // 製作方式
		   { name: '黏稠液化的', effect: 0.6 },  // 變質狀態
		   { name: '抗輻射處理的', effect: 1.25 }, // 特殊處理
		   { name: '合成再造的', effect: 1.15 }, // 生產方式
		   { name: '真空脫水的', effect: 1.35 }  // 加工技術
		]
	  },
	  materials: {
		names: ['廢金屬', '電子元件', '聚合物', '鈦合金', '鋁材', '銅線', '鋼板', '橡膠', '玻璃', '陶瓷', '混凝土', '木材', '塑料', '纖維布', '石墨', '矽膠', '鎂合金', '鉛塊', '鋅板', '鎳片', '錫箔', '碳纖維', '不鏽鋼', '彈簧', '軸承', '齒輪', '螺絲', '螺母', '螺栓', '鐵絲', '鋼纜', '鋁箔', '銅管', '鋼管', 'PVC管', '電線', '絕緣膠帶', '焊錫', '潤滑油', '砂紙', '磨刀石', '砂輪', '鑽頭', '鋸片', '鉗子', '扳手', '錘頭', '螺絲刀', '鐵釘', '鉚釘', '鐵鍊', '掛鉤', '滑輪', '皮帶', '彈簧鋼', '鋁合金', '黃銅', '青銅', '鑄鐵', '鍍鋅鋼', '鎢絲', '鉬片', '鈷粉', '稀土磁鐵', '鋰電池', '太陽能板', '電路板', '電容器', '電阻器', '二極管', '晶體管', '集成電路', '馬達', '發電機', '變壓器', '電磁鐵', '絕緣漆', '防火棉', '隔熱板', '防水布', '防彈玻璃', '碳化矽', '氧化鋁', '氮化硼', '石棉', '玻璃纖維', '環氧樹脂', '聚氨酯', '尼龍繩', '凱夫拉纖維', '聚乙烯', '聚丙烯', '聚碳酸酯', '聚酯薄膜', '矽鋼片', '磁性材料', '超導材料', '陶瓷纖維', '耐火磚', '水泥', '石膏板', '瀝青', '砂石', '黏土', '石灰', '磚塊', '大理石', '花崗岩', '石英砂', '矽藻土'],
		modifiers: [
		  { name: '俺拾的', effect: 2.0 },
		  { name: '廢棄的', effect: 1.8 },
		  { name: '高溫鍛壓的', effect: 1.9 },  // 加工工藝
		  { name: '鏽蝕脆化的', effect: 0.7 },  // 劣化狀態
		  { name: '電鍍強化的', effect: 2.0 },  // 表面處理
		  { name: '回收再造的', effect: 1.5 },  // 來源類型
		  { name: '輻射硬化的', effect: 1.8 },  // 環境適應
		  { name: '精密鑄造的', effect: 2.2 },  // 製造精度
		  { name: '應力斷裂的', effect: 0.5 },  // 結構缺陷
		  { name: '碳纖維複合', effect: 2.3 },  // 材料類型
		  { name: '戰前庫存的', effect: 1.7 },  // 時代背景
		  { name: '液壓成型的', effect: 2.1 }   // 成型技術
		]
	  },
	  weapons: {
		names: ['長劍', '短劍', '彎刀', '戰斧', '雙手斧', '匕首', '長矛', '短矛', '戰錘', '釘頭錘', '鏈枷', '鐮刀', '鉤鐮', '戟', '長柄斧', '武士刀', '太刀', '肋差', '西洋刺劍', '闊劍', '手半劍', '羅馬短劍', '維京斧', '飛斧', '投矛', '飛刀', '狼牙棒', '流星錘', '戰鐮', '雙截棍', '三節棍', '鐵鞭', '鐵尺', '峨眉刺', '鉤爪', '袖箭', '弩箭', '複合弓', '反曲弓', '長弓', 'AK-74M', 'AK-105', 'AK-12', 'AK-101', 'AK-103', 'AKS-74U', 'RPK-16', 'SKS', 'VPO-136', 'VPO-209', 'ADAR 2-15', 'TX-15 DML', 'M4A1', 'HK416', 'SCAR-L', 'FN FAL', 'SR-25', 'M1A', 'RSASS', 'SV-98', 'Mosin Nagant', 'VSS Vintorez', 'AS VAL', 'SR-3M', '9A-91', 'VSK-94', 'MP5', 'MP7', 'P90', 'UMP45', 'Vector', 'PP-19-01 Vityaz', 'PP-91 Kedr', 'MPX', 'MP9', 'MP-155', 'Saiga-12', 'TOZ-106', 'Remington 870', 'Mossberg 590', 'Glock 17', 'Glock 18C', 'M9A3', 'P226', 'TT-33', 'APS', 'Five-seveN', 'Desert Eagle', 'RSh-12', 'SVD', 'DVL-10', 'T-5000', 'M700', 'MK18', 'HK G36', 'AUG A3', 'DT MDR', 'MCX', 'SA-58', 'RPD', 'PKM'],
		modifiers: [
		  { name: '生鏽的', effect: 0.9 },
		  { name: '雷射校準的', effect: 1.6 },  // 調試狀態
		  { name: '卡彈改裝的', effect: 0.6 },  // 故障類型
		  { name: '戰術消音的', effect: 1.4 },  // 功能改裝
		  { name: '鏽蝕黏連的', effect: 0.5 },  // 損壞程度
		  { name: '複合材料的', effect: 1.7 },  // 材質特性
		  { name: '強化射速的', effect: 1.8 },  // 射擊模式
		  { name: '防反光處理的', effect: 1.3 },  // 表面處理
		  { name: '雙彈匣系統', effect: 1.5 },  // 結構設計
		  { name: '熱能瞄具的', effect: 1.9 },  // 配件升級
		  { name: '平衡配重的', effect: 1.2 }   // 人體工學
		]
	  },
	  tech: {
		names: ['電路板', '加密芯片', 'AI核心', '量子處理器', '傳感器模組', '伺服馬達', '固態硬盤', '內存條', 'GPU芯片', 'CPU散熱器', '電源模塊', '藍牙模組', 'WiFi天線', '射頻芯片', '光纖收發器', '觸控面板', '液晶屏幕', 'OLED顯示器', '攝像頭模組', '指紋識別器', '聲波馬達', '微型麥克風', '揚聲器單元', '振動電機', '陀螺儀傳感器', '加速度計', '氣壓傳感器', '溫度傳感器', '濕度傳感器', '紅外線發射器', '激光雷達', '毫米波雷達', 'NFC芯片', 'RFID標籤', '生物識別模組', '語音識別芯片', '神經網絡處理器', '邊緣計算單元', '5G基帶芯片', '衛星通信模塊', '無人機飛控', '機械臂控制器', '工業PLC', '機器視覺鏡頭', '3D打印噴頭', 'CNC控制板', '激光切割頭', '電化學傳感器', '光伏電池板', '鋰電池電芯', '超級電容器', '燃料電池堆', '無線充電線圈', '逆變器模塊', '變壓器組件', '繼電器開關', '電磁閥門', '步進電機', '伺服驅動器', '機器人關節模組', '自動駕駛ECU', '車載雷達', '車規級芯片', '航空電子組件', '衛星姿控系統', '火箭導航芯片', '深空通信終端', '量子加密機', '區塊鏈礦機', '雲服務器主板', '數據中心交換機', '光刻機鏡頭', '半導體蝕刻機', '納米壓印設備', '分子篩膜', '碳納米管材料', '石墨烯晶片', '超導體材料', '柔性電子薄膜', '智能纖維織物', '電子皮膚', '腦機接口探針', '醫療影像探頭', '基因測序儀', '納米機器人', '微流控芯片', '生物傳感器', '人工晶狀體', '仿生義肢', '智能假肢', '外骨骼驅動器', 'AR顯示模組', 'VR定位傳感器', '全息投影儀', '激光投影鏡頭', '智能家居中樞', '物聯網網關', '邊緣服務器', 'AI訓練集群', '超級計算機節點', '量子計算單元'],
		modifiers: [
		  { name: '實驗性的', effect: 1.5 },
		  { name: '防火牆破解', effect: 1.8 },   // 軟體狀態
		  { name: '軍用加密的', effect: 2.4 },   // 安全等級
		  { name: '過載燒毀的', effect: 0.3 },   // 損壞類型
		  { name: '模組化設計', effect: 1.7 },   // 結構特性
		  { name: '量子加密的', effect: 2.6 },   // 技術層級
		  { name: '輻射屏蔽的', effect: 1.5 },   // 防護功能
		  { name: '原型機版本的', effect: 1.9 },   // 開發階段
		  { name: '生物識別的', effect: 2.1 },   // 驗證方式
		  { name: '太陽能供電的', effect: 1.4 },   // 能源類型
		  { name: '全息投影的', effect: 2.0 }    // 顯示技術
		]
	  }
	};

	let LOCATIONS = ["废弃超市", "核电站废墟", "地铁隧道", "军事基地", "医院地下室", "科研所遗址", "加油站", "农场谷仓", "廢棄購物中心", "核反應爐冷卻池", "地鐵維修通道", "退役導彈發射井", "精神病院停尸間", "化工實驗室廢墟", "漏油加油站", "穀物黴變倉庫", "銹蝕輸油管道", "坍塌礦山隧道", "廢棄冷凍食品廠", "放射性廢料坑", "城市防空洞群", "軍用雷達站遺址", "焚化爐處理車間", "水庫控制塔", "報廢火車調度場", "抗生素生產線", "鋼鐵廠高爐區", "海底隧道滲水段", "航空燃料儲罐區", "生物製劑實驗室", "晶圓廠無塵室", "纜車中轉機房", "造紙廠汙水池", "地下鈾礦豎井", "跨海大橋橋墩", "電弧爐煉鋼車間", "穀物升降機筒倉", "石化管線加壓站", "報廢船舶拆解場", "放射性汙水井", "山區纜車塔架", "混凝土預拌工廠", "地下配電總站", "戰備糧食儲藏庫", "鐵路信號控制塔", "製藥廠發酵車間", "廢棄紡織印染廠", "山體滑坡掩埋村", "冷戰時期觀察哨", "地下種子基因庫", "港口貨櫃吊裝區", "鋁電解車間廢墟", "河川疏浚設備場", "火力發電煤倉", "廢棄汽車壓縮廠", "深層地質鑽探井", "戰時地下印刷所", "放射性醫療器械庫"];
	let currentUpgradeIndex;
    
	let productionCollection = {};
	
	// 新定義池：增加事件時，僵尸遇到的對象
	const ZOMBIE_ENCOUNTER_POOL = [
	  "流浪的僵尸","孤獨的旅行者","天真的倖存者","迷途的行者","受傷的退伍軍人","帶著染血筆記的科學家","狂熱的末日教徒","改造機車的暴徒","囤藥藥劑師","失語戰地記者","黑市地圖商人","叛逃研究員","免疫體流浪兒","焦慮直升機工程師", "瘋癲尸體畫家", "項圈實驗體", "樂器盒狙擊手", "訊號塔廣播員", "急診室焚尸醫","被感染的護林員", "變異流浪犬", "腐爛救護員", "寄生藤宿主", "嘶吼路燈吊尸"  // 可擴充更多選項
	];

	// 新定義池：減少事件時，僵尸遭遇的不利事件
	const ZOMBIE_DISASTER_POOL = [
	  "暴走的變異獸","大規模的坍塌", "強雷雨天氣","突如其來的颶風","被感染的警犬群","巨型腐爛烏鴉王","寄生藤蔓僵尸樹","成群尸鼠遷徙","黏菌覆蓋的腐化熊","食尸禿鷲群襲擊","軍方燃燒彈地毯轟炸","自動哨戒機槍陣列啟動","地下瓦斯管線大爆炸","高壓電網意外過載","致命抗體空氣傳播","智能無人機群掃蕩","生化溶尸酸雨雲團","精神干擾波無差別攻擊","反僵尸真菌快速蔓延","異種捕食者集團狩獵" // 可擴充更多選項
	];
	
	/***** 全局變量定義 *****/
	function updateResourceCardsBorder() {
	  // 定義稀有度列表，順序從低到高
	  const rarityList = [
		"junk", "old", "damaged", "common",
		"decent", "sealed", "selected", "tested",
		"rare", "epic", "legendary", "divine"
	  ];
	  
	  // 根據 gameState.resetCounts，分別為各資源計算重置次數對應的索引
	  const foodRarity = rarityList[ gameState.resetCounts.food % rarityList.length ];
	  const materialsRarity = rarityList[ gameState.resetCounts.materials % rarityList.length ];
	  const weaponsRarity = rarityList[ gameState.resetCounts.weapons % rarityList.length ];
	  const techRarity = rarityList[ gameState.resetCounts.tech % rarityList.length ];
	  
	  // 根據您的 HTML 結構，此處假定資源卡的父元素為顯示區（例如 resource-header 的容器）
	  const foodCard = document.getElementById("foodCount")?.parentElement;
	  const materialsCard = document.getElementById("materialsCount")?.parentElement;
	  const weaponsCard = document.getElementById("weaponsCount")?.parentElement;
	  const techCard = document.getElementById("techCount")?.parentElement;
	  
	  if (foodCard) {
		// 此處動態組合 CSS 變數名，形如 "var(--junk)"、"var(--old)" 等
		foodCard.style.border = "2px solid var(--" + foodRarity + ")";
	  }
	  if (materialsCard) {
		materialsCard.style.border = "2px solid var(--" + materialsRarity + ")";
	  }
	  if (weaponsCard) {
		weaponsCard.style.border = "2px solid var(--" + weaponsRarity + ")";
	  }
	  if (techCard) {
		techCard.style.border = "2px solid var(--" + techRarity + ")";
	  }
	}


	
	// 固定稀有度數組（共 12 個等級）
	const RARITIES = [
	  "junk", "old", "damaged", "common", "decent",
	  "sealed", "selected", "tested", "rare", "epic",
	  "legendary", "divine"
	];

	function calculateTotalCombinations() {
	  let total = 0;
	  // 遍歷 ITEM_DATA 中所有資源類型
	  for (let res in ITEM_DATA) {
		if (ITEM_DATA.hasOwnProperty(res)) {
		  const data = ITEM_DATA[res];
		  // 物品名稱數量
		  const namesCount = Array.isArray(data.names) ? data.names.length : 0;
		  // 詞綴數量，如果 modifiers 不存在則默認為 0
		  const modifiersCount = Array.isArray(data.modifiers) ? data.modifiers.length : 0;
		  const rarityCount = RARITIES.length; // 固定為12

		  // 計算：物品名+稀有度 與 物品名+詞綴+稀有度
		  const countNameRarity = namesCount * rarityCount;
		  const countNameModifierRarity = namesCount * modifiersCount * rarityCount;

		  const resourceTotal = countNameRarity + countNameModifierRarity;
		  
		  console.log(`${res}：物品名稱數量 = ${namesCount}, 詞綴數量 = ${modifiersCount}, 組合數 = ${resourceTotal}`);
		  total += resourceTotal;
		}
	  }
	  return total;
	}

	// 從 ITEM_DATA 中動態計算所有可能的收藏組合數
	let ALL_COMBINATIONS = calculateTotalCombinations();
	console.log(`ITEM_DATA 全部收藏組合數 = ${ALL_COMBINATIONS}`);


	// 更新收藏記錄完成度的函數
	function updateCollectionCompletion() {
	  // 已收藏項目數量：以 collectedItems 的鍵數量作為計數
	  const obtained = Object.keys(collectedItems).length;
	  // 計算收藏完成率（百分比），避免除數為 0 的情況
	  const total = ALL_COMBINATIONS || 1;
	  const percentage = (obtained / total) * 100;

	  const completionElem = document.getElementById("collectionCompletion");
	  if (completionElem) {
		// 即使數值為 0，也顯示0/總數: 0.0%
		completionElem.textContent = `收集進度: ${obtained}/${total}(${percentage.toFixed(3)}%)`;
	  }
	}

	
	function showTempMessage(message) {
	  let tempDiv = document.createElement("div");
	  tempDiv.style.position = "fixed";
	  tempDiv.style.top = "20%"; // 可根據需要調整顯示位置
	  tempDiv.style.left = "50%";
	  tempDiv.style.transform = "translate(-50%, 0)";
	  tempDiv.style.background = "#333";
	  tempDiv.style.color = "#FFF";
	  tempDiv.style.padding = "1em 2em";
	  tempDiv.style.borderRadius = "12px";
	  tempDiv.style.zIndex = "1100"; // 比升級彈窗層次高
	  tempDiv.style.boxShadow = "0 4px 12px rgba(0,0,0,0.3)";
	  tempDiv.textContent = message;
	  document.body.appendChild(tempDiv);
	  setTimeout(function() {
		tempDiv.parentNode.removeChild(tempDiv);
	  }, 300);
	}


	
	//生產收藏彈窗
	function showProductionCollection() {
	  // 將 productionCollection 轉換為陣列後排序（如依獲取次數從高到低排序）
	  let prodItems = Object.keys(productionCollection).map(key => ({
		name: key,
		count: productionCollection[key]
	  }));
	  
	  prodItems.sort((a, b) => b.count - a.count);
	  
	  // 生成表格 HTML
	  let html = `<table style="width:100%; border-collapse:collapse;"> 
		<thead>
		  <tr>
			<th style="border:1px solid var(--border-color); padding:5px;">物品名稱</th>
			<th style="border:1px solid var(--border-color); padding:5px;">獲得次數</th>
		  </tr>
		</thead>
		<tbody>`;
	  
	  prodItems.forEach(item => {
		html += `<tr>
		  <td style="border:1px solid var(--border-color); padding:5px;">${item.name}</td>
		  <td style="border:1px solid var(--border-color); padding:5px; text-align:right;">${item.count}</td>
		</tr>`;
	  });
	  html += `</tbody></table>`;
	  
	  // 將生成的 HTML 填入生產收藏頁面的內容區域中
	  document.getElementById("productionCollectionContent").innerHTML = html;
	  
	  // 顯示生產收藏彈窗
	  showModal("productionCollectionModal");
	}

	


	const RESOURCE_CAP = 900000000000;  // 所有資源達到此值即認為“達到上限”
	const RESET_VALUE = 100000;     // 重置後每項資源量
	let collectedItems = {};
	let gameState = {
	  resources: { food: 100, materials: 100, weapons: 50, tech: 20 },
	  // 新增：重置次數記錄，初始值為 0
	  resetCounts: { food: 0, materials: 0, weapons: 0, tech: 0 },
	  totalZombies: 10,
	  allocations: { exploration: 4, farming: 4, recycling: 1, research: 1 },
	  buildings: new Array(9).fill(null).map((_, i) =>
		i === 4 ? { type: 'center', level: 1, upgradable: true } : null
	  ),
	  explorationMilestone: 10,
	  efficiency: { food: 1, materials: 1, weapons: 1, tech: 1, exploration: 1 }
	};

	let BUILDINGS = {
	  center: {
		name: '中心基地',
		buildable: false,
		baseCost: { materials: 200, tech: 50 },
		costMultiplier: 1.5,      // 每升級一次，成本乘以1.5
		baseEffect: { capacity: 10, explorationBoost: 0.05 },
		effectMultiplier: 1.02,    // 每升級一次，效果乘以1.2
		getUpgradeInfo: function(currentLevel) {
		  // currentLevel 代表目標升級後的等級
		  return {
			cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  capacity: this.baseEffect.capacity * Math.pow(this.effectMultiplier, currentLevel - 1),
			  explorationBoost: this.baseEffect.explorationBoost * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },

	  barracks: {
		name: '僵尸兵營',
		baseCost: { food: 300, materials: 200 },
		costMultiplier: 1.5,
		baseEffect: { production: 1 },
		// 新增：1级时每秒消耗武器资源比例 (例如 0.05)
		baseWeaponConsumptionRate: 0.05,
		effectMultiplier: 1.02,
		getUpgradeInfo: function(currentLevel) {
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  // 如果目標等級超過中心基地等級則返回 null 表示無法升級
		  if (currentLevel > centerLevel) return null;
		  return {
			cost: {
			  food: Math.floor(this.baseCost.food * Math.pow(this.costMultiplier, currentLevel - 1)),
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  production: this.baseEffect.production * Math.pow(this.effectMultiplier, currentLevel - 1),
			  // 計算等級調整後的武器資源消耗率（例如 1 级时为 baseWeaponConsumptionRate, 后续以 effectMultiplier 指數增長）
			  weaponConsumptionRate: this.baseWeaponConsumptionRate * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },


	  greenhouse: {
		name: '溫室大棚',
		baseCost: { materials: 150, tech: 50 },
		costMultiplier: 1.5,
		baseEffect: { food: 0.1 },
		effectMultiplier: 1.02,
		getUpgradeInfo: function(currentLevel) {
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  if (currentLevel > centerLevel) return null;
		  return {
			cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  food: this.baseEffect.food * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },
	  recyclingFactory: {
	    name: '回收工廠',
	    baseCost: { materials: 150, tech: 50 }, // 與溫室大棚相似的成本
	    costMultiplier: 1.5,                   // 每次升級成本乘以1.5
	    baseEffect: { materials: 0.1 },         // 初始效果：為材料產量加成10%
	    effectMultiplier: 1.02,                 // 每升級一次效果乘以1.2
	    getUpgradeInfo: function(currentLevel) {
		  // 取得中心基地的等級，作為其他建築升級上限的參考
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  // 如果目標等級超過中心基地等級，則返回 null 表示無法升級
		  if (currentLevel > centerLevel) return null;
		  return {
		    cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1))
	        },
		    effect: {
			  // 效果轉為影響材料產量加成
			  materials: this.baseEffect.materials * Math.pow(this.effectMultiplier, currentLevel - 1)
		    }
		  };
	    }
	  },

	  armory: {
		name: '軍械工坊',
		baseCost: { materials: 200, weapons: 50 },
		costMultiplier: 1.5,
		baseEffect: { weapons: 0.15 },
		effectMultiplier: 1.02,
		getUpgradeInfo: function(currentLevel) {
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  if (currentLevel > centerLevel) return null;
		  return {
			cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  weapons: Math.floor(this.baseCost.weapons * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  weapons: this.baseEffect.weapons * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },

	  laboratory: {
		name: '科研實驗室',
		baseCost: { materials: 300, tech: 100 },
		costMultiplier: 1.5,
		baseEffect: { tech: 0.2 },
		effectMultiplier: 1.02,
		getUpgradeInfo: function(currentLevel) {
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  if (currentLevel > centerLevel) return null;
		  return {
			cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  tech: this.baseEffect.tech * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },

	  // 新增：資源增幅站，增加所有資源的產量加成
	  resourceAmplifier: {
		name: '資源增幅站',
		baseCost: { materials: 250, tech: 75 },
		costMultiplier: 1.6,
		baseEffect: { resourceBonus: 0.05 },  // 初始 +5%
		effectMultiplier: 1.02,
		getUpgradeInfo: function(currentLevel) {
		  // 對於這類建築，可以不受中心基地等級的限制（或另外設定限制）
		  return {
			cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  resourceBonus: this.baseEffect.resourceBonus * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },

	  // 新增：僵尸指揮中心，提高獲得僵尸的機率與數量，同時減少損失
	  // 並增加武器資源消耗：1級時每秒消耗0.5%，隨等級提升，消耗率按 effectMultiplier 增長
	  zombieCommandCenter: {
	    name: '僵尸指揮中心',
	    baseCost: { materials: 300, weapons: 50 },
	    costMultiplier: 1.5,
	    baseEffect: { 
	      zombieBoost: 0.05, 
		  zombieLossReduction: 0.1 
	    },
	    // 新增：1級時每秒消耗武器資源 0.5%（即 0.005）
	    baseWeaponConsumptionRate: 0.05,
	    effectMultiplier: 1.015,
	    getUpgradeInfo: function(currentLevel) {
	  	  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  if (currentLevel > centerLevel) return null;
		  return {
		    cost: {
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
			  weapons: Math.floor(this.baseCost.weapons * Math.pow(this.costMultiplier, currentLevel - 1))
		    },
		    effect: {
			  zombieBoost: this.baseEffect.zombieBoost * Math.pow(this.effectMultiplier, currentLevel - 1),
			  zombieLossReduction: this.baseEffect.zombieLossReduction * Math.pow(this.effectMultiplier, currentLevel - 1),
			  // 動態計算武器資源消耗率：1級為 baseWeaponConsumptionRate，之後按 effectMultiplier 指數增長
			  weaponConsumptionRate: this.baseWeaponConsumptionRate * Math.pow(this.effectMultiplier, currentLevel - 1)
		    }
		  };
	    }
	  },


	  // 新增：珍稀庫，提高高稀有度物品獲得率
	  rareVault: {
		name: '珍稀庫',
		baseCost: { tech: 200, materials: 150 },
		costMultiplier: 1.55,
		baseEffect: { rareChanceBoost: 0.05 },  // 初始 +5%
		effectMultiplier: 1.02,
		getUpgradeInfo: function(currentLevel) {
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  if (currentLevel > centerLevel) return null;
		  return {
			cost: {
			  tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1)),
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  rareChanceBoost: this.baseEffect.rareChanceBoost * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },

	  // 新增：武器影響中樞，給予強力生產加成，但持續消耗武器資源
	  weaponConsumptionFacility: {
		name: '武器影響中樞',
		baseCost: { weapons: 100, materials: 300 },
		costMultiplier: 1.7,
		baseEffect: { productionBonus: 0.1, weaponConsumptionRate: 0.02 },
		effectMultiplier: 1.02,
		getUpgradeInfo: function(currentLevel) {
		  const center = gameState.buildings.find(b => b && b.type === "center");
		  const centerLevel = center ? center.level : 1;
		  if (currentLevel > centerLevel) return null;
		  return {
			cost: {
			  weapons: Math.floor(this.baseCost.weapons * Math.pow(this.costMultiplier, currentLevel - 1)),
			  materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1))
			},
			effect: {
			  productionBonus: this.baseEffect.productionBonus * Math.pow(this.effectMultiplier, currentLevel - 1),
			  weaponConsumptionRate: this.baseEffect.weaponConsumptionRate * Math.pow(this.effectMultiplier, currentLevel - 1)
			}
		  };
		}
	  },
	  safetyCenter: {
		  name: '安全中心',
		  // 可根據需求自訂成本，這裡僅提供一個示例
		  baseCost: { materials: 400, tech: 150, weapons: 200 },
		  costMultiplier: 1.6,
		  baseEffect: {
			accidentReduction: 0.05,        // 1級時降低5%
			resourceConsumptionRate: 0.05     // 1級時，每秒消耗0.05×總僵尸數的資源
		  },
		  effectMultiplier: 1.01,  // 升級時效果乘子，例如每升級一次效果乘以1.1
		  getUpgradeInfo: function(currentLevel) {
			const accidentReduction = Math.min(this.baseEffect.accidentReduction * Math.pow(this.effectMultiplier, currentLevel - 1), 0.50);
			const resourceConsumptionRate = Math.min(this.baseEffect.resourceConsumptionRate * Math.pow(this.effectMultiplier, currentLevel - 1), 0.4);
			return {
			  cost: {
				materials: Math.floor(this.baseCost.materials * Math.pow(this.costMultiplier, currentLevel - 1)),
				tech: Math.floor(this.baseCost.tech * Math.pow(this.costMultiplier, currentLevel - 1)),
				weapons: Math.floor(this.baseCost.weapons * Math.pow(this.costMultiplier, currentLevel - 1))
			  },
			  effect: {
				accidentReduction: accidentReduction,
				resourceConsumptionRate: resourceConsumptionRate
			  }
			};
		  }
		}  
	  
	};
	

	/***** 探索隊及僵尸事件處理 *****/
	function addEventLog(message, rarity, eventType = "exploration", applyZombieStyle = false) {
	  let logContainerId = (eventType === "production") ? "productionLog" : "explorationLog";
	  const logElem = document.getElementById(logContainerId);
	  if (logElem) {
		 const maxLogs = 100;
		while (logElem.childElementCount >= maxLogs) {
		  logElem.removeChild(logElem.firstChild);
		}
		// 定義稀有度映射對象
		const rarityMapping = {
		  junk: "[破爛的]",
		  old: "[陳舊的]",
		  damaged: "[破損的]",
		  common: "[正常的]",
		  decent: "[看起來不錯的]",
		  sealed: "[未開封的]",
		  selected: "[精挑細選的]",
		  tested: "[歷經考驗的]",
		  rare: "[稀有的]",
		  epic: "[史詩的]",
		  legendary: "[傳奇的]",
		  divine: "[神聖的]"
		};
		const formattedMessage = message.replace(
		  new RegExp(rarity + "\\b"), 
		  rarityMapping[rarity] || rarity
		);
		
		const div = document.createElement("div");
		div.className = `log-entry ${rarity}`;
		if(eventType === "zombie") {
		  div.className += " zombie-event";
		}
		if(applyZombieStyle) {
		  div.className += " zombie-event";
		}
		div.textContent = formattedMessage;
		
		logElem.appendChild(div);
		logElem.scrollTop = logElem.scrollHeight;
	  }
	}

	function logResource(resource, itemName, amount, eventType = "production") {
	  addEventLog(`生產: ${itemName} +${amount} ${resource}`, 'common', eventType);
	  if (!productionCollection[itemName]) {
		productionCollection[itemName] = 0;
	  }
	  productionCollection[itemName] += 1;
	}

    function checkUpgradable(type, level) {
	  const centerBuilding = gameState.buildings.find(b => b && b.type.toLowerCase() === "center");
	  const centerLevel = centerBuilding ? centerBuilding.level : 1;

	  if (type === "center") {
		return true; // 讓中心基地無限制升級
	  } else {
		return level < centerLevel; // 其他建築等級不能超過中心基地
	  }
	}

	// 根據稀有度權重隨機選取一個稀有度
	function weightedRandomRarity() {
	  const weights = {
		junk: 25,
		old: 20,
		damaged: 15,
		common: 15,
		decent: 10,
		sealed: 5,
		selected: 4,
		tested: 3,
		rare: 2,
		epic: 0.5,
		legendary: 0.3,
		divine: 0.2
	  };
	  let total = Object.values(weights).reduce((a, b) => a + b, 0);
	  let rand = Math.random() * total;
	  return Object.keys(weights).find(key => (rand -= weights[key]) < 0);
	}

	// 根據稀有度倍率計算最終數值
	function applyRarityMultiplier(base, rarity) {
	  const multipliers = {
		junk: 1,
		old: 1.5,
		damaged: 2,
		common: 2.5,
		decent: 3,
		sealed: 3.5,
		selected: 4,
		tested: 5,
		rare: 6,
		epic: 8,
		legendary: 10,
		divine: 12
	  };
	  return base * multipliers[rarity];
	}

	// 根據隊伍規模產生僵尸變化（增加或損失）
	function generateZombieChange(teamSize) {
	  if (Math.random() < 0.4) {
		return Math.random() < 0.6
		  ? Math.floor(teamSize * (0.001 + Math.random() * 1.9))
		  : -Math.floor(teamSize * (0.001 + Math.random() * 0.7));
	  }
	  return 0;
	}
	
	/**
	 * 根據類型和數量生成探索事件中的僵尸變化描述
	 * @param {string} type - "increase" 或 "decrease"
	 * @param {number} quantity - 變化的僵尸數量（正數，若減少則傳入絕對值）
	 * @returns {string} - 格式化的描述字符串
	 */
	function generateZombieEventDescription(type, quantity) {
	  // 隨機選用一個地點
	  const location = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
	  
	  if (type === "increase") {
		const encounter = ZOMBIE_ENCOUNTER_POOL[Math.floor(Math.random() * ZOMBIE_ENCOUNTER_POOL.length)];
		return `你派出的僵尸在 ${location} 遇到 ${encounter}，獲得 ${quantity} 僵尸。`;
	  } else if (type === "decrease") {
		const disaster = ZOMBIE_DISASTER_POOL[Math.floor(Math.random() * ZOMBIE_DISASTER_POOL.length)];
		return `你派出的僵尸在 ${location} 遭遇 ${disaster}，損失 ${quantity} 僵尸。`;
	  } else {
		return "";
	  }
	}

	// 生成探索結果，包括獲得資源、數量與可能的僵尸變化
	function generateExplorationResult(teamSize) {
	  const location = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
	  const resourceTypes = ['food', 'materials', 'weapons', 'tech'];
	  const resource = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
	  const rarity = weightedRandomRarity();
	  const baseAmount = Math.floor(Math.random() * 11) + 5;
	  const multiplier = Math.pow(1.005, teamSize);
	  const computed = applyRarityMultiplier(baseAmount, rarity) * multiplier;
	  const amount = convertProduction(computed);
	  const itemName = getRandomItemName(resource);
	  const modifier = getRandomModifier(resource);
	  const zombieChange = generateZombieChange(teamSize);
	  
	  return {
		resource,
		amount,
		rarity,
		zombieChange,
		log: {
		  text: `探索 ${location} 獲得 ${modifier.name} ${itemName} +${amount} ${resource}`,
		  zombieText: zombieChange > 0 
					? `⚡ 獲得 ${zombieChange} 僵尸`
					: zombieChange < 0 
					  ? `☠️ 損失 ${Math.abs(zombieChange)} 僵尸`
					  : null,
		  rarity
		}
	  };
	}

    /***** 輔助函數 *****/
    function convertProduction(val) {
      return (val > 0 && val < 1) ? 1 : Math.floor(val);
    }
    function formatNumber(num) {
	  if (num < 10000) {
		return parseFloat(num.toFixed(3));
	  } else if (num < 100000000) {
		// 萬 ~ 億
		if (num < 1000000) {
		  let wan = num / 10000;
		  return wan.toFixed(Math.max(3 - Math.floor(wan).toString().length, 0)) + "萬";
		} else if (num < 10000000) {
		  let baiwan = num / 1000000;
		  return baiwan.toFixed(Math.max(3 - Math.floor(baiwan).toString().length, 0)) + "百萬";
		} else {
		  let qianwan = num / 10000000;
		  return qianwan.toFixed(Math.max(3 - Math.floor(qianwan).toString().length, 0)) + "千萬";
		}
	  } else if (num < 1000000000000) {
		// 億 ~ 兆
		if (num < 10000000000) {
		  let yi = num / 100000000;
		  return yi.toFixed(Math.max(3 - Math.floor(yi).toString().length, 0)) + "億";
		} else if (num < 100000000000) {
		  let shiyi = num / 1000000000;
		  return shiyi.toFixed(Math.max(3 - Math.floor(shiyi).toString().length, 0)) + "十億";
		} else {
		  let baiyi = num / 10000000000;
		  return baiyi.toFixed(Math.max(3 - Math.floor(baiyi).toString().length, 0)) + "百億";
		}
	  } else if (num < 10000000000000000) {
		// 兆 ~ 京
		if (num < 100000000000000) {
		  let zhao = num / 1000000000000;
		  return zhao.toFixed(Math.max(3 - Math.floor(zhao).toString().length, 0)) + "兆";
		} else if (num < 1000000000000000) {
		  let shizhao = num / 10000000000000;
		  return shizhao.toFixed(Math.max(3 - Math.floor(shizhao).toString().length, 0)) + "十兆";
		} else {
		  let baizhao = num / 100000000000000;
		  return baizhao.toFixed(Math.max(3 - Math.floor(baizhao).toString().length, 0)) + "百兆";
		}
	  } else {
		// 京及以上
		if (num < 1000000000000000000) {
		  let jing = num / 10000000000000000;
		  return jing.toFixed(Math.max(3 - Math.floor(jing).toString().length, 0)) + "京";
		} else if (num < 10000000000000000000) {
		  let shijing = num / 100000000000000000;
		  return shijing.toFixed(Math.max(3 - Math.floor(shijing).toString().length, 0)) + "十京";
		} else {
		  // 超出JavaScript安全整數範圍時改用科學計數法
		  return num.toExponential(3).replace('e+', '×10^');
		}
	  }
	}
    function canAfford(cost) {
      return Object.entries(cost).every(([res, val]) => gameState.resources[res] >= val);
    }
    function payCost(cost) {
      Object.entries(cost).forEach(([res, val]) => {
        gameState.resources[res] -= val;
      });
    }
    function getRandomItemName(resource) {
      return ITEM_DATA[resource].names[Math.floor(Math.random() * ITEM_DATA[resource].names.length)];
    }
    function getRandomModifier(resource) {
      const modifiers = ITEM_DATA[resource].modifiers;
      return modifiers[Math.floor(Math.random() * modifiers.length)];
    }

    /***** 探索隊自動重分配事件 *****/
    function checkExplorationMilestone() {
      while (gameState.allocations.exploration >= gameState.explorationMilestone) {
        let remove = Math.min(5, gameState.allocations.exploration);
        let gained = remove;
        let toExploration = Math.round(gained * 0.5);
        let toFarming = Math.round(gained * 0.3);
        let toRecycling = Math.round(gained * 0.1);
        let toResearch = Math.round(gained * 0.1);
        let sum = toExploration + toFarming + toRecycling + toResearch;
        if(sum < gained) {
          toExploration += (gained - sum);
        } else if(sum > gained) {
          toExploration -= (sum - gained);
        }
        gameState.allocations.exploration -= remove;
        gameState.allocations.exploration += toExploration;
        gameState.allocations.farming += toFarming;
        gameState.allocations.recycling += toRecycling;
        gameState.allocations.research += toResearch;
        addEventLog(`探索隊達到 ${gameState.explorationMilestone} 隻，自動重分配：探索保留 ${toExploration}, 種植+${toFarming}, 回收+${toRecycling}, 科研+${toResearch}`, 'uncommon');
        gameState.explorationMilestone += 10;
      }
    }
  
    /***** 兵營產生僵尸 *****/
    function produceZombies() {
      const production = gameState.buildings.reduce((sum, b) => {
        if (b && b.type === 'barracks') {
           const info = BUILDINGS.barracks.getUpgradeInfo(b.level);
		  // 如果 info 存在，使用其 effect.production；否則視為 0
		  const prod = info && info.effect && info.effect.production ? info.effect.production : 0;
		  return sum + prod;
		}
		return sum;
	  }, 0);
	  const newZombies = Math.floor(production);
      if (newZombies > 0) {
        let gained = newZombies;
        let toExploration = Math.round(gained * 0.7);
        let toFarming = Math.round(gained * 0.1);
        let toRecycling = Math.round(gained * 0.1);
        let toResearch = Math.round(gained * 0.1);
        let sum = toExploration + toFarming + toRecycling + toResearch;
        if(sum < gained) {
          toExploration += (gained - sum);
        } else if(sum > gained) {
          toExploration -= (sum - gained);
        }
        gameState.totalZombies += gained;
        gameState.allocations.exploration += toExploration;
        gameState.allocations.farming += toFarming;
        gameState.allocations.recycling += toRecycling;
        gameState.allocations.research += toResearch;
        addEventLog(`兵營生產：新增 ${gained} 僵尸，探索保留 ${toExploration}, 種植+${toFarming}, 回收+${toRecycling}, 科研+${toResearch}`, 'uncommon');
      }
      updateResourceDisplays();
    }
  
    /***** 探索事件處理 *****/
	function generateExplorationResult(teamSize) {
	  const location = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
	  const resourceTypes = ['food', 'materials', 'weapons', 'tech'];
	  const resource = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
	  const rarity = weightedRandomRarity();
	  const baseAmount = Math.floor(Math.random() * 5) + 5;
	  const multiplier = Math.pow(1.05, teamSize);
	  const computed = applyRarityMultiplier(baseAmount, rarity) * multiplier;
	  const amount = convertProduction(computed);
	  const itemName = getRandomItemName(resource);
	  const modifier = getRandomModifier(resource);
	  const zombieChange = generateZombieChange(teamSize);

	  return {
		resource,
		amount,
		rarity,
		zombieChange,
		// 將獲得物品名稱整合後存入 item 屬性
		item: `${modifier.name} ${itemName}`,
		log: {
		  text: `探索 ${location} 獲得 ${rarity} ${modifier.name} ${itemName} +${amount} ${resource}`,
		  zombieText: zombieChange > 0 
			? `⚡ 獲得 ${zombieChange} 僵尸` 
			: zombieChange < 0 
			  ? `☠️ 損失 ${Math.abs(zombieChange)} 僵尸` 
			  : null,
		  rarity
		}
	  };
	}

    function handleExploration() {
       // ...其他處理邏輯
	  const teamSize = gameState.allocations.exploration;
	  if (teamSize < 1) return;
	  const result = generateExplorationResult(teamSize);
	  // 進行資源加減等等
	  gameState.resources[result.resource] += result.amount;
	  addEventLog(result.log.text, result.rarity, "exploration");
	  
	  // 更新收藏記錄
	  if (result.item) {
		if (collectedItems[result.item]) {
		  collectedItems[result.item].count += 1;
		} else {
		  collectedItems[result.item] = { count: 1, rarity: result.rarity };
		}
	  }
	  
	  // 處理僵尸變化描述（增加或減少）
	  if (result.zombieChange !== 0) {
		let desc = "";
		if (result.zombieChange > 0) {
		  desc = generateZombieEventDescription("increase", result.zombieChange);
		  // 增加僵尸邏輯
		  gameState.totalZombies += result.zombieChange;
		  gameState.allocations.exploration += result.zombieChange; // 依實際邏輯分配
		} else {
		  const loss = Math.abs(result.zombieChange);
		  desc = generateZombieEventDescription("decrease", loss);
		  // 減少僵尸邏輯
		  gameState.totalZombies -= loss;
		  gameState.allocations.exploration = Math.max(0, gameState.allocations.exploration - loss);
		}
		// 加入日誌顯示新的描述內容
		addEventLog(desc, "uncommon", "zombie");
	  }
	  
	  updateAllDisplays();
	}
  
    /***** 資源生產 *****/
    function produceResources(dept, resource, baseRate) {
      const count = gameState.allocations[dept];
      if (count <= 0) return;
      const multiplier = Math.pow(1.0005, count);
      const computed = baseRate * multiplier * gameState.efficiency[resource];
      const amount = convertProduction(computed);
      if (Math.random() < 0.05) {
        const modifier = getRandomModifier(resource);
        const modAmount = convertProduction(amount * modifier.effect);
        logResource(resource, `${modifier.name} ${getRandomItemName(resource)}`, modAmount, "production");
      } else {
        logResource(resource, getRandomItemName(resource), amount, "production");
      }
      gameState.resources[resource] += amount;
	  
	  // 新增隨機事件：僵尸損失（僅對種植、回收、科研部門）
	  if (dept === "farming" || dept === "recycling" || dept === "research") {
	  const baseEventProbability = 0.005; // 基礎事故觸發機率
	  // 根据部門僵尸數量，在基礎概率上加成，假設每隻僵尸增加 0.01 的概率
	  const deptZombies = gameState.allocations[dept] || 0;
	  let eventProbability = baseEventProbability + (deptZombies * 0.001);
	  // 防止機率超過 100%
	  eventProbability = Math.min(eventProbability, 0.8);

	  let lossMultiplier = 1;
	  
	  // 如安全中心存在，則按其效果降低事故觸發機率
	  const safety = gameState.buildings.find(b => b && b.type.toLowerCase() === "safetycenter");
	  if (safety) {
		const safetyInfo = BUILDINGS.safetyCenter.getUpgradeInfo(safety.level);
		const reduction = safetyInfo.effect.accidentReduction; // 如降幅 0.05 表示事故機率乘以 0.95
		eventProbability *= (1 - reduction);
		lossMultiplier = (1 - reduction);
	  }
	  
	  if (Math.random() < eventProbability) {
		// 隨機損失比例介於 5% 到 80%
		const lossPercentage = 0.01 + Math.random() * 0.8;
		// 根據該部門僵尸數計算損失量（lossMultiplier 可在未來用於進一步調整損失量）
		let lost = Math.floor(gameState.allocations[dept] * lossPercentage * lossMultiplier);
		// 若計算後的損失為 0，但部門中仍有僵尸，最低可以考慮損失 1（或保持 0 視具體需求而定）
		if (lost < 1 && gameState.allocations[dept] > 0) {
		  lost = 1;
		}
		gameState.allocations[dept] -= lost;
		gameState.totalZombies -= lost;
		
		let eventMsg = "";
		if (dept === "farming") {
		  eventMsg = `發生食物中毒：種植部門損失 ${lost} 僵尸 (${(lossPercentage * 100).toFixed(1)}%)`;
		} else if (dept === "recycling") {
		  eventMsg = `發生意外事故：回收部門損失 ${lost} 僵尸 (${(lossPercentage * 100).toFixed(1)}%)`;
		} else if (dept === "research") {
		  eventMsg = `發生爆炸事故：科研部門損失 ${lost} 僵尸 (${(lossPercentage * 100).toFixed(1)}%)`;
		}
		addEventLog(eventMsg, "warning", "production", true);
	  }
	}	  
      updateResourceDisplays();
    }
	function updateSafetyCenterConsumption() {
	  // 檢查安全中心是否存在
	  const safety = gameState.buildings.find(b => b && b.type.toLowerCase() === "safetycenter");
	  if (!safety) return;
	  
	  const safetyInfo = BUILDINGS.safetyCenter.getUpgradeInfo(safety.level);
	  const consumptionRate = safetyInfo.effect.resourceConsumptionRate; // 每秒消耗百分比，如基礎 0.05，最高 0.4
	  
	  // 根據僵尸總數，對四種資源計算消耗量
	  const resourceList = ["food", "materials", "weapons", "tech"];
	  resourceList.forEach(res => {
		// 消耗量 = consumptionRate * totalZombies
		const toConsume = consumptionRate * gameState.totalZombies;
		gameState.resources[res] = Math.max(0, gameState.resources[res] - toConsume);
	  });
	  
	  updateResourceDisplays();
	}
	function updateBarracksWeaponConsumption() {
	  // 篩選出所有“barracks”建築
	  const barracksBuildings = gameState.buildings.filter(b => b && b.type.toLowerCase() === "barracks");
	  if (barracksBuildings.length === 0) return;
	  
	  let totalConsumption = 0;
	  
	  // 對每棟僵尸兵營依據其等級計算消耗率（取 getUpgradeInfo 計算的消耗率）
	  barracksBuildings.forEach(b => {
		// 若僵尸兵營的升級資訊可求得，則讀取該棟建築的武器資源消耗率
		const upgradeInfo = (typeof BUILDINGS[b.type].getUpgradeInfo === "function") 
							 ? BUILDINGS[b.type].getUpgradeInfo(b.level)
							 : null;
		if (upgradeInfo && upgradeInfo.effect.weaponConsumptionRate) {
		  totalConsumption += upgradeInfo.effect.weaponConsumptionRate;
		}
	  });
	  
	  // 以總僵尸數為基礎，計算累計的武器資源消耗量
	  // 例如：總消耗 = totalConsumption * gameState.totalZombies
	  const consumption = totalConsumption * gameState.totalZombies;
	  
	  // 從玩家的武器資源中扣除
	  gameState.resources.weapons = Math.max(0, gameState.resources.weapons - consumption);
	  
	  // 更新資源顯示
	  updateResourceDisplays();
	}


    function checkResourceCap() {
	// 檢查所有資源是否均達到 RESOURCE_CAP
	  if (
		gameState.resources.food >= RESOURCE_CAP &&
		gameState.resources.materials >= RESOURCE_CAP &&
		gameState.resources.weapons >= RESOURCE_CAP &&
		gameState.resources.tech >= RESOURCE_CAP
	  ) {
		// 重置所有資源為 RESET_VALUE
		gameState.resources.food = RESET_VALUE;
		gameState.resources.materials = RESET_VALUE;
		gameState.resources.weapons = RESET_VALUE;
		gameState.resources.tech = RESET_VALUE;
		
		// 累加每一項資源的重置次數
		gameState.resetCounts.food++;
		gameState.resetCounts.materials++;
		gameState.resetCounts.weapons++;
		gameState.resetCounts.tech++;

		// 更新資源卡的邊框樣式
		updateResourceCardsBorder();
	  }
	}

    /***** 食物消耗與僵尸損失 *****/
    function updateFoodConsumption() {
      let foodNeeded = Math.floor(gameState.totalZombies * 0.6);
      if (foodNeeded > 0 && gameState.resources.food >= foodNeeded) {
        gameState.resources.food -= foodNeeded;
        addEventLog(`消耗食物：${foodNeeded}`, 'common');
      } else if (gameState.resources.food <= 0) {
        let removeNum = Math.ceil(gameState.totalZombies * 0.2);
        if (removeNum < 1) removeNum = 1;
        let priorities = ['exploration', 'research', 'recycling', 'farming'];
        for (let dept of priorities) {
          let available = gameState.allocations[dept] || 0;
          if (available >= removeNum) {
            gameState.allocations[dept] -= removeNum;
            gameState.totalZombies -= removeNum;
            addEventLog(`食物耗盡，${dept}失去 ${removeNum} 僵尸`, 'epic');
            removeNum = 0;
            break;
          } else {
            gameState.totalZombies -= available;
            addEventLog(`食物耗盡，${dept}失去 ${available} 僵尸`, 'epic');
            removeNum -= available;
            gameState.allocations[dept] = 0;
          }
        }
        if (gameState.totalZombies <= 0) {
          addEventLog("所有僵尸均已死亡，遊戲結束！", "epic");
          clearInterval(gameLoopInterval);
        }
      }
      updateResourceDisplays();
    }
  
    /***** 更新顯示 *****/
    function updateResourceDisplays() {
      document.getElementById("foodCount").textContent = formatNumber(gameState.resources.food);
      document.getElementById("materialsCount").textContent = formatNumber(gameState.resources.materials);
      document.getElementById("weaponsCount").textContent = formatNumber(gameState.resources.weapons);
      document.getElementById("techCount").textContent = formatNumber(gameState.resources.tech);
      document.getElementById("totalZombies").textContent = formatNumber(gameState.totalZombies);
      const totalAllocated = gameState.allocations.exploration +
                             gameState.allocations.farming +
                             gameState.allocations.recycling +
                             gameState.allocations.research;
      document.getElementById("pendingZombies").textContent = formatNumber(gameState.totalZombies - totalAllocated);
    
	// 檢查並（如有必要）重置資源
	checkResourceCap();
	}
  
    function updateEfficiencyDisplays() {
      document.getElementById("exploreEfficiency").textContent = "效率: " + Math.floor(gameState.efficiency.exploration * 100) + "%";
      document.getElementById("farmEfficiency").textContent = "+" + Math.floor((gameState.efficiency.food - 1) * 100) + "%";
      document.getElementById("recycleEfficiency").textContent = "+" + Math.floor((gameState.efficiency.materials - 1) * 100) + "%";
      document.getElementById("researchEfficiency").textContent = "+" + Math.floor((gameState.efficiency.tech - 1) * 100) + "%";
    }
  
    function updateAllDisplays() {
      updateResourceDisplays();
      document.getElementById("explorationCount").textContent = gameState.allocations.exploration;
      document.getElementById("farmingCount").textContent = gameState.allocations.farming;
      document.getElementById("recyclingCount").textContent = gameState.allocations.recycling;
      document.getElementById("researchCount").textContent = gameState.allocations.research;
      updateEfficiencyDisplays();
      initBuildingGrid();
      checkExplorationMilestone();
    }
  
    /***** 建築管理系統 *****/
    function initBuildingGrid() {
      const grid = document.getElementById('buildingGrid');
      grid.innerHTML = '';
      gameState.buildings.forEach((building, index) => {
        const tile = document.createElement('div');
        tile.className = `tile ${building?.upgradable ? 'upgradable' : ''}`;
        tile.setAttribute('data-index', index);
        tile.onclick = () => {
          console.log("Tile clicked, index:", index);
          handleBuildingClick(index);
        };
        if (building) {
          const config = BUILDINGS[building.type];
          tile.innerHTML = `
            <div class="building-icon">${getBuildingIcon(building.type)}</div>
            <div class="building-info">
              <div>${config.name}</div>
              <div class="building-level">Lv.${building.level}</div>
            </div>
            ${building.upgradable ? '<div class="upgrade-indicator">↑</div>' : ''}
          `;
        } else {
          tile.innerHTML = `
            <div class="empty-plot">🟦</div>
            <div class="plot-label">空地</div>
          `;
        }
        grid.appendChild(tile);
      });
    }
  
    function handleBuildingClick(index) {
	  const building = gameState.buildings[index];
	  if (!building) {
		return showBuildMenu(index);
	  }
	  // 直接使用升級彈窗顯示資訊和操作（拆除按鈕也整合進來）
	  showUpgradeMenu(index);
	}

  
	function showBuildMenu(index) {
	  // 過濾具有 baseCost 的建築，排除中心基地（center）
	  const available = Object.entries(BUILDINGS)
		.filter(([key, cfg]) => cfg.baseCost && key.toLowerCase() !== "center");

	  const modalContent = available.map(([key, cfg]) => {
		// 取得1級加成信息（如果存在）
		let bonusInfo = "";
		if (typeof cfg.getUpgradeInfo === "function") {
		  const info = cfg.getUpgradeInfo(1);
		  if (info && info.effect) {
			bonusInfo = Object.entries(info.effect)
			  .map(([attr, value]) => `${attr}: +${value}`)
			  .join("<br>");
		  }
		}
		return `
		  <div class="build-box" onclick="startBuilding('${key}', ${index})">
			<div class="build-top-container">
			  <div class="build-row">
				<!-- 左側 50%：建築圖示與名稱 -->
				<div class="build-left">
				  <span class="build-icon">${getBuildingIcon(key)}</span>
				  <span class="build-name" style="margin-left:5px; font-weight:bold;">${cfg.name}</span>
				</div>
				<!-- 右側 50%：1級加成描述 -->
				<div class="build-right">
				  ${bonusInfo}
				</div>
			  </div>
			</div>
			<!-- 下方顯示建造所需物資 -->
			<div class="build-resources">
			  ${Object.entries(cfg.baseCost)
				.map(([res, val]) => `<span class="cost-item" style="margin-right: 8px;">${res}: ${val}</span>`)
				.join(' ')}
			</div>
		  </div>
		`;
	  }).join('');
		
	  document.getElementById('buildOptions').innerHTML = modalContent;
	  showModal("buildModal");
	}





	function startBuilding(type, index) {
	  const config = BUILDINGS[type];
	  // 使用 baseCost 來判定初始建造成本
	  if (!canAfford(config.baseCost)) {
		addEventLog(`❌ 資源不足，無法建造 ${config.name}`, 'epic');
		return;
	  }
	  payCost(config.baseCost);
	  gameState.buildings[index] = {
		type,
		level: 1,
		upgradable: checkUpgradable(type, 1)
	  };
	  updateEfficiencies();
	  addEventLog(`🏗️ 成功建造 ${config.name}`, 'uncommon');
	  closeModal('buildModal');
	  updateAllDisplays();
	  
	  // 透過彈窗提示建造成功
	  showResultModal(`成功建造 ${config.name}`);
	}

  
    function updateEfficiencies() {
	  // 重置所有效率
	  Object.keys(gameState.efficiency).forEach(k => gameState.efficiency[k] = 1);

	  // 獲取中心基地等級（若不存在則為1）
	  const centerBuilding = gameState.buildings.find(b => b?.type === "center");
	  const centerLevel = centerBuilding ? centerBuilding.level : 1;

	  // 初始化加成變數
	  let explorationBoost = 0;
	  let researchBoost = 0;
	  let zombieEfficiency = 0;
	  let productionBonus = 0;

	  gameState.buildings.forEach(b => {
		if (!b) return; // 跳過空地

		const upgradeInfo = (typeof BUILDINGS[b.type].getUpgradeInfo === "function")
                      ? BUILDINGS[b.type].getUpgradeInfo(b.level)
                      : null;
		const effects = upgradeInfo?.effect || {};


		// 確保一般效率被更新
		Object.entries(effects).forEach(([key, value]) => {
		  gameState.efficiency[key] = (gameState.efficiency[key] || 1) + value;
		});

		// 若是中心基地，累積特殊加成
		if (b.type === "center") {
		  explorationBoost += effects.explorationBoost || 0;
		  researchBoost += effects.researchBoost || 0;
		  zombieEfficiency += effects.zombieEfficiency || 0;
		  productionBonus += effects.productionBonus || 0;
		}
	  });

	  // 應用中心基地加成
	  gameState.explorationEfficiency = 1 + explorationBoost;
	  gameState.researchEfficiency = 1 + researchBoost;
	  gameState.zombieEfficiency = 1 + zombieEfficiency;
	  gameState.productionEfficiency = 1 + productionBonus;

	  // 限制其他建築的最高等級
	  gameState.buildings.forEach(b => {
		if (b && b.type !== "center" && b.level > centerLevel) {
		  b.level = centerLevel; // 限制最大等級
		}
	  });
	}

  
    function getBuildingIcon(type) {
	  const icons = {
		center: "🏰",
		barracks: "🏫",
		greenhouse: "🌿",
		armory: "🔧",
		laboratory: "🔬",
		resourceamplifier: "📈",       // 替換為更常見的符號
		zombiecommandcenter: "🧟",
		rarevault: "💎",
		weaponconsumptionfacility: "⚔️", // 改為交叉劍
		safetycenter: "🛡️",
		recyclingfactory: "♻️"
	  };
	  return icons[type.toLowerCase()] || "🟦";
	}


	
	// 更新所有建築的升級狀態，根據主基地當前等級來決定
	function updateBuildingsAfterMainBaseUpgrade() {
	  // 找出主基地並獲取當前等級（不區分大小寫）
	  const centerBuilding = gameState.buildings.find(b => b && b.type.toLowerCase() === "center");
	  const centerLevel = centerBuilding ? centerBuilding.level : 1;

	  // 遍歷所有建築，非主基地的 upgradable 狀態由自身等級與主基地等級決定
	  gameState.buildings.forEach(b => {
		if (b && b.type.toLowerCase() !== "center") {
		  b.upgradable = (b.level < centerLevel);
		}
	  });
	}
	
	function confirmUpgrade() {
	  if (typeof currentUpgradeIndex === "undefined") return;
	  
	  const index = currentUpgradeIndex;
	  const building = gameState.buildings[index];
	  const config = BUILDINGS[building.type];
	  const nextUpgrade = (typeof config.getUpgradeInfo === "function")
							? config.getUpgradeInfo(building.level + 1)
							: null;
							
	  if (!nextUpgrade || !nextUpgrade.cost) {
		// 無法升級（可能已達頂級）
		showTempMessage("升級失敗");
		return;
	  }
	  
	  if (!canAfford(nextUpgrade.cost)) {
		showTempMessage("升級失敗");
		return;
	  }
	  
	  payCost(nextUpgrade.cost);
	  building.level++;
	  building.upgradable = checkUpgradable(building.type, building.level);
	  if (building.type.toLowerCase() === "center") {
		updateBuildingsAfterMainBaseUpgrade();
	  }
	  updateEfficiencies();
	  updateAllDisplays();
	  
	  showTempMessage("升級成功");
	  // 注意：此處不自動關閉升級彈窗，便於連續升級
	}





	// 新增：結果提示彈窗函數
	function showResultModal(message) {
	  document.getElementById("resultMessage").textContent = message;
	  showModal("resultModal");
	}

	function closeResultModal() {
	  closeModal("resultModal");
	}

	// 原有的升級菜單函數（修改後使用動態升級資訊）
	function showUpgradeMenu(index) {
	  currentUpgradeIndex = index;
	  const building = gameState.buildings[index];
	  if (!building) return;
	  const config = BUILDINGS[building.type];
	  
	  // 取得當前加成信息（使用當前等級）
	  let currentInfo = "";
	  if (typeof config.getUpgradeInfo === "function") {
		const currentUpgrade = config.getUpgradeInfo(building.level);
		if (currentUpgrade && currentUpgrade.effect) {
		  currentInfo = Object.entries(currentUpgrade.effect)
						 .map(([attr, value]) => `${attr}: +${value}`)
						 .join(", ");
		}
	  }
	  
	  // 取得下一級升級信息（無論是否滿足都顯示）
	  let nextInfo = "";
	  const nextUpgrade = (typeof config.getUpgradeInfo === "function")
							? config.getUpgradeInfo(building.level + 1)
							: null;
	  if (nextUpgrade && nextUpgrade.cost) {
		nextInfo = " ";
		for (let [res, val] of Object.entries(nextUpgrade.cost)) {
		  nextInfo += ` ${res}: ${val}`;
		}
		// 判斷資源是否滿足，如果不滿足則添加提示
		if (!canAfford(nextUpgrade.cost)) {
		  nextInfo += " (未滿足)";
		}
	  } else {
		nextInfo = "已達最高級";
	  }
	  
	  // 組合上半部分內容
	  const upperContent = `當前加成: ${currentInfo}\n升級所需: ${nextInfo}`;
	  
	  document.getElementById("upgradeTitle").textContent = config.name;
	  document.getElementById("upgradeInfo").textContent = upperContent;
	  
	  // 按鈕部分：確認升級按鈕始終顯示；拆除按鈕對中心基地隱藏
	  document.getElementById("confirmUpgradeBtn").style.display = "inline-block";
	  if (building.type.toLowerCase() === "center") {
		document.getElementById("demolishBtn").style.display = "none";
	  } else {
		document.getElementById("demolishBtn").style.display = "inline-block";
	  }
	  
	  showModal("upgradeModal");
	}


	function closeUpgradeModal() {
	  closeModal("upgradeModal");
	}

		function startBuilding(type, index) {
	  const config = BUILDINGS[type];
	  if (!canAfford(config.baseCost)) {
		addEventLog(`❌ 資源不足，無法建造 ${config.name}`, 'epic');
		showResultModal(`建造失敗：資源不足以建造 ${config.name}`);
		return;
	  }
	  payCost(config.baseCost);
	  gameState.buildings[index] = {
		type,
		level: 1,
		upgradable: checkUpgradable(type, 1)
	  };
	  updateEfficiencies();
	  addEventLog(`🏗️ 成功建造 ${config.name}`, 'uncommon');
	  closeModal("buildModal");
	  updateAllDisplays();
	  // 以臨時提示方式告知建造成功（0.3秒後自動消失，不需確認按鍵）
	  showTempMessage(`成功建造 ${config.name}`);
	}

	// 建築互動（包括拆除、查看資訊等）與拆除建築的邏輯

	function showBuildingInteractionMenu(index) {
	  const building = gameState.buildings[index];
	  if (!building) return;
	  const config = BUILDINGS[building.type];

	  // 生成顯示基本資訊的字串
	  const infoStr = `<div class="building-info-popup">
							<p><strong>${config.name}</strong></p>
							<p>目前等級：Lv.${building.level}</p>
						</div>`;

	  // 如果建築可升級，則添加升級按鈕
	  let buttonContent = "";
	  if (building.upgradable) {
		buttonContent += `<button class="modal-btn" onclick="showUpgradeMenu(${index})">升級建築</button>`;
	  }
	  // 僅當該建築不是中心基地時才顯示拆除按鈕
	  if (building.type.toLowerCase() !== "center") {
		buttonContent += `<button class="modal-btn danger" onclick="confirmBuildingRemoval(${index})">拆除建築</button>`;
	  }

	  // 拼接最終的互動內容
	  const interactionContent = infoStr + buttonContent;

	  document.getElementById("interactionContent").innerHTML = interactionContent;
	  document.getElementById("interactionTitle").textContent = config.name;
	  showModal("interactionModal");
	}


	function confirmBuildingRemoval(index) {
	  const building = gameState.buildings[index];
	  if (!building) return;
	  let confirmRemoval = confirm(`確定要拆除 ${BUILDINGS[building.type].name}？此操作不可逆！`);
	  if (!confirmRemoval) return;
	  
	  gameState.buildings[index] = null;
	  addEventLog(`🏗️ ${BUILDINGS[building.type].name} 已被拆除`, "warning");
	  updateAllDisplays();
	  closeModal("interactionModal");
	  showResultModal(`已拆除 ${BUILDINGS[building.type].name}`);
	}

	function showBuildingInfo(index) {
	  const building = gameState.buildings[index];
	  if (building) {
		const config = BUILDINGS[building.type];
		addEventLog(`${config.name} 等級 ${building.level}`, "common");
		showResultModal(`${config.name} 的目前等級：${building.level}`);
	  }
	}


  
    function toggleResource(resource) {
      const detailsElem = document.getElementById(resource + "Details");
      if (detailsElem.style.maxHeight && detailsElem.style.maxHeight !== "0px") {
        detailsElem.style.maxHeight = "0";
      } else {
        detailsElem.style.maxHeight = "100px";
      }
    }
  
    function adjustZombies(dept, amount) {
      if (!gameState.allocations[dept]) gameState.allocations[dept] = 0;
      let newVal = gameState.allocations[dept] + amount;
      if (newVal < 0) newVal = 0;
      const totalAllocated = gameState.allocations.exploration +
                             gameState.allocations.farming +
                             gameState.allocations.recycling +
                             gameState.allocations.research;
      if (totalAllocated + amount > gameState.totalZombies) {
        addEventLog("沒有足夠的僵尸分配", "warning");
        return;
      }
      gameState.allocations[dept] = newVal;
      updateAllDisplays();
    }
  
    function showModal(modalId) {
      const modal = document.getElementById(modalId);
      if (modal) modal.style.display = "flex";
    }
  
    function closeModal(modalId) {
      const modal = document.getElementById(modalId);
      if (modal) modal.style.display = "none";
    }
  
    function closeBuildModal() {
      closeModal("buildModal");
    }
    /***** 輔助函數 結束 *****/
  
    // 遊戲初始化與核心循環
    function initGame() {
      updateAllDisplays();
      initBuildingGrid();
      startGameLoops();
    }
  
    function startGameLoops() {
      gameLoopInterval = setInterval(() => {
        produceResources('farming', 'food', 1.5*5);
        produceResources('recycling', 'materials', 0.5*5);
        produceResources('research', 'tech', 0.2*5);
        produceZombies();
        updateFoodConsumption();
      }, 5000);
      setInterval(() => {
        if (gameState.allocations.exploration > 0) {
          handleExploration();
        }
      }, 5000);
	  setInterval(updateSafetyCenterConsumption, 5000);
	  // 每秒更新僵尸兵營的武器消耗
	  setInterval(updateBarracksWeaponConsumption, 5000);

    }
	
	
    function loadSave() {
      // 如有需要，可在此讀取存檔，本例中直接設定初始部門分配
      gameState.allocations.exploration = 4;
      gameState.allocations.farming = 4;
      gameState.allocations.recycling = 1;
      gameState.allocations.research = 1;
    }
  
    function autoSave() {
      console.log("遊戲已自動存檔");
    }
  
	 
	function showCollection() {
	  // 定義依稀有度排序的順序
	  const rarityOrder = { 
		  divine: 12,      // 神聖的
		  legendary: 11,   // 傳奇的
		  epic: 10,        // 史詩的
		  rare: 9,         // 稀有的
		  tested: 8,       // 歷經考驗的
		  selected: 7,     // 精挑細選的
		  sealed: 6,       // 未開封的
		  decent: 5,       // 看起來不錯的
		  common: 4,       // 正常的
		  damaged: 3,      // 破損的
		  old: 2,          // 陳舊的
		  junk: 1     
	  };
	  // 將 collectedItems 轉換成陣列，每個項目包含：名稱、獲得次數與稀有度
	  let items = Object.keys(collectedItems).map(key => ({
		  name: key,
		  count: collectedItems[key].count,
		  rarity: collectedItems[key].rarity
	  }));
	  // 按照稀有度由高到低排序
	  items.sort((a, b) => (rarityOrder[b.rarity] || 0) - (rarityOrder[a.rarity] || 0));

	  // 組合 HTML：只顯示物品名稱和獲得次數
	  let html = `<table style="width:100%; border-collapse:collapse;"> 
		<thead>
		  <tr>
			<th style="border:1px solid var(--border-color); padding:5px;">物品名稱</th>
			<th style="border:1px solid var(--border-color); padding:5px;">獲得次數</th>
		  </tr>
		</thead>
		<tbody>`;
	  items.forEach(item => {
		  html += `<tr class="${item.rarity}">
			<td style="border:1px solid var(--border-color); padding:5px;">${item.name}</td>
			<td style="border:1px solid var(--border-color); padding:5px;">${item.count}</td>
		  </tr>`;
	  });
	  html += `</tbody></table>`;

	  // 將生成的 HTML 填入彈窗內容容器中
	  document.getElementById("collectionContent").innerHTML = html;
	  updateCollectionCompletion();
	  // 將收藏彈窗打開
	  showModal('favoritesModal');
	}

	
	// 當文件內容完全加載後啟動遊戲
	document.addEventListener("DOMContentLoaded", function() {
		initGame();
		// 假設您的收藏按鈕 ID 為 favoritesBtn
	     const favBtn = document.getElementById("favoritesBtn");
		  if (favBtn) {
			favBtn.addEventListener("click", showCollection);
		  }
		// 記錄計時開始的時間
		let startTime = Date.now();

		// 更新計時器顯示
		function updateTimer() {
		  const now = Date.now();
		  const elapsed = now - startTime; // 毫秒數
		  const seconds = Math.floor((elapsed / 1000) % 60);
		  const minutes = Math.floor((elapsed / 60000) % 60);
		  const hours = Math.floor(elapsed / 3600000);

		  // 補齊兩位數格式
		  const formattedTime = 
			String(hours).padStart(2, '0') + ":" +
			String(minutes).padStart(2, '0') + ":" +
			String(seconds).padStart(2, '0');
		  
		  // 更新 DOM 中計時器顯示
		  const timerElem = document.getElementById('timerValue');
		  if (timerElem) {
			timerElem.textContent = formattedTime;
		  }
		}

		// 每秒更新一次
		setInterval(updateTimer, 1000);
		
		
		// 為所有 modal-overlay 添加事件監聽器
		document.querySelectorAll('.modal-overlay').forEach(overlay => {
		  overlay.addEventListener('click', function(event) {
			// 精确判断点击区域是否为遮罩层本身
			if (event.target === overlay) { 
			  closeModal(overlay.id);
			}
		  });
		});
	});
	</script>
</body>
</html>